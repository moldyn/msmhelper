{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":""},{"location":"#msmhelper","title":"msmhelper","text":"<p>This is a package with helper functions to work with discrete state trajectories and Markov state models. In contrast to pyemma and msmbuilder, it focuses on Markov state modeling based on an already existing state trajectory. Therefore, neither dimensionality reduction methods nor clustering methods are included. For a methodological overview, we recommend Sittel and Stock.</p> <p>This package is published in:</p> <p>msmhelper: A Python Package for Markov State Modeling of Protein Dynamics, D. Nagel, and G. Stock, J. Open Source Soft. 2023 8 (85), 5339, doi: 10.21105/joss.05339</p> <p>We kindly ask you to cite this article in case you use this software package for published works.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Simple usage with sleek function-based API</li> <li>High performance due to numba-optimized source code, checkout the benchmark comparing to PyEMMA</li> <li>Documentation including tutorials</li> <li>Powerful command-line interface (CLI) to create publication-ready figures</li> <li>Supports Python 3.8-3.11</li> </ul>"},{"location":"#implemented-key-functionalities","title":"Implemented Key Functionalities","text":"<ul> <li>Hummer-Szabo projection of optimal dimensionality reduction by Hummer and Szabo 2014</li> <li>Dynamical coring by Nagel et al. 2019</li> <li>Fast extraction of pathways and MSM-based prediction of pathways based on the definition of Nagel et al. 2020</li> <li>Fast calculation of waiting times based on both, state trajectories and MSMs</li> <li>Blazing fast Chapman-Kolmogorov test implementation</li> <li>Entropy-based similarity measure to compare different state discretizations, this method will be published soon in Nagel 2023</li> <li>Contact representation by Nagel et al. 2023 for a compact structural representation of the states</li> <li>Command-line interface providing both, visualization and analysis methods</li> <li>Provide (non-reversible) transition matrix of all states (corresponds in pyemma to <code>connectivity='none', 'all'</code> which will (probably) never be implemented)</li> </ul>"},{"location":"#getting-started","title":"Getting started","text":""},{"location":"#installation","title":"Installation","text":"<p>The package is called <code>msmhelper</code> and is available via PyPI or conda. To install it, simply call: <pre><code>python3 -m pip install --upgrade msmhelper\n</code></pre> or <pre><code>conda install -c conda-forge msmhelper\n</code></pre></p> <p>or for the latest dev version <pre><code># via ssh key\npython3 -m pip install git+ssh://git@github.com/moldyn/msmhelper.git\n\n# or via password-based login\npython3 -m pip install git+https://github.com/moldyn/msmhelper.git\n</code></pre></p>"},{"location":"#documentation-and-tutorials","title":"Documentation and Tutorials","text":"<p>The documentation serves as a comprehensive resource, offering a broad range of information such as general guidelines, API code references, and command line tool details. It also includes a Frequently Asked Questions (FAQ) section and outlines the procedures for contributing to the project.  Moreover, a suite of tutorials is available, covering all the primary functionalities of the package. These tutorials are provided in the form of Jupyter notebooks. You can easily obtain these notebooks either directly from the docs/tutorials directory on our GitHub repository or by clicking the download buttons available on each tutorial page within the documentation.</p> <p>If you prefer, you can compile the documentation on your local machine by executing the following commands:</p> <pre><code># install all additional dependencies\npython -m pip install msmhelper[docs]\n# build the docs inside the site directory\npython -m mkdocs build\n</code></pre>"},{"location":"#shell-completion","title":"Shell Completion","text":"<p>Using the <code>bash</code>, <code>zsh</code> or <code>fish</code> shell click provides an easy way to provide shell completion, checkout the docs. In the case of bash you need to add following line to your <code>~/.bashrc</code> <pre><code>eval \"$(_MSMHELPER_COMPLETE=bash_source msmhelper)\"\n</code></pre> In general one can call the module directly by its entry point <code>$ msmhelper</code> or by calling the module <code>$ python -m msmhelper</code>. The latter method is preferred to ensure using the desired python environment. For enabling the shell completion, the entry point needs to be used.</p>"},{"location":"#usage","title":"Usage","text":"<p>This package offers either a command line interface to run standalone analysis and to create commonly-used figures, or its much more powerful API can be used to embedded it into an existing Python workflow. Check out the documentation for an overview over all modules and some example workflows, and for some examples see the following section. <pre><code>import msmhelper as mh\n\n# open text files\ntraj = mh.openmicrostates(filename, limitsfile)\n# create markov state model\ntmat, states = mh.estimate_markov_model(traj, lagtime=1)\n...\n</code></pre></p>"},{"location":"#hummer-szabo-projection","title":"Hummer-Szabo Projection","text":"<p>In the following we show some sample figures produced directly with the command line tools. For more information on that, there is a tutorial explaining the methods more in depth. In general we can see, that applying the HS-projection removes most projection artifacts based on coarse-graining many microstates into a few macrostates.</p> Method MSM Hummer-Szabo MSM Implied Timescales Chapman-Kolmogorov test Waiting Time Distributions Waiting Times Contact Representation <p>For more examples checkout the tutorials.</p>"},{"location":"#roadmap","title":"Roadmap","text":"<ul> <li>Add Buchete-Hummer test as alternative for the Chapman-Kolmogorov test.</li> <li>Add a numba implementation of a parallelized autocorrelation function estimation.</li> <li>Use static type hints together with beartype</li> </ul>"},{"location":"benchmark/","title":"Benchmark","text":"In\u00a0[1]: Copied! <pre># importing packages needed for benchmark\nimport deeptime\nimport msmhelper as mh\nimport numpy as np\nimport pyemma\nimport prettypyplot as pplt\nfrom matplotlib import pyplot as plt\n\n# change matplotlbiu default style\npplt.use_style(figsize=(6, 2), latex=False)\n\n\n# method to visualize results\ndef visualize_benchmark_results(times, labels, title):\n    fig, ax = plt.subplots()\n\n    times = np.array([t.average for t in times])\n    bar = ax.bar(labels, 1 / times, color=plt.colormaps['paula'].colors)\n    ax.bar_label(bar,\n        labels=[f'x{fac:.1f}' for fac in times[0] / times],\n    )\n    ax.set_ylabel(r'runs per second [1/s]')\n    ax.set_ylim(np.min(1 / times) / 3, np.max(1 / times) * 3)\n    ax.set_yscale('log')\n    \n    # highlight relative performance\n    ax.set_title(title)\n\n\ndef generate_traj(n_steps, n_states):\n    \"\"\"Generate random state trajectory.\"\"\"\n    return np.random.randint(low=1, high=n_states + 1, size=n_steps)\n</pre> # importing packages needed for benchmark import deeptime import msmhelper as mh import numpy as np import pyemma import prettypyplot as pplt from matplotlib import pyplot as plt  # change matplotlbiu default style pplt.use_style(figsize=(6, 2), latex=False)   # method to visualize results def visualize_benchmark_results(times, labels, title):     fig, ax = plt.subplots()      times = np.array([t.average for t in times])     bar = ax.bar(labels, 1 / times, color=plt.colormaps['paula'].colors)     ax.bar_label(bar,         labels=[f'x{fac:.1f}' for fac in times[0] / times],     )     ax.set_ylabel(r'runs per second [1/s]')     ax.set_ylim(np.min(1 / times) / 3, np.max(1 / times) * 3)     ax.set_yscale('log')          # highlight relative performance     ax.set_title(title)   def generate_traj(n_steps, n_states):     \"\"\"Generate random state trajectory.\"\"\"     return np.random.randint(low=1, high=n_states + 1, size=n_steps) In\u00a0[2]: Copied! <pre># create random trajectory\nn_steps = int(1e5)\nn_states = 10\nlagtime = 100\n</pre> # create random trajectory n_steps = int(1e5) n_states = 10 lagtime = 100 <p>Using numba the source code gets compiled just-in-time on the first usage. Hence, we need to run the code once in advance to measure the performance without compilation time. For further informations see the numba docs.</p> In\u00a0[3]: Copied! <pre>traj = generate_traj(n_steps, n_states),\ntmp = mh.msm.estimate_markov_model(traj, lagtime=lagtime)\ntmp = mh.msm.implied_timescales(traj, [lagtime], ntimescales=2)\ntmp = mh.msm.ck_test(traj, [lagtime], tmax=1000)\ntmp = mh.msm.timescales.propagate_MCMC(traj, lagtime, 100)\n</pre> traj = generate_traj(n_steps, n_states), tmp = mh.msm.estimate_markov_model(traj, lagtime=lagtime) tmp = mh.msm.implied_timescales(traj, [lagtime], ntimescales=2) tmp = mh.msm.ck_test(traj, [lagtime], tmax=1000) tmp = mh.msm.timescales.propagate_MCMC(traj, lagtime, 100) <p>In the following, we compare the determination of the Markov State Model from a numpy state trajectory.</p> In\u00a0[4]: Copied! <pre>%%timeit -r 10 -n 1 -q -o traj = generate_traj(n_steps, n_states)\nmsm = mh.msm.estimate_markov_model(traj, lagtime=lagtime)\n</pre> %%timeit -r 10 -n 1 -q -o traj = generate_traj(n_steps, n_states) msm = mh.msm.estimate_markov_model(traj, lagtime=lagtime) Out[4]: <pre>&lt;TimeitResult : 2.51 ms \u00b1 93 \u00b5s per loop (mean \u00b1 std. dev. of 10 runs, 1 loop each)&gt;</pre> In\u00a0[5]: Copied! <pre>time_msm_mh_traj = _\n</pre> time_msm_mh_traj = _ In\u00a0[6]: Copied! <pre>%%timeit -r 10 -n 1 -q -o traj = generate_traj(n_steps, n_states)\npyemma.msm.estimate_markov_model(traj, lag=lagtime, reversible=False)\n</pre> %%timeit -r 10 -n 1 -q -o traj = generate_traj(n_steps, n_states) pyemma.msm.estimate_markov_model(traj, lag=lagtime, reversible=False) Out[6]: <pre>&lt;TimeitResult : 8.67 ms \u00b1 531 \u00b5s per loop (mean \u00b1 std. dev. of 10 runs, 1 loop each)&gt;</pre> In\u00a0[7]: Copied! <pre>time_msm_pyemma_nonrev = _\n</pre> time_msm_pyemma_nonrev = _ In\u00a0[8]: Copied! <pre>%%timeit -r 10 -n 1 -q -o traj = generate_traj(n_steps, n_states)\npyemma.msm.estimate_markov_model(traj, lag=lagtime)\n</pre> %%timeit -r 10 -n 1 -q -o traj = generate_traj(n_steps, n_states) pyemma.msm.estimate_markov_model(traj, lag=lagtime) Out[8]: <pre>&lt;TimeitResult : 8.24 ms \u00b1 335 \u00b5s per loop (mean \u00b1 std. dev. of 10 runs, 1 loop each)&gt;</pre> In\u00a0[9]: Copied! <pre>time_msm_pyemma_rev = _\n</pre> time_msm_pyemma_rev = _ <p>If you have already formatted the trajectory, msmhelper is even significantly faster:</p> In\u00a0[10]: Copied! <pre>%%timeit -r 10 -n 1 -q -o traj = mh.StateTraj(generate_traj(n_steps, n_states))\ntraj.estimate_markov_model(lagtime=lagtime)\n</pre> %%timeit -r 10 -n 1 -q -o traj = mh.StateTraj(generate_traj(n_steps, n_states)) traj.estimate_markov_model(lagtime=lagtime) Out[10]: <pre>&lt;TimeitResult : 305 \u00b5s \u00b1 30.4 \u00b5s per loop (mean \u00b1 std. dev. of 10 runs, 1 loop each)&gt;</pre> <p>Comparing to deeptime we face the issue, that only index trajectories are accepted. Hence, we need to shift it first.</p> In\u00a0[11]: Copied! <pre>time_msm_mh_statetraj = _\n</pre> time_msm_mh_statetraj = _ In\u00a0[12]: Copied! <pre>%%timeit -r 10 -n 1 -q -o traj = generate_traj(n_steps, n_states)\n# shift trajector to idx trajectory\ntraj = mh.utils.rename_by_index(traj)\ndeeptime.markov.msm.MaximumLikelihoodMSM(\n    reversible=True,\n).fit_fetch(\n    deeptime.markov.TransitionCountEstimator(\n        lagtime=lagtime,\n        count_mode='sliding',\n    ).fit_fetch(traj),\n    lagtime=lagtime,\n)\n</pre> %%timeit -r 10 -n 1 -q -o traj = generate_traj(n_steps, n_states) # shift trajector to idx trajectory traj = mh.utils.rename_by_index(traj) deeptime.markov.msm.MaximumLikelihoodMSM(     reversible=True, ).fit_fetch(     deeptime.markov.TransitionCountEstimator(         lagtime=lagtime,         count_mode='sliding',     ).fit_fetch(traj),     lagtime=lagtime, ) Out[12]: <pre>&lt;TimeitResult : 4.31 ms \u00b1 427 \u00b5s per loop (mean \u00b1 std. dev. of 10 runs, 1 loop each)&gt;</pre> In\u00a0[13]: Copied! <pre>time_msm_deeptime = _\n</pre> time_msm_deeptime = _ <p>Comparing the perforamance we find</p> In\u00a0[14]: Copied! <pre>visualize_benchmark_results(\n    (time_msm_pyemma_nonrev, time_msm_pyemma_rev, time_msm_mh_traj, time_msm_mh_statetraj, time_msm_deeptime),\n    ('PyEMMA\\n non-reversible', 'PyEMMA\\n reversible', 'msmhelper\\n numpy', 'msmhelper\\n StateTraj', 'deeptime\\n reversible'),\n    f'Benchmarking MSM estimation with $N_\\mathrm{{steps}}=10^{np.log10(n_steps):.0f}$ and {n_states} states',\n)\n</pre> visualize_benchmark_results(     (time_msm_pyemma_nonrev, time_msm_pyemma_rev, time_msm_mh_traj, time_msm_mh_statetraj, time_msm_deeptime),     ('PyEMMA\\n non-reversible', 'PyEMMA\\n reversible', 'msmhelper\\n numpy', 'msmhelper\\n StateTraj', 'deeptime\\n reversible'),     f'Benchmarking MSM estimation with $N_\\mathrm{{steps}}=10^{np.log10(n_steps):.0f}$ and {n_states} states', ) <p>Increasing the number of states and steps we find:</p> In\u00a0[15]: Copied! <pre># create random trajectory with more states and frames\nn_steps = int(1e7)\nn_states = 100\n</pre> # create random trajectory with more states and frames n_steps = int(1e7) n_states = 100 In\u00a0[16]: Copied! <pre>%%timeit -r 5 -n 1 -q -o traj = mh.StateTraj(generate_traj(n_steps, n_states))\ntraj.estimate_markov_model(lagtime=lagtime)\n</pre> %%timeit -r 5 -n 1 -q -o traj = mh.StateTraj(generate_traj(n_steps, n_states)) traj.estimate_markov_model(lagtime=lagtime) Out[16]: <pre>&lt;TimeitResult : 26.9 ms \u00b1 230 \u00b5s per loop (mean \u00b1 std. dev. of 5 runs, 1 loop each)&gt;</pre> In\u00a0[17]: Copied! <pre>time_msm_mh_statetraj = _\n</pre> time_msm_mh_statetraj = _ In\u00a0[18]: Copied! <pre>%%timeit -r 5 -n 1 -q -o traj = generate_traj(n_steps, n_states)\nmh.msm.estimate_markov_model(traj, lagtime=lagtime)\n</pre> %%timeit -r 5 -n 1 -q -o traj = generate_traj(n_steps, n_states) mh.msm.estimate_markov_model(traj, lagtime=lagtime) Out[18]: <pre>&lt;TimeitResult : 374 ms \u00b1 4.53 ms per loop (mean \u00b1 std. dev. of 5 runs, 1 loop each)&gt;</pre> In\u00a0[19]: Copied! <pre>time_msm_mh_traj = _\n</pre> time_msm_mh_traj = _ In\u00a0[20]: Copied! <pre>%%timeit -r 5 -n 1 -q -o traj = generate_traj(n_steps, n_states)\npyemma.msm.estimate_markov_model(traj, lag=lagtime, reversible=False)\n</pre> %%timeit -r 5 -n 1 -q -o traj = generate_traj(n_steps, n_states) pyemma.msm.estimate_markov_model(traj, lag=lagtime, reversible=False) Out[20]: <pre>&lt;TimeitResult : 731 ms \u00b1 1.67 ms per loop (mean \u00b1 std. dev. of 5 runs, 1 loop each)&gt;</pre> In\u00a0[21]: Copied! <pre>time_msm_pyemma_nonrev = _\n</pre> time_msm_pyemma_nonrev = _ In\u00a0[22]: Copied! <pre>%%timeit -r 5 -n 1 -q -o traj = generate_traj(n_steps, n_states)\npyemma.msm.estimate_markov_model(traj, lag=lagtime, reversible=True)\n</pre> %%timeit -r 5 -n 1 -q -o traj = generate_traj(n_steps, n_states) pyemma.msm.estimate_markov_model(traj, lag=lagtime, reversible=True) Out[22]: <pre>&lt;TimeitResult : 733 ms \u00b1 3.56 ms per loop (mean \u00b1 std. dev. of 5 runs, 1 loop each)&gt;</pre> In\u00a0[23]: Copied! <pre>time_msm_pyemma_rev = _\n</pre> time_msm_pyemma_rev = _ In\u00a0[24]: Copied! <pre>visualize_benchmark_results(\n    (time_msm_pyemma_nonrev, time_msm_pyemma_rev, time_msm_mh_traj, time_msm_mh_statetraj),\n    ('PyEMMA\\n non-reversible', 'PyEMMA\\n reversible', 'msmhelper\\n numpy', 'msmhelper\\n StateTraj'),\n    f'Benchmarking MSM estimation with $N_\\mathrm{{steps}}=10^{np.log10(n_steps):.0f}$ and {n_states} states',\n)\n</pre> visualize_benchmark_results(     (time_msm_pyemma_nonrev, time_msm_pyemma_rev, time_msm_mh_traj, time_msm_mh_statetraj),     ('PyEMMA\\n non-reversible', 'PyEMMA\\n reversible', 'msmhelper\\n numpy', 'msmhelper\\n StateTraj'),     f'Benchmarking MSM estimation with $N_\\mathrm{{steps}}=10^{np.log10(n_steps):.0f}$ and {n_states} states', ) In\u00a0[25]: Copied! <pre># create random trajectory\nn_steps = int(1e5)\nn_states = 10\nn_timescales = 2\n\n# creating lagtimes\nlagtimes = np.unique(np.geomspace(1, 100, 20).astype(int))\nprint(f'lagtimes: {\", \".join(lagtimes.astype(str))}')\n\n# catch warnings, because random state trajectory has mainly complex eigenvalues\nimport warnings\n</pre> # create random trajectory n_steps = int(1e5) n_states = 10 n_timescales = 2  # creating lagtimes lagtimes = np.unique(np.geomspace(1, 100, 20).astype(int)) print(f'lagtimes: {\", \".join(lagtimes.astype(str))}')  # catch warnings, because random state trajectory has mainly complex eigenvalues import warnings <pre>lagtimes: 1, 2, 3, 4, 5, 6, 8, 11, 14, 18, 23, 29, 37, 48, 61, 78, 100\n</pre> In\u00a0[26]: Copied! <pre>%%timeit -r 5 -n 1 -q -o traj = generate_traj(n_steps, n_states)\nwith warnings.catch_warnings():\n    warnings.simplefilter('ignore')\n    mh.msm.implied_timescales(traj, lagtimes, ntimescales=n_timescales)\n</pre> %%timeit -r 5 -n 1 -q -o traj = generate_traj(n_steps, n_states) with warnings.catch_warnings():     warnings.simplefilter('ignore')     mh.msm.implied_timescales(traj, lagtimes, ntimescales=n_timescales) Out[26]: <pre>&lt;TimeitResult : 11.6 ms \u00b1 1.26 ms per loop (mean \u00b1 std. dev. of 5 runs, 1 loop each)&gt;</pre> In\u00a0[27]: Copied! <pre>time_impl_mh = _\n</pre> time_impl_mh = _ In\u00a0[28]: Copied! <pre>%%timeit -r 5 -n 1 -q -o traj = generate_traj(n_steps, n_states)\nwith warnings.catch_warnings():\n    warnings.simplefilter('ignore')\n    pyemma.msm.its(\n        traj,\n        lagtimes,\n        nits=n_timescales,\n        show_progress=False,\n        reversible=False,\n        n_jobs=1,  # keeping this to None it does not work with PyEMMA 2.5.12\n    ).timescales\n</pre> %%timeit -r 5 -n 1 -q -o traj = generate_traj(n_steps, n_states) with warnings.catch_warnings():     warnings.simplefilter('ignore')     pyemma.msm.its(         traj,         lagtimes,         nits=n_timescales,         show_progress=False,         reversible=False,         n_jobs=1,  # keeping this to None it does not work with PyEMMA 2.5.12     ).timescales Out[28]: <pre>&lt;TimeitResult : 199 ms \u00b1 65.4 ms per loop (mean \u00b1 std. dev. of 5 runs, 1 loop each)&gt;</pre> In\u00a0[29]: Copied! <pre>time_impl_pyemma = _\n</pre> time_impl_pyemma = _ In\u00a0[30]: Copied! <pre>visualize_benchmark_results(\n    (time_impl_pyemma, time_impl_mh),\n    ('PyEMMA', 'msmhelper'),\n    f'Benchmarking Implied Timescale',\n)\n</pre> visualize_benchmark_results(     (time_impl_pyemma, time_impl_mh),     ('PyEMMA', 'msmhelper'),     f'Benchmarking Implied Timescale', ) In\u00a0[31]: Copied! <pre>%%timeit -r 5 -n 1 -q -o traj = generate_traj(n_steps, n_states)\nmh.msm.ck_test(traj, lagtimes, tmax=1000)\n</pre> %%timeit -r 5 -n 1 -q -o traj = generate_traj(n_steps, n_states) mh.msm.ck_test(traj, lagtimes, tmax=1000) Out[31]: <pre>&lt;TimeitResult : 38.6 ms \u00b1 260 \u00b5s per loop (mean \u00b1 std. dev. of 5 runs, 1 loop each)&gt;</pre> In\u00a0[32]: Copied! <pre>time_cktest_mh = _\n</pre> time_cktest_mh = _ In\u00a0[33]: Copied! <pre>%%timeit -r 5 -n 1 -q -o traj = generate_traj(n_steps, n_states)\nfor lagtime in lagtimes:\n    msm = pyemma.msm.estimate_markov_model(traj, lag=lagtime)\n    msm.cktest(2, n_jobs=1, show_progress=False)\n</pre> %%timeit -r 5 -n 1 -q -o traj = generate_traj(n_steps, n_states) for lagtime in lagtimes:     msm = pyemma.msm.estimate_markov_model(traj, lag=lagtime)     msm.cktest(2, n_jobs=1, show_progress=False) Out[33]: <pre>&lt;TimeitResult : 2.01 s \u00b1 26.4 ms per loop (mean \u00b1 std. dev. of 5 runs, 1 loop each)&gt;</pre> In\u00a0[34]: Copied! <pre>time_cktest_pyemma = _\n</pre> time_cktest_pyemma = _ In\u00a0[35]: Copied! <pre>%%timeit -r 5 -n 1 -q -o traj = generate_traj(n_steps, n_states)\ntraj = mh.utils.rename_by_index(traj)\nmodels = [\n    deeptime.markov.msm.MaximumLikelihoodMSM(\n        reversible=True,\n    ).fit_fetch(\n        deeptime.markov.TransitionCountEstimator(\n            lagtime=lagtime,\n            count_mode='sliding',\n        ).fit_fetch(traj),\n        lagtime=lagtime,\n    )\n    for lagtime in lagtimes\n]\nmodels[0].ck_test(models, n_metastable_sets=n_states)\n</pre> %%timeit -r 5 -n 1 -q -o traj = generate_traj(n_steps, n_states) traj = mh.utils.rename_by_index(traj) models = [     deeptime.markov.msm.MaximumLikelihoodMSM(         reversible=True,     ).fit_fetch(         deeptime.markov.TransitionCountEstimator(             lagtime=lagtime,             count_mode='sliding',         ).fit_fetch(traj),         lagtime=lagtime,     )     for lagtime in lagtimes ] models[0].ck_test(models, n_metastable_sets=n_states) Out[35]: <pre>&lt;TimeitResult : 1.03 s \u00b1 30.4 ms per loop (mean \u00b1 std. dev. of 5 runs, 1 loop each)&gt;</pre> In\u00a0[36]: Copied! <pre>time_cktest_deeptime = _\n</pre> time_cktest_deeptime = _ In\u00a0[37]: Copied! <pre>visualize_benchmark_results(\n    (time_cktest_pyemma, time_cktest_deeptime, time_cktest_mh),\n    ('PyEMMA', 'deeptime', 'msmhelper'),\n    f'Benchmarking Chapman-Kolmogorov Test',\n)\n</pre> visualize_benchmark_results(     (time_cktest_pyemma, time_cktest_deeptime, time_cktest_mh),     ('PyEMMA', 'deeptime', 'msmhelper'),     f'Benchmarking Chapman-Kolmogorov Test', ) In\u00a0[38]: Copied! <pre># decrease number of steps to speed up msm estimation\nn_steps = int(1e5)\nn_states = 10\n\n# number to propagate MCMC\nn_mcmc_steps = int(1e5)\n</pre> # decrease number of steps to speed up msm estimation n_steps = int(1e5) n_states = 10  # number to propagate MCMC n_mcmc_steps = int(1e5) In\u00a0[39]: Copied! <pre>%%timeit -r 5 -n 1 -q -o traj = mh.StateTraj(generate_traj(n_steps, n_states))\nmcmc = mh.msm.timescales.propagate_MCMC(traj, lagtime, n_mcmc_steps)\n</pre> %%timeit -r 5 -n 1 -q -o traj = mh.StateTraj(generate_traj(n_steps, n_states)) mcmc = mh.msm.timescales.propagate_MCMC(traj, lagtime, n_mcmc_steps) Out[39]: <pre>&lt;TimeitResult : 5.41 ms \u00b1 63.7 \u00b5s per loop (mean \u00b1 std. dev. of 5 runs, 1 loop each)&gt;</pre> In\u00a0[40]: Copied! <pre>time_mcmc_mh = _\n</pre> time_mcmc_mh = _ In\u00a0[41]: Copied! <pre>%%timeit -r 5 -n 1 -q -o traj = generate_traj(n_steps, n_states)\nmcmc = pyemma.msm.estimate_markov_model(traj, lag=lagtime).generate_traj(n_mcmc_steps)\n</pre> %%timeit -r 5 -n 1 -q -o traj = generate_traj(n_steps, n_states) mcmc = pyemma.msm.estimate_markov_model(traj, lag=lagtime).generate_traj(n_mcmc_steps) Out[41]: <pre>&lt;TimeitResult : 457 ms \u00b1 3.66 ms per loop (mean \u00b1 std. dev. of 5 runs, 1 loop each)&gt;</pre> In\u00a0[42]: Copied! <pre>time_mcmc_pyemma = _\n</pre> time_mcmc_pyemma = _ In\u00a0[43]: Copied! <pre>%%timeit -r 5 -n 1 -q -o traj = generate_traj(n_steps, n_states)\ntraj = mh.utils.rename_by_index(traj)\nmcmc = deeptime.markov.msm.MaximumLikelihoodMSM(\n    reversible=True,\n).fit_fetch(\n    deeptime.markov.TransitionCountEstimator(\n        lagtime=lagtime,\n        count_mode='sliding',\n    ).fit_fetch(traj),\n    lagtime=lagtime,\n).simulate(n_mcmc_steps)\n</pre> %%timeit -r 5 -n 1 -q -o traj = generate_traj(n_steps, n_states) traj = mh.utils.rename_by_index(traj) mcmc = deeptime.markov.msm.MaximumLikelihoodMSM(     reversible=True, ).fit_fetch(     deeptime.markov.TransitionCountEstimator(         lagtime=lagtime,         count_mode='sliding',     ).fit_fetch(traj),     lagtime=lagtime, ).simulate(n_mcmc_steps) Out[43]: <pre>&lt;TimeitResult : 17.3 ms \u00b1 206 \u00b5s per loop (mean \u00b1 std. dev. of 5 runs, 1 loop each)&gt;</pre> In\u00a0[44]: Copied! <pre>time_mcmc_deeptime = _\n</pre> time_mcmc_deeptime = _ In\u00a0[45]: Copied! <pre>visualize_benchmark_results(\n    (time_mcmc_pyemma, time_mcmc_deeptime, time_mcmc_mh),\n    ('PyEMMA', 'deeptime', 'msmhelper'),\n    f'Benchmarking Markov Chain Monte Carlo Propagation',\n)\n</pre> visualize_benchmark_results(     (time_mcmc_pyemma, time_mcmc_deeptime, time_mcmc_mh),     ('PyEMMA', 'deeptime', 'msmhelper'),     f'Benchmarking Markov Chain Monte Carlo Propagation', )"},{"location":"benchmark/#benchmark","title":"Benchmark\u00b6","text":""},{"location":"benchmark/#a-performance-comparison-to-pyemma-and-deeptime","title":"A Performance Comparison to PyEMMA (and deeptime)\u00b6","text":"<p>In the following comparison we want to show that the performance of msmhelper is competitive to that of PyEMMA. It should be kept in mind that while both packages focus on the construction and analysis of MSM, PyEMMA has much more functionality and both packages approach Markov State modeling with a different philosophy. Nevertheless, in the following we will compare a few functions that both packages provide. We will ignore the linear algebra methods, since both packages rely on numpy.</p> <p>A comparison to PyEMMA's successor, deeptime, has been added. However, it should be noted that while PyEMMA's focus was on MSM analysis, deeptime's focus is on modern machine learning analysis. Therefore, the comparison should not be seen as a benchmark but rather as a rough baseline.</p> <p>In general, performance depends very much on the architecture and Python/package versions. Therefore, it is best to look at the benchmark results on your own device. To do this, you can simply download the Jupyter Notebook from the icon above.</p>"},{"location":"benchmark/#estimation-of-a-markov-state-model","title":"Estimation of a Markov State Model\u00b6","text":""},{"location":"benchmark/#estimation-of-implied-timescales","title":"Estimation of Implied Timescales\u00b6","text":"<p>An important property of Markov State models are the implied time scales. These correspond to the $i$-th eigenvalue $\\lambda_i$ of the transition matrix $T_{ij}$ and are defined by $$t_i = - \\frac{t_\\text{lag}}{\\log(\\lambda_i)}$$</p>"},{"location":"benchmark/#chapman-kolmogorov-test","title":"Chapman-Kolmogorov Test\u00b6","text":"<p>The most important test to check the Markovianity of a MSM is the Chapman-Kolmogorov test which visualizes the agreement of the Chapman-Kolomogorov equation $$T(\\tau n) = T^n(\\tau)$$ The following comparison is not easy to interpret, because both packages do not determine the same thing. However, it should be sufficient to get a feeling.</p>"},{"location":"benchmark/#propagating-a-markov-chain-monte-carlo","title":"Propagating a Markov Chain Monte Carlo\u00b6","text":"<p>We now consider the propagation of a Markov chain Monte Carlo, since this plays a central role in the package msmhelper to estimate the time scales.</p>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is inspired by Keep a Changelog, and Element and this project adheres to Semantic Versioning.</p>"},{"location":"changelog/#unreleased","title":"Unreleased","text":""},{"location":"changelog/#added-features-and-improvements","title":"Added Features and Improvements \ud83d\ude4c:","text":"<ul> <li>Supporting latest Python 3.12 \ud83c\udf89</li> </ul>"},{"location":"changelog/#other-changes","title":"Other changes:","text":"<ul> <li>Support latest version of <code>pplt</code></li> <li>Fix docs</li> </ul>"},{"location":"changelog/#111-2023-11-10","title":"1.1.1 - 2023-11-10","text":""},{"location":"changelog/#bugfix","title":"Bugfix \ud83d\udc1b:","text":"<ul> <li>Fix mutable properties of <code>mh.StateTraj</code> and <code>mh.LumpedStateTraj</code>, #43</li> </ul>"},{"location":"changelog/#other-changes_1","title":"Other changes:","text":"<ul> <li>Improved performance of <code>mh.LumpedStateTraj.microtrajs</code></li> </ul>"},{"location":"changelog/#110-2023-11-03","title":"1.1.0 - 2023-11-03","text":""},{"location":"changelog/#api-changes-warning","title":"API changes warning \u26a0\ufe0f:","text":"<ul> <li>Python 3.7 support was dropped!</li> </ul>"},{"location":"changelog/#added-features-and-improvements_1","title":"Added Features and Improvements \ud83d\ude4c:","text":"<ul> <li>Supporting latest Python 3.11 \ud83c\udf89</li> </ul>"},{"location":"changelog/#bugfix_1","title":"Bugfix \ud83d\udc1b:","text":"<ul> <li>Fixed wrong connectivity in <code>mh.datasets.utils.propagate_MCMC</code> for different datatypes, #39</li> </ul>"},{"location":"changelog/#104-2023-05-22","title":"1.0.4 - 2023-05-22","text":""},{"location":"changelog/#other-changes_2","title":"Other changes:","text":"<ul> <li>Improvements of the README and the documentation, suggested by the JOSS reviewers @yuxuanzhuang and @lorenzo-rovigatti</li> <li>Added zenodo setup</li> <li>Added issue templates</li> </ul>"},{"location":"changelog/#103-2023-04-17","title":"1.0.3 - 2023-04-17","text":""},{"location":"changelog/#bugfix_2","title":"Bugfix \ud83d\udc1b:","text":"<ul> <li>Fix that <code>mh.LumpedStateTraj.index_trajs</code> and <code>mh.LumpedStateTraj.index_trajs_flatten</code> return now index trajectories corresponding to the macrostate trajectories</li> </ul>"},{"location":"changelog/#other-changes_3","title":"Other changes:","text":"<ul> <li>Improve the x-axis limits, use more distinguishable colors, and lower the number of bins for the MD for the cli <code>msmhelper waiting-times</code></li> <li>Updated contribution and added maintenance guidelines</li> <li>Minor improvements of docs suggested by JOSS reviewer</li> </ul>"},{"location":"changelog/#102-2023-03-13","title":"1.0.2 - 2023-03-13","text":""},{"location":"changelog/#added-features-and-improvements_2","title":"Added Features and Improvements \ud83d\ude4c:","text":"<ul> <li>Added cli for <code>compare-discretization</code></li> </ul>"},{"location":"changelog/#bugfix_3","title":"Bugfix \ud83d\udc1b:","text":"<ul> <li>Fix missing import of <code>msm.utils.linalg</code> when importing <code>msm.utils</code></li> <li>Fix bug of similarity measure (<code>mh.md.compare_discretization</code>) being infinite</li> </ul>"},{"location":"changelog/#101-2023-03-08","title":"1.0.1 - 2023-03-08","text":""},{"location":"changelog/#other-changes_4","title":"Other changes:","text":"<ul> <li>Added basic test for <code>msmhelper waiting-times</code> command-line interface</li> <li>Using scientific y-labels for <code>msmhelper waiting-times</code> and <code>msmhelper waiting-time-dist</code> command-line interfaces to improve figures for real data</li> </ul>"},{"location":"changelog/#bugfix_4","title":"Bugfix \ud83d\udc1b:","text":"<ul> <li>Fix bug where <code>--frames-per-unit</code> and <code>unit</code> where neglected in the cli <code>msmhelper waiting-time-dist</code></li> <li>Fix undesired behavior where <code>msmhelper implied-timescales</code> used gray spines instead of true black</li> </ul>"},{"location":"changelog/#100-2023-03-03","title":"1.0.0 - 2023-03-03","text":""},{"location":"changelog/#api-changes-warning_1","title":"API changes warning \u26a0\ufe0f:","text":"<ul> <li>Completely refactoring of the API, this release has many breaking changes to v0.6.2</li> <li>Renamed module <code>iotext</code> to <code>io</code></li> <li>Moved all functions related to msm to <code>msm</code> module</li> <li>Moved all functions related to raw state trajectories to <code>md</code> module</li> <li>Moved all remaining functions into <code>utils</code> module</li> <li>Removed <code>StateTraj.trajs</code> property to reduce confusion between index and   state trajectories.</li> <li>Removed Python 3.6 support.</li> </ul>"},{"location":"changelog/#added-features-and-improvements_3","title":"Added Features and Improvements \ud83d\ude4c:","text":"<ul> <li>Add an all new mkdocs documentation with material design \ud83c\udf89</li> <li>Add a command line interface for standalone tasks \ud83c\udf89</li> <li>Add follow-along tutorials, FAQ, and better code references \ud83c\udf89</li> <li>Add the submodule <code>plot</code> to create commonly-used figures</li> <li>Improved MSM generation by a factor of 2-3 for continuously named states.</li> </ul>"},{"location":"changelog/#other-changes_5","title":"Other changes:","text":"<ul> <li>Add <code>gaussian_filter</code> functionality</li> <li>Add implementation of <code>dynamical_coring</code></li> <li>Add estimation of transition times</li> <li>Add contact representation of states</li> <li>And many more improvements</li> </ul>"},{"location":"changelog/#bugfix_5","title":"Bugfix \ud83d\udc1b:","text":"<ul> <li>Fixed bug where <code>propagate_MCMC</code> returns index trajectory instead of a state trajectory</li> </ul>"},{"location":"changelog/#062-2022-09-20","title":"0.6.2 - 2022-09-20","text":""},{"location":"changelog/#other-changes_6","title":"Other changes:","text":"<ul> <li>Moved to package to src directory</li> <li>Add <code>nvals</code> parameter to all eigenvalues/-vectors functions</li> <li>Add <code>ntimescales</code> parameter to <code>implied_timescales</code></li> <li>Improved tests for <code>implied_timescales</code></li> </ul>"},{"location":"changelog/#bugfix_6","title":"Bugfix \ud83d\udc1b:","text":"<ul> <li>Fix complex matrices for LumpedStateTraj due to complex eigenvalues</li> </ul>"},{"location":"changelog/#061-2022-08-01","title":"0.6.1 - 2022-08-01","text":""},{"location":"changelog/#bugfix_7","title":"Bugfix \ud83d\udc1b:","text":"<ul> <li>Include extra-requirements via MANIFEST.in</li> </ul>"},{"location":"changelog/#060-2022-08-01","title":"0.6.0 - 2022-08-01","text":""},{"location":"changelog/#api-changes-warning_2","title":"API changes warning \u26a0\ufe0f:","text":"<ul> <li>Remove <code>pyemma</code> to ensure better pip support</li> <li>Remove <code>build_MSM</code> use instead <code>estimate_markov_model</code></li> </ul>"},{"location":"changelog/#added-features-and-improvements_4","title":"Added Features and Improvements \ud83d\ude4c:","text":"<ul> <li>Upload test coverage to Codecov</li> <li>Add extra-requirements to pip installation</li> <li>Added Changelog file </li> <li>Add new parameter <code>allow_non_ergodic</code> to <code>mh.equilibrium_population</code></li> <li>Upload docs to gh-pages </li> <li>Add module <code>md</code> with functions for estimating timescales and pathways</li> </ul>"},{"location":"changelog/#other-changes_7","title":"Other changes:","text":"<ul> <li>Added <code>beartype</code> dependency for adding dynamic type checking</li> <li>Parallelize and refactor <code>compare_discretization</code></li> <li>replaced decorators with <code>decorit</code> package</li> </ul>"},{"location":"changelog/#bugfix_8","title":"Bugfix \ud83d\udc1b:","text":"<ul> <li>Fix source code rendering in documentation</li> <li>Fix deprecated warnings of <code>numpy</code> and <code>pytest</code></li> <li>Fix most LGTM warnings</li> <li>Many more minor fixes</li> <li>Add parameter <code>atol</code> to tests functions to make them more robust</li> </ul>"},{"location":"changelog/#050-2021-07-22","title":"0.5.0 - 2021-07-22","text":""},{"location":"changelog/#added-features-and-improvements_5","title":"Added Features and Improvements \ud83d\ude4c:","text":"<ul> <li>Add <code>LumpedStateTraj</code> class which allows optimal projection of microstate dynamics to macrostates, method taken from Szabo and Hummer</li> <li>Add estimation of MD waiting times</li> <li>Add tests for <code>is_transition_matrix</code>, <code>is_ergodic</code></li> </ul>"},{"location":"changelog/#bugfix_9","title":"Bugfix \ud83d\udc1b:","text":"<ul> <li>Minor improvements and tweaks.</li> </ul>"},{"location":"changelog/#other-changes_8","title":"Other changes:","text":""},{"location":"changelog/#040-2020-09-14","title":"0.4.0 - 2020-09-14","text":""},{"location":"changelog/#api-changes-warning_3","title":"API changes warning \u26a0\ufe0f:","text":"<ul> <li>Removed <code>n_iterations</code> parameter from <code>Clustering</code></li> </ul>"},{"location":"changelog/#added-features-and-improvements_6","title":"Added Features and Improvements \ud83d\ude4c:","text":"<ul> <li>Added clustering mode <code>mode='kmedoids'</code> for k-medoids clustering</li> <li>Added tools module to reopen clusters</li> </ul>"},{"location":"changelog/#other-changes_9","title":"Other changes:","text":"<ul> <li>Improved some test functions</li> </ul>"},{"location":"changelog/#030-2020-08-25","title":"0.3.0 - 2020-08-25","text":""},{"location":"changelog/#added-features-and-improvements_7","title":"Added Features and Improvements \ud83d\ude4c:","text":"<ul> <li>Add <code>StateTraj</code> class to speed up calcualations by a factor of 50.</li> <li>Refactor code to use/be compatible with <code>StateTraj</code> class</li> <li>Add <code>benchmark</code> module with an numba optimized version of the Chapman-Kolmogorov test</li> <li>Add function for estimating implied timescales</li> </ul>"},{"location":"changelog/#bugfix_10","title":"Bugfix \ud83d\udc1b:","text":"<ul> <li>Minor bug fixes and im</li> </ul>"},{"location":"changelog/#other-changes_10","title":"Other changes:","text":"<ul> <li>Improving documentation/docstrings</li> <li>Adding tests including benchmarks</li> </ul>"},{"location":"changelog/#020-2020-08-14","title":"0.2.0 - 2020-08-14","text":""},{"location":"changelog/#added-features-and-improvements_8","title":"Added Features and Improvements \ud83d\ude4c:","text":"<ul> <li>Major speed improvement by rewriting parts of msm module with numba</li> </ul>"},{"location":"changelog/#010-2020-02-20","title":"0.1.0 - 2020-02-20","text":"<ul> <li>Initial release</li> </ul>"},{"location":"contributing/","title":"Welcome to the <code>msmhelper</code> Contributing Guide","text":"<p>This guide will give you an overview of the contribution workflow from opening an issue and creating a PR. To get an overview of the project, read the module overview.</p>"},{"location":"contributing/#issues","title":"Issues","text":""},{"location":"contributing/#create-a-new-issue","title":"Create a new issue","text":"<p>If you spot a bug, want to request a new functionality, or have a question on how to use the module, please search if an issue already exists. If a related issue does not exist, feel free to open a new issue.</p>"},{"location":"contributing/#solve-an-issue","title":"Solve an issue","text":"<p>If you want to contribute and do not how, feel free to scan through the existing issues.</p>"},{"location":"contributing/#create-a-new-pull-request","title":"Create a new pull request","text":""},{"location":"contributing/#create-a-fork","title":"Create a fork","text":"<p>If you want to request a change, you first have to fork the repository.</p>"},{"location":"contributing/#setup-a-development-environment","title":"Setup a development environment","text":"bash + condabash + venvzsh + condazsh + venv <pre><code>conda create -n msmhelper -c conda-forge python=3.11\nconda activate msmhelper\npython -m pip install -e .[all]\n</code></pre> <pre><code>python -m venv ./msmhelper\nsource ./msmhelper/bin/activate\npython -m pip install -e .[all]\n</code></pre> <pre><code>conda create -n msmhelper -c conda-forge python=3.11\nconda activate msmhelper\npython -m pip install -e .\\[all]\n</code></pre> <pre><code>python -m venv ./msmhelper\nsource ./msmhelper/bin/activate\npython -m pip install -e .\\[all]\n</code></pre>"},{"location":"contributing/#make-changes-and-run-tests","title":"Make changes and run tests","text":"<p>Apply your changes and check if you followed the coding style (PEP8) by running <pre><code>python -m flake8 --config flake8-CI.cfg\n</code></pre> All errors pointing to <code>./build/</code> can be neglected.</p> <p>If you add a new function/method/class please ensure that you add a test function, as well. Running the test simply by <pre><code>python -m pytest --no-cov\nexport NUMBA_DISABLE_JIT=1 &amp;&amp; python -m pytest\n</code></pre> Ensure that the coverage does not decrease.</p>"},{"location":"contributing/#open-a-pull-request","title":"Open a pull request","text":"<p>Now you are ready to open a pull request and please do not forget to add a description.</p>"},{"location":"faq/","title":"Frequently Asked Questions","text":""},{"location":"faq/#is-tij-going-from-i-to-j-or-j-to-i","title":"Is T<sub>ij</sub> going from i to j or j to i?","text":"<p>This is a confusing topic and depending on the field, other conventions are used. Here, we rely on the definition that \\(T_{ij}\\) is the probability that we jump from \\(i\\to j\\). This means\u2014due to probability conversation\u2014that we have a row-normalized transition matrix \\(1 = \\sum_j T_{ij}\\) and that we need to estimate the left-handed eigenvectors for estimating the stationary distribution or implied timescales.</p>"},{"location":"faq/#is-python-37-supported","title":"Is Python 3.7 supported?","text":"<p>Starting from version 1.1.x Python 3.7 supported will be dropped, due to its EOL status. If support is needed, please use the latest 1.0.x version.</p>"},{"location":"faq/#how-is-the-performance-compared-to-pyemma","title":"How is the performance compared to PyEmma?","text":"<p>This depends heavily on the task, but in general it should be comparable or even faster, see Benchmark.</p>"},{"location":"faq/#is-there-a-command-line-interface","title":"Is there a command line interface?","text":"<p>Yes, indeed. Some useful plots (e.g. CK-test) and tools can be used directly from the command line. Please check out the short tutorial CLI.</p>"},{"location":"faq/#is-there-a-shell-completion","title":"Is there a shell completion","text":"<p>Using the <code>bash</code>, <code>zsh</code> or <code>fish</code> shell click provides an easy way to provide shell completion, checkout the docs. In the case of bash you need to add following line to your <code>~/.bashrc</code> <pre><code>eval \"$(_MSMHELPER_COMPLETE=bash_source msmhelper)\"\n</code></pre> In general one can call the module directly by its entry point <code>$ msmhelper</code> or by calling the module <code>$ python -m msmhelper</code>. For enabling the shell completion, the entry point needs to be used.</p>"},{"location":"faq/#how-do-i-use-the-hummer-szabo-projection","title":"How do I use the Hummer-Szabo projection?","text":"<p>Following the tutorials, you find in Hummer-Szabo projection a detailed explanation. To make it short, simply create a state trajectory <code>traj = mh.LumpedStateTraj(macrotrajs, microtrajs)</code> and pass this object to the analysis methods.</p>"},{"location":"faq/#i-get-negative-values-for-the-hummer-szabo-projection","title":"I get negative values for the Hummer-Szabo projection?","text":"<p>This is sadly not a bug, but a limitation of the projection formalism. This should occur only for bad lumping and with values close to zero. For a detailed description of this issue please take a look at the original publication, (10.1021/jp508375q). To avoid it, you can use the flag <code>positive=True</code> while initialization to enforce \\(T_{ij} \\ge 0\\).</p>"},{"location":"faq/#feature-x-is-missing","title":"Feature X is missing","text":"<p>First, if you are looking for a feature complete package, I would recommand you to take a look at pyemma and msmbuilder. If you believe that a crucial functionality/method is missing, feel free to open an issue and describe the missing functionality and why it should be added. Alternatively, you can implement it yourself and create a PR to add it to this package, see contributing guide.</p>"},{"location":"faq/#i-found-a-bug-what-to-do-next","title":"I found a bug. What to do next?","text":"<p>If you find a bug in this package, it is very kind of you to open an issue/bug report. This allows us to identify and fix the problem, thus improving the overall quality of the software for all users. By providing a clear and concise description of the problem, including steps to reproduce it, and relevant information such as device, operating system, and software version, you will help us resolve the problem quickly and effectively. Submitting a bug report is a valuable contribution to the software and its community, and is greatly appreciated by the development team.</p>"},{"location":"faq/#is-it-possible-to-build-the-documentation-for-offline-use","title":"Is it possible to build the documentation for offline use?","text":"<p>Yes, for sure. You can compile the documentation on your local machine by executing the following commands: <pre><code># install all additional dependencies\npython -m pip install msmhelper[docs]\n# build the docs inside the site directory\npython -m mkdocs build\n</code></pre></p>"},{"location":"license/","title":"License","text":"<p>BSD 3-Clause License</p> <p>Copyright \u00a9 2019-2023, Daniel Nagel All rights reserved.</p> <p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p> <ul> <li> <p>Redistributions of source code must retain the above copyright notice, this   list of conditions and the following disclaimer.</p> </li> <li> <p>Redistributions in binary form must reproduce the above copyright notice,   this list of conditions and the following disclaimer in the documentation   and/or other materials provided with the distribution.</p> </li> <li> <p>Neither the name of the copyright holder nor the names of its   contributors may be used to endorse or promote products derived from   this software without specific prior written permission.</p> </li> </ul> <p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>"},{"location":"maintenance/","title":"Welcome to the <code>msmhelper</code> Maintenance Guideline","text":"<p>This guide will give you an overview of how to publish a new version of msmhelper. In the following we will refer to the new version as <code>v1.*.*</code>. This needs to be substituted to the current version, e.g. <code>v1.1.3</code>.</p>"},{"location":"maintenance/#prepare-new-release","title":"Prepare New Release","text":"<p>Please ensure that,</p> <ol> <li>the version number in <code>setup.py</code> and <code>src/msmhelper/__init__.py</code> are bumped,</li> <li>a new tag is created via <code>git tag v1.*.*</code> and pushed <code>git push --tags</code>, and </li> <li>the changelog includes the new tag and all changes of the release. As an example see for e.g. the commit of <code>v1.0.2</code>, <code>132673a</code>.</li> </ol>"},{"location":"maintenance/#build-and-upload-to-pypi","title":"Build and Upload to PyPI","text":"<p>For an introduction, please take a look at the PyPI manual.</p> <p>First ensure that all needed dependencies are installed <pre><code>python -m pip install --upgrade pip\npython -m pip install --upgrade build\npython -m pip install --upgrade twine\n</code></pre></p> <p>To create the build, please ensure first that the directory <code>dist</code> does not exist. Otherwise delete it, <pre><code>rm dist\n</code></pre> Then, execute <pre><code>python3 -m build\n</code></pre> which will create the directory <code>dist</code> including the source distributions: <pre><code>dist/\n\u251c\u2500\u2500 msmhelper-1.*.*-py3-none-any.whl\n\u2514\u2500\u2500 msmhelper-1.*.*.tar.gz\n</code></pre> To upload the new files, run <pre><code>python3 -m twine upload dist/*\n</code></pre></p>"},{"location":"maintenance/#update-on-conda-forge","title":"Update on Conda-Forge","text":"<p>Once a new version is published on PyPI, the conda-forge bot will automatically create a pull request on msmhelper-feedstock.</p>"},{"location":"reference/","title":"msmhelper","text":""},{"location":"reference/#msmhelper--msmhelper","title":"msmhelper","text":"<p>This package is designed for the analysis of discrete time series data from Molecular Dynamics (MD) simulations. It focuses on Markov state modeling (MSM), a powerful technique for analyzing complex systems, and provides a set of functions for constructing and analyzing Markov models, including methods calculating transition probabilities, and fitting models to data. The package is suitable for researchers and engineers who need to analyze large and complex datasets in order to gain insights into the behavior of the underlying dynamics.</p> <p>The module is structured into the following submodules:</p> <ul> <li> <p>io: This submodule contains all methods related to reading data from text files and writing data to text files, including helpful header comments.</p> </li> <li> <p>md: This submodule offers techniques for the analysis of state trajectories\u2014commonly known as Molecular Dynamics (MD)\u2014without relying on Markov state models. It encompasses functions for determining timescales, recognizing significant events, correcting dynamical anomalies, and evaluating various state discretization methods.  These functions provide a comprehensive solution for analyzing time-series data and understanding the underlying dynamics of complex systems.</p> </li> <li> <p>msm: This submodule contains methods related to Markov state modeling, a powerful technique for analyzing complex systems. It provides a set of functions for constructing and analyzing Markov models, including methods for calculating transition probabilities and estimating various time scales.</p> </li> <li> <p>plot: This submodule is dedicated to visualizing results. It offers a collection of functions for generating frequently used figures, such as the CK-test, implied timescales, and waiting times.</p> </li> <li> <p>statetraj: This submodule contains the two classes StateTraj and LumpedStateTraj which are used to represent the time series and allows for an improved performance.</p> </li> <li> <p>utils: This submodule provides utility functions that can be used to manipulate and test data, such as filtering and validation methods. The functions in this submodule can be used in conjunction with other parts of the software to perform a variety of tasks, making it an essential part of the package.</p> </li> </ul>"},{"location":"reference/#msmhelper.LumpedStateTraj","title":"<code>LumpedStateTraj(macrotrajs, microtrajs=None, positive=False)</code>","text":"<p>               Bases: <code>StateTraj</code></p> <p>Class for using the Hummer-Szabo projection with state trajectories.</p> <p>Initialize LumpedStateTraj.</p> <p>If called with LumpedStateTraj instance, it will be returned instead. This class is an implementation of the Hummer-Szabo projection<sup>1</sup>.</p> <ol> <li> <p>Hummer and Szabo, Optimal Dimensionality Reduction of   Multistate Kinetic and Markov-State Models, J. Phys. Chem. B,   119 (29), 9029-9037 (2015),   doi: 10.1021/jp508375q \u21a9</p> </li> </ol> <p>Parameters:</p> <ul> <li> <code>macrotrajs</code>               (<code>list or ndarray or list of ndarray</code>)           \u2013            <p>Lumped state trajectory/trajectories. The states need to be integers and all states needs to correspond to union of microstates.</p> </li> <li> <code>microtrajs</code>               (<code>list or ndarray or list of ndarray</code>, default:                   <code>None</code> )           \u2013            <p>State trajectory/trajectories. EaThe states should start from zero and need to be integers.</p> </li> <li> <code>positive</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If <code>True</code> \\(T_ij\\ge0\\) will be enforced, else small negative values are possible.</p> </li> </ul> Source code in <code>src/msmhelper/statetraj.py</code> <pre><code>def __init__(self, macrotrajs, microtrajs=None, positive=False):\n    r\"\"\"Initialize LumpedStateTraj.\n\n    If called with LumpedStateTraj instance, it will be returned instead.\n    This class is an implementation of the Hummer-Szabo projection[^1].\n\n    [^1]: Hummer and Szabo, **Optimal Dimensionality Reduction of\n          Multistate Kinetic and Markov-State Models**, *J. Phys. Chem. B*,\n          119 (29), 9029-9037 (2015),\n          doi: [10.1021/jp508375q](https://doi.org/10.1021/jp508375q)\n\n    Parameters\n    ----------\n    macrotrajs : list or ndarray or list of ndarray\n        Lumped state trajectory/trajectories. The states need to be\n        integers and all states needs to correspond to union of\n        microstates.\n    microtrajs : list or ndarray or list of ndarray\n        State trajectory/trajectories. EaThe states should start from zero\n        and need to be integers.\n    positive : bool\n        If `True` $T_ij\\ge0$ will be enforced, else small negative values\n        are possible.\n\n    \"\"\"\n    if isinstance(macrotrajs, LumpedStateTraj):\n        return\n\n    if microtrajs is None:\n        raise TypeError(\n            'microtrajs may only be None when macrotrajs is of type ' +\n            'LumpedStateTraj.',\n        )\n\n    self.positive = positive\n\n    # parse macrotraj\n    macrotrajs = mh.utils.format_state_traj(macrotrajs)\n    self._macrostates = mh.utils.unique(macrotrajs)\n\n    # init microstate trajectories\n    super().__init__(microtrajs)\n\n    # cache flattened trajectories to speed up code for many states\n    macrotrajs_flatten = np.concatenate(macrotrajs)\n    microtrajs_flatten = self.microstate_trajs_flatten\n\n    self._state_assignment = np.zeros(self.nmicrostates, dtype=np.int64)\n    for idx, microstate in enumerate(self.microstates):\n        idx_first = mh.utils.find_first(microstate, microtrajs_flatten)\n        self._state_assignment[idx] = macrotrajs_flatten[idx_first]\n</code></pre>"},{"location":"reference/#msmhelper.LumpedStateTraj.states","title":"<code>states</code>  <code>property</code>","text":"<p>Return active set of macrostates.</p> <p>Returns:</p> <ul> <li> <code>states</code> (              <code>ndarray</code> )          \u2013            <p>Numpy array holding active set of states.</p> </li> </ul>"},{"location":"reference/#msmhelper.LumpedStateTraj.nstates","title":"<code>nstates</code>  <code>property</code>","text":"<p>Return number of macrostates.</p> <p>Returns:</p> <ul> <li> <code>nstates</code> (              <code>int</code> )          \u2013            <p>Number of states.</p> </li> </ul>"},{"location":"reference/#msmhelper.LumpedStateTraj.microstate_trajs","title":"<code>microstate_trajs</code>  <code>property</code>","text":"<p>Return microstate trajectory.</p> <p>Returns:</p> <ul> <li> <code>trajs</code> (              <code>list of ndarrays</code> )          \u2013            <p>List of ndarrays holding the input data.</p> </li> </ul>"},{"location":"reference/#msmhelper.LumpedStateTraj.microstate_trajs_flatten","title":"<code>microstate_trajs_flatten</code>  <code>property</code>","text":"<p>Return flattened state trajectory.</p> <p>Returns:</p> <ul> <li> <code>trajs</code> (              <code>ndarray</code> )          \u2013            <p>1D ndarrays representation of state trajectories.</p> </li> </ul>"},{"location":"reference/#msmhelper.LumpedStateTraj.microstate_index_trajs","title":"<code>microstate_index_trajs</code>  <code>property</code>","text":"<p>Return microstate index trajectory.</p> <p>Returns:</p> <ul> <li> <code>trajs</code> (              <code>list of ndarrays</code> )          \u2013            <p>List of ndarrays holding the microstate index trajectory.</p> </li> </ul>"},{"location":"reference/#msmhelper.LumpedStateTraj.microstate_index_trajs_flatten","title":"<code>microstate_index_trajs_flatten</code>  <code>property</code>","text":"<p>Return flattened microstate index trajectory.</p> <p>Returns:</p> <ul> <li> <code>trajs</code> (              <code>ndarray</code> )          \u2013            <p>1D ndarrays representation of microstate index trajectories.</p> </li> </ul>"},{"location":"reference/#msmhelper.LumpedStateTraj.trajs","title":"<code>trajs</code>  <code>property</code>","text":"<p>Return macrostate trajectory.</p> <p>Returns:</p> <ul> <li> <code>trajs</code> (              <code>list of ndarrays</code> )          \u2013            <p>List of ndarrays holding the input macrostate data.</p> </li> </ul>"},{"location":"reference/#msmhelper.LumpedStateTraj.index_trajs","title":"<code>index_trajs</code>  <code>property</code>","text":"<p>Return index trajectory.</p> <p>Returns:</p> <ul> <li> <code>trajs</code> (              <code>list of ndarrays</code> )          \u2013            <p>List of ndarrays holding the input data.</p> </li> </ul>"},{"location":"reference/#msmhelper.LumpedStateTraj.microstates","title":"<code>microstates</code>  <code>property</code>","text":"<p>Return active set of microstates.</p> <p>Returns:</p> <ul> <li> <code>states</code> (              <code>ndarray</code> )          \u2013            <p>Numpy array holding active set of states.</p> </li> </ul>"},{"location":"reference/#msmhelper.LumpedStateTraj.nmicrostates","title":"<code>nmicrostates</code>  <code>property</code>","text":"<p>Return number of active set of states.</p> <p>Returns:</p> <ul> <li> <code>states</code> (              <code>ndarray</code> )          \u2013            <p>Numpy array holding active set of states.</p> </li> </ul>"},{"location":"reference/#msmhelper.LumpedStateTraj.state_assignment","title":"<code>state_assignment</code>  <code>property</code>","text":"<p>Return micro to macrostate assignment vector.</p> <p>Returns:</p> <ul> <li> <code>state_assignment</code> (              <code>ndarray</code> )          \u2013            <p>Micro to macrostate assignment vector.</p> </li> </ul>"},{"location":"reference/#msmhelper.LumpedStateTraj.estimate_markov_model","title":"<code>estimate_markov_model(lagtime)</code>","text":"<p>Estimates Markov State Model.</p> <p>This method estimates the microstate MSM based on the transition count matrix, followed by Szabo-Hummer projection<sup>1</sup> formalism to macrostates.</p> <ol> <li> <p>Hummer and Szabo, Optimal Dimensionality Reduction of   Multistate Kinetic and Markov-State Models, J. Phys. Chem. B,   119 (29), 9029-9037 (2015),   doi: 10.1021/jp508375q \u21a9</p> </li> </ol> <p>Parameters:</p> <ul> <li> <code>lagtime</code>               (<code>int</code>)           \u2013            <p>Lag time for estimating the markov model given in [frames].</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>T</code> (              <code>ndarray</code> )          \u2013            <p>Transition probability matrix \\(T_{ij}\\), containing the transition probability transition from state \\(i\\to j\\).</p> </li> <li> <code>states</code> (              <code>ndarray</code> )          \u2013            <p>Array holding states corresponding to the columns of \\(T_{ij}\\).</p> </li> </ul> Source code in <code>src/msmhelper/statetraj.py</code> <pre><code>def estimate_markov_model(self, lagtime):\n    r\"\"\"Estimates Markov State Model.\n\n    This method estimates the microstate MSM based on the transition count\n    matrix, followed by Szabo-Hummer projection[^1] formalism to\n    macrostates.\n\n    [^1]: Hummer and Szabo, **Optimal Dimensionality Reduction of\n          Multistate Kinetic and Markov-State Models**, *J. Phys. Chem. B*,\n          119 (29), 9029-9037 (2015),\n          doi: [10.1021/jp508375q](https://doi.org/10.1021/jp508375q)\n\n    Parameters\n    ----------\n    lagtime : int\n        Lag time for estimating the markov model given in [frames].\n\n    Returns\n    -------\n    T : ndarray\n        Transition probability matrix $T_{ij}$, containing the transition\n        probability transition from state $i\\to j$.\n    states : ndarray\n        Array holding states corresponding to the columns of $T_{ij}$.\n\n    \"\"\"\n    # in the following corresponds 'i' to micro and 'a' to macro\n    msm_i, _ = mh.msm.msm._estimate_markov_model(\n        self.microstate_index_trajs,\n        lagtime,\n        self.nmicrostates,\n        self.microstates,\n    )\n    if not mh.utils.tests.is_ergodic(msm_i):\n        raise TypeError('tmat needs to be ergodic transition matrix.')\n    return (self._estimate_markov_model(msm_i), self.states)\n</code></pre>"},{"location":"reference/#msmhelper.StateTraj","title":"<code>StateTraj(trajs)</code>","text":"<p>Class for handling discrete state trajectories.</p> <p>Initialize StateTraj and convert to index trajectories.</p> <p>If called with StateTraj instance, it will be returned instead.</p> <p>Parameters:</p> <ul> <li> <code>trajs</code>               (<code>list or ndarray or list of ndarray</code>)           \u2013            <p>State trajectory/trajectories. The states need to be integers.</p> </li> </ul> Source code in <code>src/msmhelper/statetraj.py</code> <pre><code>def __init__(self, trajs):\n    \"\"\"Initialize StateTraj and convert to index trajectories.\n\n    If called with StateTraj instance, it will be returned instead.\n\n    Parameters\n    ----------\n    trajs : list or ndarray or list of ndarray\n        State trajectory/trajectories. The states need to be integers.\n\n    \"\"\"\n    if isinstance(trajs, StateTraj):\n        return\n\n    self._trajs = mh.utils.format_state_traj(trajs)\n\n    # get number of states\n    self._states = mh.utils.unique(self._trajs)\n\n    # enforce true copy of trajs\n    if np.array_equal(self._states, np.arange(self.nstates)):\n        self._trajs = [traj.copy() for traj in self._trajs]\n    # shift to indices\n    elif np.array_equal(self._states, np.arange(1, self.nstates + 1)):\n        self._states = np.arange(1, self.nstates + 1)\n        self._trajs = [traj - 1 for traj in self._trajs]\n    else:  # not np.array_equal(self._states, np.arange(self.nstates)):\n        self._trajs, self._states = mh.utils.rename_by_index(\n            self._trajs,\n            return_permutation=True,\n        )\n</code></pre>"},{"location":"reference/#msmhelper.StateTraj.states","title":"<code>states</code>  <code>property</code>","text":"<p>Return active set of states.</p> <p>Returns:</p> <ul> <li> <code>states</code> (              <code>ndarray</code> )          \u2013            <p>Numpy array holding active set of states.</p> </li> </ul>"},{"location":"reference/#msmhelper.StateTraj.nstates","title":"<code>nstates</code>  <code>property</code>","text":"<p>Return number of states.</p> <p>Returns:</p> <ul> <li> <code>nstates</code> (              <code>int</code> )          \u2013            <p>Number of states.</p> </li> </ul>"},{"location":"reference/#msmhelper.StateTraj.ntrajs","title":"<code>ntrajs</code>  <code>property</code>","text":"<p>Return number of trajectories.</p> <p>Returns:</p> <ul> <li> <code>ntrajs</code> (              <code>int</code> )          \u2013            <p>Number of trajectories.</p> </li> </ul>"},{"location":"reference/#msmhelper.StateTraj.nframes","title":"<code>nframes</code>  <code>property</code>","text":"<p>Return cumulative length of all trajectories.</p> <p>Returns:</p> <ul> <li> <code>nframes</code> (              <code>int</code> )          \u2013            <p>Number of frames of all trajectories.</p> </li> </ul>"},{"location":"reference/#msmhelper.StateTraj.trajs","title":"<code>trajs</code>  <code>property</code>","text":"<p>Return state trajectory.</p> <p>Returns:</p> <ul> <li> <code>trajs</code> (              <code>list of ndarrays</code> )          \u2013            <p>List of ndarrays holding the input data.</p> </li> </ul>"},{"location":"reference/#msmhelper.StateTraj.trajs_flatten","title":"<code>trajs_flatten</code>  <code>property</code>","text":"<p>Return flattened state trajectory.</p> <p>Returns:</p> <ul> <li> <code>trajs</code> (              <code>ndarray</code> )          \u2013            <p>1D ndarray representation of state trajectories.</p> </li> </ul>"},{"location":"reference/#msmhelper.StateTraj.index_trajs","title":"<code>index_trajs</code>  <code>property</code>","text":"<p>Return index trajectory.</p> <p>Returns:</p> <ul> <li> <code>trajs</code> (              <code>list of ndarrays</code> )          \u2013            <p>List of ndarrays holding the input data.</p> </li> </ul>"},{"location":"reference/#msmhelper.StateTraj.index_trajs_flatten","title":"<code>index_trajs_flatten</code>  <code>property</code>","text":"<p>Return flattened index trajectory.</p> <p>Returns:</p> <ul> <li> <code>trajs</code> (              <code>ndarray</code> )          \u2013            <p>1D ndarray representation of index trajectories.</p> </li> </ul>"},{"location":"reference/#msmhelper.StateTraj.estimate_markov_model","title":"<code>estimate_markov_model(lagtime)</code>","text":"<p>Estimates Markov State Model.</p> <p>This method estimates the MSM based on the transition count matrix.</p> <p>Parameters:</p> <ul> <li> <code>lagtime</code>               (<code>int</code>)           \u2013            <p>Lag time for estimating the markov model given in [frames].</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>T</code> (              <code>ndarray</code> )          \u2013            <p>Transition probability matrix \\(T_{ij}\\), containing the transition probability transition from state \\(i        o j\\).</p> </li> <li> <code>states</code> (              <code>ndarray</code> )          \u2013            <p>Array holding states corresponding to the columns of \\(T_{ij}\\).</p> </li> </ul> Source code in <code>src/msmhelper/statetraj.py</code> <pre><code>def estimate_markov_model(self, lagtime):\n    \"\"\"Estimates Markov State Model.\n\n    This method estimates the MSM based on the transition count matrix.\n\n    Parameters\n    ----------\n    lagtime : int\n        Lag time for estimating the markov model given in [frames].\n\n    Returns\n    -------\n    T : ndarray\n        Transition probability matrix $T_{ij}$, containing the transition\n        probability transition from state $i\\to j$.\n    states : ndarray\n        Array holding states corresponding to the columns of $T_{ij}$.\n\n    \"\"\"\n    return mh.msm.msm._estimate_markov_model(\n        self.index_trajs,\n        lagtime,\n        self.nstates,\n        self.states,\n    )\n</code></pre>"},{"location":"reference/#msmhelper.StateTraj.state_to_idx","title":"<code>state_to_idx(state)</code>","text":"<p>Get idx corresponding to state.</p> <p>Parameters:</p> <ul> <li> <code>state</code>               (<code>int</code>)           \u2013            <p>State to get idx of.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>idx</code> (              <code>int</code> )          \u2013            <p>Idx corresponding to state.</p> </li> </ul> Source code in <code>src/msmhelper/statetraj.py</code> <pre><code>def state_to_idx(self, state):\n    \"\"\"Get idx corresponding to state.\n\n    Parameters\n    ----------\n    state : int\n        State to get idx of.\n\n    Returns\n    -------\n    idx : int\n        Idx corresponding to state.\n\n    \"\"\"\n    idx = np.where(self.states == state)[0]\n    if not idx.size:\n        raise ValueError(\n            'State \"{state}\" does not exists in trajectory.'.format(\n                state=state,\n            ),\n        )\n    return idx[0]\n</code></pre>"},{"location":"reference/#msmhelper.opentxt","title":"<code>opentxt(file_name, comment='#', nrows=None, **kwargs)</code>","text":"<p>Open a text file.</p> <p>This method can load an nxm array of floats from an ascii file. It uses either pandas read_csv for a single comment or as fallback the slower np.loadtxt for multiple comments.</p> <p>Warning</p> <p>In contrast to pandas the order of usecols will be used. So if using <code>data = opentxt(..., uscols=[1, 0])</code> you access the first column by <code>data[:, 0]</code> and the second one by <code>data[:, 1]</code>.</p> <p>Parameters:</p> <ul> <li> <code>file_name</code>               (<code>string</code>)           \u2013            <p>Name of file to be opened.</p> </li> <li> <code>comment</code>               (<code>str or array of str</code>, default:                   <code>'#'</code> )           \u2013            <p>Characters with which a comment starts.</p> </li> <li> <code>nrows</code>               (<code>int</code>, default:                   <code>None</code> )           \u2013            <p>The maximum number of lines to be read</p> </li> <li> <code>usecols</code>               (<code>int - array</code>)           \u2013            <p>Columns to be read from the file (zero indexed).</p> </li> <li> <code>skiprows</code>               (<code>int</code>)           \u2013            <p>The number of leading rows which will be skipped.</p> </li> <li> <code>dtype</code>               (<code>data - type</code>)           \u2013            <p>Data-type of the resulting array. Default: float.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>array</code> (              <code>ndarray</code> )          \u2013            <p>Data read from the text file.</p> </li> </ul> Source code in <code>src/msmhelper/io.py</code> <pre><code>def opentxt(file_name, comment='#', nrows=None, **kwargs):\n    r\"\"\"Open a text file.\n\n    This method can load an nxm array of floats from an ascii file. It uses\n    either pandas read_csv for a single comment or as fallback the slower\n    [np.loadtxt][numpy.loadtxt] for multiple comments.\n\n    !!! warning\n        In contrast to pandas the order of usecols will be used. So if\n        using `data = opentxt(..., uscols=[1, 0])` you access the first column\n        by `data[:, 0]` and the second one by `data[:, 1]`.\n\n    Parameters\n    ----------\n    file_name : string\n        Name of file to be opened.\n    comment : str or array of str, optional\n        Characters with which a comment starts.\n    nrows : int, optional\n        The maximum number of lines to be read\n    usecols : int-array, optional\n        Columns to be read from the file (zero indexed).\n    skiprows : int, optional\n        The number of leading rows which will be skipped.\n    dtype : data-type, optional\n        Data-type of the resulting array. Default: float.\n\n    Returns\n    -------\n    array : ndarray\n        Data read from the text file.\n\n    \"\"\"\n    if len(comment) == 1:\n        # pandas does not support array of single char\n        if not isinstance(comment, str):\n            comment = comment[0]\n\n        # force pandas to load in stated order without sorting\n        cols = kwargs.pop('usecols', None)\n        if cols is not None:\n            idx = np.argsort(cols)\n            cols = np.atleast_1d(cols).astype(np.int32)[idx]\n\n        array = pd.read_csv(\n            file_name,\n            sep=r'\\s+',\n            header=None,\n            comment=comment,\n            nrows=nrows,\n            usecols=cols,\n            **kwargs,\n        ).values\n\n        if array.shape[-1] == 1:\n            array = array.flatten()\n        # swap columns back to ensure correct order\n        elif cols is not None:\n            array = utils.swapcols(array, idx, np.arange(len(idx)))\n\n        return array\n\n    return np.loadtxt(\n        file_name,\n        comments=comment,\n        max_rows=nrows,\n        **kwargs,\n    )\n</code></pre>"},{"location":"reference/#msmhelper.savetxt","title":"<code>savetxt(file_name, array, header=None, fmt='%.5f')</code>","text":"<p>Save nxm array of floats to a text file.</p> <p>It uses numpys savetxt method and extends the header with information of execution.</p> <p>Parameters:</p> <ul> <li> <code>file_name</code>               (<code>string</code>)           \u2013            <p>File name to store data.</p> </li> <li> <code>array</code>               (<code>ndarray</code>)           \u2013            <p>Data to be stored.</p> </li> <li> <code>header</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>Comment written into the header of the output file.</p> </li> <li> <code>fmt</code>               (<code>str or sequence of strs</code>, default:                   <code>'%.5f'</code> )           \u2013            <p>See numpy.savetxt.</p> </li> </ul> Source code in <code>src/msmhelper/io.py</code> <pre><code>def savetxt(file_name, array, header=None, fmt='%.5f'):  # noqa: WPS323\n    \"\"\"Save nxm array of floats to a text file.\n\n    It uses numpys savetxt method and extends the header with information\n    of execution.\n\n    Parameters\n    ----------\n    file_name : string\n        File name to store data.\n    array : ndarray\n        Data to be stored.\n    header : str, optional\n        Comment written into the header of the output file.\n    fmt : str or sequence of strs, optional\n        See [numpy.savetxt][].\n\n    \"\"\"\n    # prepare header comments\n    RUI = _get_runtime_user_information()\n\n    header_comment = (\n        'This file was generated by {script_dir}/{script_name}:\\n{args}' +\n        '\\n\\n{date}, {user}@{pc}'\n    ).format(**RUI, args=' '.join(sys.argv))\n\n    if header:  # print column title if given\n        header_comment += '\\n{0}'.format(header)\n\n    # save file\n    np.savetxt(file_name, array, fmt=fmt, header=header_comment)\n</code></pre>"},{"location":"reference/#msmhelper.opentxt_limits","title":"<code>opentxt_limits(file_name, limits_file=None, **kwargs)</code>","text":"<p>Load file and split according to limit file.</p> <p>If limits_file is not provided it will return <code>[traj]</code>.</p> <p>Parameters:</p> <ul> <li> <code>file_name</code>               (<code>string</code>)           \u2013            <p>Name of file to be opened.</p> </li> <li> <code>limits_file</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>File name of limit file. Should be single column ascii file.</p> </li> <li> <code>**kwargs</code>           \u2013            <p>See parameters defined in opentxt</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>traj</code> (              <code>ndarray</code> )          \u2013            <p>Return array of subtrajectories.</p> </li> </ul> Source code in <code>src/msmhelper/io.py</code> <pre><code>def opentxt_limits(file_name, limits_file=None, **kwargs):\n    \"\"\"Load file and split according to limit file.\n\n    If limits_file is not provided it will return `[traj]`.\n\n    Parameters\n    ----------\n    file_name : string\n        Name of file to be opened.\n    limits_file : str, optional\n        File name of limit file. Should be single column ascii file.\n    **kwargs\n        See parameters defined in [opentxt][msmhelper.io.opentxt]\n\n    Returns\n    -------\n    traj : ndarray\n        Return array of subtrajectories.\n\n    \"\"\"\n    # open trajectory\n    traj = opentxt(file_name, **kwargs)\n\n    # open limits\n    limits = open_limits(limits_file=limits_file, data_length=len(traj))\n\n    # split trajectory\n    return np.split(traj, limits)[:-1]\n</code></pre>"},{"location":"reference/#msmhelper.openmicrostates","title":"<code>openmicrostates(file_name, limits_file=None, **kwargs)</code>","text":"<p>Load 1d file and split according to limit file.</p> <p>Both, the limit file and the trajectory file needs to be a single column file. If limits_file is not provided it will return [traj]. The trajectory will of dtype np.int16, so the states needs to be smaller than 32767.</p> <p>Parameters:</p> <ul> <li> <code>file_name</code>               (<code>string</code>)           \u2013            <p>Name of file to be opened.</p> </li> <li> <code>limits_file</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>File name of limit file. Should be single column ascii file.</p> </li> <li> <code>**kwargs</code>           \u2013            <p>See parameters defined in opentxt</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>traj</code> (              <code>ndarray</code> )          \u2013            <p>Return array of subtrajectories.</p> </li> </ul> Source code in <code>src/msmhelper/io.py</code> <pre><code>def openmicrostates(file_name, limits_file=None, **kwargs):\n    \"\"\"Load 1d file and split according to limit file.\n\n    Both, the limit file and the trajectory file needs to be a single column\n    file. If limits_file is not provided it will return [traj]. The trajectory\n    will of dtype np.int16, so the states needs to be smaller than 32767.\n\n    Parameters\n    ----------\n    file_name : string\n        Name of file to be opened.\n    limits_file : str, optional\n        File name of limit file. Should be single column ascii file.\n    **kwargs\n        See parameters defined in [opentxt][msmhelper.io.opentxt]\n\n    Returns\n    -------\n    traj : ndarray\n        Return array of subtrajectories.\n\n    \"\"\"\n    # open trajectory\n    if 'dtype' in kwargs and not np.issubdtype(kwargs['dtype'], np.integer):\n        raise TypeError('dtype should be integer')\n    else:\n        kwargs['dtype'] = np.int16\n\n    # load split trajectory\n    traj = opentxt_limits(file_name, limits_file, **kwargs)\n\n    if len(traj[0].shape) != 1:\n        raise FileError('Microstate trjectory shoud be single column file.')\n\n    return traj\n</code></pre>"},{"location":"reference/#msmhelper.open_limits","title":"<code>open_limits(data_length, limits_file=None)</code>","text":"<p>Load and check limit file.</p> <p>The limits give the length of each single trajectory. So e.g. [5, 5, 5] for 3 equally-sized subtrajectories of length 5.</p> <p>Parameters:</p> <ul> <li> <code>data_length</code>               (<code>int</code>)           \u2013            <p>Length of data read.</p> </li> <li> <code>limits_file</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>File name of limit file. Should be single column ascii file.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>limits</code> (              <code>ndarray</code> )          \u2013            <p>Return cumsum of limits.</p> </li> </ul> Source code in <code>src/msmhelper/io.py</code> <pre><code>def open_limits(data_length, limits_file=None):\n    \"\"\"Load and check limit file.\n\n    The limits give the length of each single trajectory. So e.g.\n    [5, 5, 5] for 3 equally-sized subtrajectories of length 5.\n\n    Parameters\n    ----------\n    data_length : int\n        Length of data read.\n    limits_file : str, optional\n        File name of limit file. Should be single column ascii file.\n\n    Returns\n    -------\n    limits : ndarray\n        Return cumsum of limits.\n\n    \"\"\"\n    if limits_file is None:\n        return np.array([data_length])  # for single trajectory\n\n    # open limits file\n    limits = opentxt(limits_file)\n    if len(limits.shape) != 1:\n        raise FileError('Shoud be single column file.')\n\n    # convert to cumulative sum\n    limits = np.cumsum(limits)\n    if data_length != limits[-1]:\n        raise ValueError('Limits are inconsistent to data.')\n\n    return limits\n</code></pre>"},{"location":"reference/#msmhelper.rename_by_population","title":"<code>rename_by_population(trajs, return_permutation=False)</code>","text":"<p>Rename states sorted by their population starting from 1.</p> <p>Parameters:</p> <ul> <li> <code>trajs</code>               (<code>list or ndarray or list of ndarrays</code>)           \u2013            <p>State trajectory or list of state trajectories.</p> </li> <li> <code>return_permutation</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Return additionaly the permutation to achieve performed renaming. Default is False.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>trajs</code> (              <code>ndarray</code> )          \u2013            <p>Renamed data.</p> </li> <li> <code>permutation</code> (              <code>ndarray</code> )          \u2013            <p>Permutation going from old to new state nameing. So the <code>i</code>th state of the new naming corresponds to the old state <code>permutation[i-1]</code>.</p> </li> </ul> Source code in <code>src/msmhelper/utils/_utils.py</code> <pre><code>def rename_by_population(trajs, return_permutation=False):\n    r\"\"\"Rename states sorted by their population starting from 1.\n\n    Parameters\n    ----------\n    trajs : list or ndarray or list of ndarrays\n        State trajectory or list of state trajectories.\n    return_permutation : bool\n        Return additionaly the permutation to achieve performed renaming.\n        Default is False.\n\n    Returns\n    -------\n    trajs : ndarray\n        Renamed data.\n    permutation : ndarray\n        Permutation going from old to new state nameing. So the `i`th state\n        of the new naming corresponds to the old state `permutation[i-1]`.\n\n    \"\"\"\n    # get unique states with population\n    states, pop = unique(trajs, return_counts=True)\n\n    # get decreasing order\n    idx_sort = np.argsort(pop)[::-1]\n    states = states[idx_sort]\n\n    # rename states\n    trajs_renamed = shift_data(\n        trajs,\n        val_old=states,\n        val_new=np.arange(len(states)) + 1,\n    )\n    if return_permutation:\n        return trajs_renamed, states\n    return trajs_renamed\n</code></pre>"},{"location":"reference/#msmhelper.rename_by_index","title":"<code>rename_by_index(trajs, return_permutation=False)</code>","text":"<p>Rename states sorted by their numerical values starting from 0.</p> <p>Parameters:</p> <ul> <li> <code>trajs</code>               (<code>list or ndarray or list of ndarrays</code>)           \u2013            <p>State trajectory or list of state trajectories.</p> </li> <li> <code>return_permutation</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Return additionaly the permutation to achieve performed renaming. Default is False.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>trajs</code> (              <code>ndarray</code> )          \u2013            <p>Renamed data.</p> </li> <li> <code>permutation</code> (              <code>ndarray</code> )          \u2013            <p>Permutation going from old to new state nameing. So the <code>i</code>th state of the new naming corresponds to the old state <code>permutation[i-1]</code>.</p> </li> </ul> Source code in <code>src/msmhelper/utils/_utils.py</code> <pre><code>def rename_by_index(trajs, return_permutation=False):\n    r\"\"\"Rename states sorted by their numerical values starting from 0.\n\n    Parameters\n    ----------\n    trajs : list or ndarray or list of ndarrays\n        State trajectory or list of state trajectories.\n    return_permutation : bool\n        Return additionaly the permutation to achieve performed renaming.\n        Default is False.\n\n    Returns\n    -------\n    trajs : ndarray\n        Renamed data.\n    permutation : ndarray\n        Permutation going from old to new state nameing. So the `i`th state\n        of the new naming corresponds to the old state `permutation[i-1]`.\n\n    \"\"\"\n    # get unique states\n    states = unique(trajs)\n\n    # rename states\n    trajs_renamed = shift_data(\n        trajs,\n        val_old=states,\n        val_new=np.arange(len(states)),\n    )\n    if return_permutation:\n        return trajs_renamed, states\n    return trajs_renamed\n</code></pre>"},{"location":"reference/#msmhelper.shift_data","title":"<code>shift_data(array, val_old, val_new, dtype=np.int64)</code>","text":"<p>Shift integer array (data) from old to new values.</p> <p>Warning</p> <p>The values of <code>val_old</code>, <code>val_new</code> and <code>data</code> needs to be integers.</p> <p>The basic function is based on Ashwini_Chaudhary solution: https://stackoverflow.com/a/29408060</p> <p>Parameters:</p> <ul> <li> <code>array</code>               (<code>StateTraj or ndarray or list or list of ndarrays</code>)           \u2013            <p>1D data or a list of data.</p> </li> <li> <code>val_old</code>               (<code>ndarray or list</code>)           \u2013            <p>Values in data which should be replaced. All values needs to be within the range of <code>[data.min(), data.max()]</code></p> </li> <li> <code>val_new</code>               (<code>ndarray or list</code>)           \u2013            <p>Values which will be used instead of old ones.</p> </li> <li> <code>dtype</code>               (<code>data - type</code>, default:                   <code>int64</code> )           \u2013            <p>The desired data-type. Needs to be of type unsigned integer.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>array</code> (              <code>ndarray</code> )          \u2013            <p>Shifted data in same shape as input.</p> </li> </ul> Source code in <code>src/msmhelper/utils/_utils.py</code> <pre><code>def shift_data(array, val_old, val_new, dtype=np.int64):\n    \"\"\"Shift integer array (data) from old to new values.\n\n    !!! warning\n        The values of `val_old`, `val_new` and `data` needs to be integers.\n\n    The basic function is based on Ashwini_Chaudhary solution:\n    https://stackoverflow.com/a/29408060\n\n    Parameters\n    ----------\n    array : StateTraj or ndarray or list or list of ndarrays\n        1D data or a list of data.\n    val_old : ndarray or list\n        Values in data which should be replaced. All values needs to be within\n        the range of `[data.min(), data.max()]`\n    val_new : ndarray or list\n        Values which will be used instead of old ones.\n    dtype : data-type, optional\n        The desired data-type. Needs to be of type unsigned integer.\n\n    Returns\n    -------\n    array : ndarray\n        Shifted data in same shape as input.\n\n    \"\"\"\n    # check data-type\n    if not np.issubdtype(dtype, np.integer):\n        raise TypeError('An unsigned integer type is needed.')\n\n    # flatten data\n    array, shape_kwargs = _flatten_data(array)\n\n    # offset data and val_old to allow negative values\n    offset = np.min([np.min(array), np.min(val_new)])\n\n    # convert to np.array\n    val_old = (np.asarray(val_old) - offset).astype(dtype)\n    val_new = (np.asarray(val_new) - offset).astype(dtype)\n\n    # convert data and shift\n    array = (array - offset).astype(dtype)\n\n    # shift data\n    conv = np.arange(array.max() + 1, dtype=dtype)\n    conv[val_old] = val_new\n    array = conv[array]\n\n    # shift data back\n    array = array.astype(np.int32) + offset\n\n    # reshape and return\n    return _unflatten_data(array, shape_kwargs)\n</code></pre>"},{"location":"reference/#msmhelper.unique","title":"<code>unique(trajs, **kwargs)</code>","text":"<p>Apply numpy.unique to traj.</p> <p>Parameters:</p> <ul> <li> <code>trajs</code>               (<code>list or ndarray or list of ndarrays</code>)           \u2013            <p>State trajectory or list of state trajectories.</p> </li> <li> <code>**kwargs</code>           \u2013            <p>Arguments of numpy.unique</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>unique</code> (              <code>ndarray</code> )          \u2013            <p>Array containing all states, see numpy for more details.</p> </li> </ul> Source code in <code>src/msmhelper/utils/_utils.py</code> <pre><code>def unique(trajs, **kwargs):\n    r\"\"\"Apply numpy.unique to traj.\n\n    Parameters\n    ----------\n    trajs : list or ndarray or list of ndarrays\n        State trajectory or list of state trajectories.\n    **kwargs\n        Arguments of [numpy.unique][]\n\n    Returns\n    -------\n    unique : ndarray\n        Array containing all states, see numpy for more details.\n\n    \"\"\"\n    # flatten data\n    trajs, _ = _flatten_data(trajs)\n\n    # get unique states with population\n    return np.unique(trajs, **kwargs)\n</code></pre>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>msmhelper<ul> <li>io</li> <li>md<ul> <li>comparison</li> <li>corrections</li> <li>timescales</li> </ul> </li> <li>msm<ul> <li>msm</li> <li>tests</li> <li>timescales</li> <li>utils<ul> <li>linalg</li> </ul> </li> </ul> </li> <li>plot</li> <li>statetraj</li> <li>utils<ul> <li>datasets</li> <li>filtering</li> <li>tests</li> </ul> </li> </ul> </li> <li>cli</li> </ul>"},{"location":"reference/cli/","title":"msmhelper","text":"<p>msmhelper v1.1.1</p> <p>Unlock the power of protein dynamics time series with Markov state modeling, by simplifying scientific analysis.</p> <p>Copyright \u00a9 2019-2023, Daniel Nagel</p> <p>Usage:</p> <pre><code>msmhelper [OPTIONS] COMMAND [ARGS]...\n</code></pre> <p>Options:</p> <pre><code>  --help  Show this message and exit.\n</code></pre> <p>Subcommands</p> <ul> <li>ck-test: Estimation and visualization of the Chapman-Kolmogorov test.</li> <li>compare-discretization: Similarity measure of two different state discretizations.</li> <li>contact-rep: Contact representation of states.</li> <li>dynamical-coring: Applying dynamical coring on state trajectory.</li> <li>gaussian-filtering: Applying gaussian filter on time series.</li> <li>implied-timescales: Estimation and visualization of the implied timescales.</li> <li>waiting-time-dist: Estimation and visualization of the waiting time distributions.</li> <li>waiting-times: Estimation and visualization of the waiting times.</li> </ul>"},{"location":"reference/cli/#msmhelper-ck-test","title":"msmhelper ck-test","text":"<p>Estimation and visualization of the Chapman-Kolmogorov test.</p> <p>Usage:</p> <pre><code>msmhelper ck-test [OPTIONS]\n</code></pre> <p>Options:</p> <pre><code>  -f, --filename PATH          Path to state trajectory file (single column\n                               ascii file).  [required]\n  --microfilename PATH         Path to microstate trajectory file (single\n                               column ascii file) to use Hummer-Szabo\n                               projection.\n  -c, --concat-limits PATH     Path to concatination limit file given the\n                               length of all trajectories, e.g. \"3\\n3\\n5\"\n  -o, --output PATH            Output basename of figure. Needs to have a\n                               valid extension (\".pdf\", \".svg\", \".png\").\n                               Default format is pdf.\n  --lagtimes INTEGER RANGE...  5 (!) Lag times given in frames to estimate\n                               Markov state model.  [x&gt;=1; required]\n  --frames-per-unit FLOAT      Number of frames per unit.  [required]\n  --unit [fs|ps|ns|us|frames]  Unit of data.  [required]\n  --grid INTEGER RANGE...      Number of rows and cols.  [x&gt;=1]\n  --max-time INTEGER RANGE     Largest time value to evaluate and plot the\n                               test.  [x&gt;=1]\n  --help                       Show this message and exit.\n</code></pre>"},{"location":"reference/cli/#msmhelper-compare-discretization","title":"msmhelper compare-discretization","text":"<p>Similarity measure of two different state discretizations.</p> <p>Usage:</p> <pre><code>msmhelper compare-discretization [OPTIONS]\n</code></pre> <p>Options:</p> <pre><code>  --traj1 PATH                   Path to first state trajectory file (single\n                                 column ascii file).  [required]\n  --traj2 PATH                   Path to second state trajectory file (single\n                                 column ascii file).  [required]\n  --method [symmetric|directed]  Method of calculating similarity.\n  --help                         Show this message and exit.\n</code></pre>"},{"location":"reference/cli/#msmhelper-contact-rep","title":"msmhelper contact-rep","text":"<p>Contact representation of states.</p> <p>This script creates a contact representation of states. Were the states are obtained by MoSAIC and the contact representation was introduced in Nagel et al.<sup>1</sup>.</p> <p>Usage:</p> <pre><code>msmhelper contact-rep [OPTIONS]\n</code></pre> <p>Options:</p> <pre><code>  --contacts PATH          Path to file holding all contacts (features) of\n                           shape `(n_frames, n_contacts)`.  [required]\n  --clusters PATH          Path to contacts cluster file, where every row is a\n                           cluster and in each row the indices corresponding\n                           to the columns of the clusters are stated.\n                           [required]\n  --state PATH             Path to state trajectory.  [required]\n  -o, --output PATH        Output basename of figure. Needs to have a valid\n                           extension (\".pdf\", \".svg\", \".png\"). Default format\n                           is pdf.\n  --grid INTEGER RANGE...  Number of rows and cols per figure.  [x&gt;=1]\n  --help                   Show this message and exit.\n</code></pre>"},{"location":"reference/cli/#msmhelper-dynamical-coring","title":"msmhelper dynamical-coring","text":"<p>Applying dynamical coring on state trajectory.</p> <p>Usage:</p> <pre><code>msmhelper dynamical-coring [OPTIONS]\n</code></pre> <p>Options:</p> <pre><code>  -i, --input PATH          Path to input file. Needs to be of shape\n                            (n_samples, n_features). All comment lines need to\n                            start with \"#\"  [required]\n  -c, --concat-limits PATH  Path to concatination limit file given the length\n                            of all trajectories, e.g. \"3\\n3\\n5\"\n  -t, --tcor INTEGER RANGE  Coring window given in [frames] used for dynamical\n                            coring.  [x&gt;=1; required]\n  -o, --output PATH         Path to output file.\n  --help                    Show this message and exit.\n</code></pre>"},{"location":"reference/cli/#msmhelper-gaussian-filtering","title":"msmhelper gaussian-filtering","text":"<p>Applying gaussian filter on time series.</p> <p>Usage:</p> <pre><code>msmhelper gaussian-filtering [OPTIONS]\n</code></pre> <p>Options:</p> <pre><code>  -i, --input PATH          Path to input file. Needs to be of shape\n                            (n_samples, n_features). All comment lines need to\n                            start with \"#\"  [required]\n  -c, --concat-limits PATH  Path to concatination limit file given the length\n                            of all trajectories, e.g. \"3\\n3\\n5\"\n  -s, --sigma FLOAT RANGE   Standard deviation given in [frames] used for\n                            Gaussian kernel  [x&gt;=1; required]\n  -o, --output PATH         Path to output file, will be of same shape as\n                            input\n  --help                    Show this message and exit.\n</code></pre>"},{"location":"reference/cli/#msmhelper-implied-timescales","title":"msmhelper implied-timescales","text":"<p>Estimation and visualization of the implied timescales.</p> <p>Usage:</p> <pre><code>msmhelper implied-timescales [OPTIONS]\n</code></pre> <p>Options:</p> <pre><code>  -f, --filename PATH          Path to state trajectory file (single column\n                               ascii file).  [required]\n  --microfilename PATH         Path to microstate trajectory file (single\n                               column ascii file) to use Hummer-Szabo\n                               projection.\n  -c, --concat-limits PATH     Path to concatination limit file given the\n                               length of all trajectories, e.g. \"3\\n3\\n5\"\n  -o, --output PATH            Output name of figure. Needs to have a valid\n                               suffix (\".pdf\", \".svg\", \".png\"). Default format\n                               is pdf.\n  --max-lagtime INTEGER RANGE  Maximal lag time to estimate Markov state model\n                               in frames.  [x&gt;=0; required]\n  --frames-per-unit FLOAT      Number of frames per unit.  [required]\n  --unit [fs|ps|ns|us|frames]  Unit of data.  [required]\n  --n-lagtimes INTEGER RANGE   Number of lagtimes to plot.  [x&gt;=1]\n  --ylog                       Use logarithmic y-axis.\n  --help                       Show this message and exit.\n</code></pre>"},{"location":"reference/cli/#msmhelper-waiting-time-dist","title":"msmhelper waiting-time-dist","text":"<p>Estimation and visualization of the waiting time distributions.</p> <p>Usage:</p> <pre><code>msmhelper waiting-time-dist [OPTIONS]\n</code></pre> <p>Options:</p> <pre><code>  -f, --filename PATH          Path to state trajectory file (single column\n                               ascii file).  [required]\n  --microfilename PATH         Path to microstate trajectory file (single\n                               column ascii file) to use Hummer-Szabo\n                               projection.\n  -c, --concat-limits PATH     Path to concatination limit file given the\n                               length of all trajectories, e.g. \"3\\n3\\n5\"\n  -o, --output PATH            Output name of figure. Needs to have a valid\n                               suffix (\".pdf\", \".svg\", \".png\"). Default format\n                               is pdf.\n  --max-lagtime INTEGER RANGE  Maximal lag time given in frames to estimate\n                               Markov state model.  [x&gt;=1; required]\n  --start INTEGER RANGE        State to start from.  [x&gt;=1; required]\n  --final INTEGER RANGE        State to end in.  [x&gt;=1; required]\n  --nsteps INTEGER RANGE       State to end in.  [x&gt;=1; required]\n  --frames-per-unit FLOAT      Number of frames per unit.  [required]\n  --unit [fs|ps|ns|us|frames]  Unit of data.  [required]\n  --help                       Show this message and exit.\n</code></pre>"},{"location":"reference/cli/#msmhelper-waiting-times","title":"msmhelper waiting-times","text":"<p>Estimation and visualization of the waiting times.</p> <p>Usage:</p> <pre><code>msmhelper waiting-times [OPTIONS]\n</code></pre> <p>Options:</p> <pre><code>  -f, --filename PATH          Path to state trajectory file (single column\n                               ascii file).  [required]\n  --microfilename PATH         Path to microstate trajectory file (single\n                               column ascii file) to use Hummer-Szabo\n                               projection.\n  -c, --concat-limits PATH     Path to concatination limit file given the\n                               length of all trajectories, e.g. \"3\\n3\\n5\"\n  -o, --output PATH            Output name of figure. Needs to have a valid\n                               suffix (\".pdf\", \".svg\", \".png\"). Default format\n                               is pdf.\n  --lagtimes INTEGER RANGE...  3 (!) Lag times given in frames to estimate\n                               Markov state model.  [x&gt;=1; required]\n  --start INTEGER RANGE        State to start from.  [x&gt;=1; required]\n  --final INTEGER RANGE        State to end in.  [x&gt;=1; required]\n  --nsteps INTEGER RANGE       State to end in.  [x&gt;=1; required]\n  --frames-per-unit FLOAT      Number of frames per unit.  [required]\n  --unit [fs|ps|ns|us|frames]  Unit of data.  [required]\n  --help                       Show this message and exit.\n</code></pre> <ol> <li> <p>Nagel et al., Selecting Features for Markov Modeling: A Case Study   on HP35., J. Chem. Theory Comput., submitted,\u00a0\u21a9</p> </li> </ol>"},{"location":"reference/io/","title":"io","text":""},{"location":"reference/io/#msmhelper.io--input-and-output-text-files","title":"Input and Output Text Files","text":"<p>This submodule contains all methods related to reading data from text files and writing data to text files, including helpful header comments.</p>"},{"location":"reference/io/#msmhelper.io.FileError","title":"<code>FileError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>An exception for wrongly formated input files.</p>"},{"location":"reference/io/#msmhelper.io.opentxt","title":"<code>opentxt(file_name, comment='#', nrows=None, **kwargs)</code>","text":"<p>Open a text file.</p> <p>This method can load an nxm array of floats from an ascii file. It uses either pandas read_csv for a single comment or as fallback the slower np.loadtxt for multiple comments.</p> <p>Warning</p> <p>In contrast to pandas the order of usecols will be used. So if using <code>data = opentxt(..., uscols=[1, 0])</code> you access the first column by <code>data[:, 0]</code> and the second one by <code>data[:, 1]</code>.</p> <p>Parameters:</p> <ul> <li> <code>file_name</code>               (<code>string</code>)           \u2013            <p>Name of file to be opened.</p> </li> <li> <code>comment</code>               (<code>str or array of str</code>, default:                   <code>'#'</code> )           \u2013            <p>Characters with which a comment starts.</p> </li> <li> <code>nrows</code>               (<code>int</code>, default:                   <code>None</code> )           \u2013            <p>The maximum number of lines to be read</p> </li> <li> <code>usecols</code>               (<code>int - array</code>)           \u2013            <p>Columns to be read from the file (zero indexed).</p> </li> <li> <code>skiprows</code>               (<code>int</code>)           \u2013            <p>The number of leading rows which will be skipped.</p> </li> <li> <code>dtype</code>               (<code>data - type</code>)           \u2013            <p>Data-type of the resulting array. Default: float.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>array</code> (              <code>ndarray</code> )          \u2013            <p>Data read from the text file.</p> </li> </ul> Source code in <code>src/msmhelper/io.py</code> <pre><code>def opentxt(file_name, comment='#', nrows=None, **kwargs):\n    r\"\"\"Open a text file.\n\n    This method can load an nxm array of floats from an ascii file. It uses\n    either pandas read_csv for a single comment or as fallback the slower\n    [np.loadtxt][numpy.loadtxt] for multiple comments.\n\n    !!! warning\n        In contrast to pandas the order of usecols will be used. So if\n        using `data = opentxt(..., uscols=[1, 0])` you access the first column\n        by `data[:, 0]` and the second one by `data[:, 1]`.\n\n    Parameters\n    ----------\n    file_name : string\n        Name of file to be opened.\n    comment : str or array of str, optional\n        Characters with which a comment starts.\n    nrows : int, optional\n        The maximum number of lines to be read\n    usecols : int-array, optional\n        Columns to be read from the file (zero indexed).\n    skiprows : int, optional\n        The number of leading rows which will be skipped.\n    dtype : data-type, optional\n        Data-type of the resulting array. Default: float.\n\n    Returns\n    -------\n    array : ndarray\n        Data read from the text file.\n\n    \"\"\"\n    if len(comment) == 1:\n        # pandas does not support array of single char\n        if not isinstance(comment, str):\n            comment = comment[0]\n\n        # force pandas to load in stated order without sorting\n        cols = kwargs.pop('usecols', None)\n        if cols is not None:\n            idx = np.argsort(cols)\n            cols = np.atleast_1d(cols).astype(np.int32)[idx]\n\n        array = pd.read_csv(\n            file_name,\n            sep=r'\\s+',\n            header=None,\n            comment=comment,\n            nrows=nrows,\n            usecols=cols,\n            **kwargs,\n        ).values\n\n        if array.shape[-1] == 1:\n            array = array.flatten()\n        # swap columns back to ensure correct order\n        elif cols is not None:\n            array = utils.swapcols(array, idx, np.arange(len(idx)))\n\n        return array\n\n    return np.loadtxt(\n        file_name,\n        comments=comment,\n        max_rows=nrows,\n        **kwargs,\n    )\n</code></pre>"},{"location":"reference/io/#msmhelper.io.savetxt","title":"<code>savetxt(file_name, array, header=None, fmt='%.5f')</code>","text":"<p>Save nxm array of floats to a text file.</p> <p>It uses numpys savetxt method and extends the header with information of execution.</p> <p>Parameters:</p> <ul> <li> <code>file_name</code>               (<code>string</code>)           \u2013            <p>File name to store data.</p> </li> <li> <code>array</code>               (<code>ndarray</code>)           \u2013            <p>Data to be stored.</p> </li> <li> <code>header</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>Comment written into the header of the output file.</p> </li> <li> <code>fmt</code>               (<code>str or sequence of strs</code>, default:                   <code>'%.5f'</code> )           \u2013            <p>See numpy.savetxt.</p> </li> </ul> Source code in <code>src/msmhelper/io.py</code> <pre><code>def savetxt(file_name, array, header=None, fmt='%.5f'):  # noqa: WPS323\n    \"\"\"Save nxm array of floats to a text file.\n\n    It uses numpys savetxt method and extends the header with information\n    of execution.\n\n    Parameters\n    ----------\n    file_name : string\n        File name to store data.\n    array : ndarray\n        Data to be stored.\n    header : str, optional\n        Comment written into the header of the output file.\n    fmt : str or sequence of strs, optional\n        See [numpy.savetxt][].\n\n    \"\"\"\n    # prepare header comments\n    RUI = _get_runtime_user_information()\n\n    header_comment = (\n        'This file was generated by {script_dir}/{script_name}:\\n{args}' +\n        '\\n\\n{date}, {user}@{pc}'\n    ).format(**RUI, args=' '.join(sys.argv))\n\n    if header:  # print column title if given\n        header_comment += '\\n{0}'.format(header)\n\n    # save file\n    np.savetxt(file_name, array, fmt=fmt, header=header_comment)\n</code></pre>"},{"location":"reference/io/#msmhelper.io.opentxt_limits","title":"<code>opentxt_limits(file_name, limits_file=None, **kwargs)</code>","text":"<p>Load file and split according to limit file.</p> <p>If limits_file is not provided it will return <code>[traj]</code>.</p> <p>Parameters:</p> <ul> <li> <code>file_name</code>               (<code>string</code>)           \u2013            <p>Name of file to be opened.</p> </li> <li> <code>limits_file</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>File name of limit file. Should be single column ascii file.</p> </li> <li> <code>**kwargs</code>           \u2013            <p>See parameters defined in opentxt</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>traj</code> (              <code>ndarray</code> )          \u2013            <p>Return array of subtrajectories.</p> </li> </ul> Source code in <code>src/msmhelper/io.py</code> <pre><code>def opentxt_limits(file_name, limits_file=None, **kwargs):\n    \"\"\"Load file and split according to limit file.\n\n    If limits_file is not provided it will return `[traj]`.\n\n    Parameters\n    ----------\n    file_name : string\n        Name of file to be opened.\n    limits_file : str, optional\n        File name of limit file. Should be single column ascii file.\n    **kwargs\n        See parameters defined in [opentxt][msmhelper.io.opentxt]\n\n    Returns\n    -------\n    traj : ndarray\n        Return array of subtrajectories.\n\n    \"\"\"\n    # open trajectory\n    traj = opentxt(file_name, **kwargs)\n\n    # open limits\n    limits = open_limits(limits_file=limits_file, data_length=len(traj))\n\n    # split trajectory\n    return np.split(traj, limits)[:-1]\n</code></pre>"},{"location":"reference/io/#msmhelper.io.openmicrostates","title":"<code>openmicrostates(file_name, limits_file=None, **kwargs)</code>","text":"<p>Load 1d file and split according to limit file.</p> <p>Both, the limit file and the trajectory file needs to be a single column file. If limits_file is not provided it will return [traj]. The trajectory will of dtype np.int16, so the states needs to be smaller than 32767.</p> <p>Parameters:</p> <ul> <li> <code>file_name</code>               (<code>string</code>)           \u2013            <p>Name of file to be opened.</p> </li> <li> <code>limits_file</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>File name of limit file. Should be single column ascii file.</p> </li> <li> <code>**kwargs</code>           \u2013            <p>See parameters defined in opentxt</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>traj</code> (              <code>ndarray</code> )          \u2013            <p>Return array of subtrajectories.</p> </li> </ul> Source code in <code>src/msmhelper/io.py</code> <pre><code>def openmicrostates(file_name, limits_file=None, **kwargs):\n    \"\"\"Load 1d file and split according to limit file.\n\n    Both, the limit file and the trajectory file needs to be a single column\n    file. If limits_file is not provided it will return [traj]. The trajectory\n    will of dtype np.int16, so the states needs to be smaller than 32767.\n\n    Parameters\n    ----------\n    file_name : string\n        Name of file to be opened.\n    limits_file : str, optional\n        File name of limit file. Should be single column ascii file.\n    **kwargs\n        See parameters defined in [opentxt][msmhelper.io.opentxt]\n\n    Returns\n    -------\n    traj : ndarray\n        Return array of subtrajectories.\n\n    \"\"\"\n    # open trajectory\n    if 'dtype' in kwargs and not np.issubdtype(kwargs['dtype'], np.integer):\n        raise TypeError('dtype should be integer')\n    else:\n        kwargs['dtype'] = np.int16\n\n    # load split trajectory\n    traj = opentxt_limits(file_name, limits_file, **kwargs)\n\n    if len(traj[0].shape) != 1:\n        raise FileError('Microstate trjectory shoud be single column file.')\n\n    return traj\n</code></pre>"},{"location":"reference/io/#msmhelper.io.open_limits","title":"<code>open_limits(data_length, limits_file=None)</code>","text":"<p>Load and check limit file.</p> <p>The limits give the length of each single trajectory. So e.g. [5, 5, 5] for 3 equally-sized subtrajectories of length 5.</p> <p>Parameters:</p> <ul> <li> <code>data_length</code>               (<code>int</code>)           \u2013            <p>Length of data read.</p> </li> <li> <code>limits_file</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>File name of limit file. Should be single column ascii file.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>limits</code> (              <code>ndarray</code> )          \u2013            <p>Return cumsum of limits.</p> </li> </ul> Source code in <code>src/msmhelper/io.py</code> <pre><code>def open_limits(data_length, limits_file=None):\n    \"\"\"Load and check limit file.\n\n    The limits give the length of each single trajectory. So e.g.\n    [5, 5, 5] for 3 equally-sized subtrajectories of length 5.\n\n    Parameters\n    ----------\n    data_length : int\n        Length of data read.\n    limits_file : str, optional\n        File name of limit file. Should be single column ascii file.\n\n    Returns\n    -------\n    limits : ndarray\n        Return cumsum of limits.\n\n    \"\"\"\n    if limits_file is None:\n        return np.array([data_length])  # for single trajectory\n\n    # open limits file\n    limits = opentxt(limits_file)\n    if len(limits.shape) != 1:\n        raise FileError('Shoud be single column file.')\n\n    # convert to cumulative sum\n    limits = np.cumsum(limits)\n    if data_length != limits[-1]:\n        raise ValueError('Limits are inconsistent to data.')\n\n    return limits\n</code></pre>"},{"location":"reference/statetraj/","title":"statetraj","text":"<p>Classes for handling discrete state trajectories.</p> <ul> <li> <p>StateTraj is a fast implementation   of a state trajectory and should be used for microstate dynamics.</p> </li> <li> <p>LumpedStateTraj is an   implementation of the Hummer-Szabo projection<sup>1</sup> and allows to reproduce   the microstates dynamics on the macrostates space.</p> </li> </ul> <p>Note</p> <p>One should also mention that for bad coarse-graining one can get negative entries in the transition matrix \\(T_{ij} &lt; 0\\). To prevent this, one can explicitly force \\(T_{ij} \\ge 0\\) by setting the flag <code>positive=True</code>.</p> <ol> <li> <p>Hummer and Szabo, Optimal Dimensionality Reduction of   Multistate Kinetic and Markov-State Models, J. Phys. Chem. B,   119 (29), 9029-9037 (2015),   doi: 10.1021/jp508375q \u21a9</p> </li> </ol>"},{"location":"reference/statetraj/#msmhelper.statetraj.StateTraj","title":"<code>StateTraj(trajs)</code>","text":"<p>Class for handling discrete state trajectories.</p> <p>Initialize StateTraj and convert to index trajectories.</p> <p>If called with StateTraj instance, it will be returned instead.</p> <p>Parameters:</p> <ul> <li> <code>trajs</code>               (<code>list or ndarray or list of ndarray</code>)           \u2013            <p>State trajectory/trajectories. The states need to be integers.</p> </li> </ul> Source code in <code>src/msmhelper/statetraj.py</code> <pre><code>def __init__(self, trajs):\n    \"\"\"Initialize StateTraj and convert to index trajectories.\n\n    If called with StateTraj instance, it will be returned instead.\n\n    Parameters\n    ----------\n    trajs : list or ndarray or list of ndarray\n        State trajectory/trajectories. The states need to be integers.\n\n    \"\"\"\n    if isinstance(trajs, StateTraj):\n        return\n\n    self._trajs = mh.utils.format_state_traj(trajs)\n\n    # get number of states\n    self._states = mh.utils.unique(self._trajs)\n\n    # enforce true copy of trajs\n    if np.array_equal(self._states, np.arange(self.nstates)):\n        self._trajs = [traj.copy() for traj in self._trajs]\n    # shift to indices\n    elif np.array_equal(self._states, np.arange(1, self.nstates + 1)):\n        self._states = np.arange(1, self.nstates + 1)\n        self._trajs = [traj - 1 for traj in self._trajs]\n    else:  # not np.array_equal(self._states, np.arange(self.nstates)):\n        self._trajs, self._states = mh.utils.rename_by_index(\n            self._trajs,\n            return_permutation=True,\n        )\n</code></pre>"},{"location":"reference/statetraj/#msmhelper.statetraj.StateTraj.states","title":"<code>states</code>  <code>property</code>","text":"<p>Return active set of states.</p> <p>Returns:</p> <ul> <li> <code>states</code> (              <code>ndarray</code> )          \u2013            <p>Numpy array holding active set of states.</p> </li> </ul>"},{"location":"reference/statetraj/#msmhelper.statetraj.StateTraj.nstates","title":"<code>nstates</code>  <code>property</code>","text":"<p>Return number of states.</p> <p>Returns:</p> <ul> <li> <code>nstates</code> (              <code>int</code> )          \u2013            <p>Number of states.</p> </li> </ul>"},{"location":"reference/statetraj/#msmhelper.statetraj.StateTraj.ntrajs","title":"<code>ntrajs</code>  <code>property</code>","text":"<p>Return number of trajectories.</p> <p>Returns:</p> <ul> <li> <code>ntrajs</code> (              <code>int</code> )          \u2013            <p>Number of trajectories.</p> </li> </ul>"},{"location":"reference/statetraj/#msmhelper.statetraj.StateTraj.nframes","title":"<code>nframes</code>  <code>property</code>","text":"<p>Return cumulative length of all trajectories.</p> <p>Returns:</p> <ul> <li> <code>nframes</code> (              <code>int</code> )          \u2013            <p>Number of frames of all trajectories.</p> </li> </ul>"},{"location":"reference/statetraj/#msmhelper.statetraj.StateTraj.trajs","title":"<code>trajs</code>  <code>property</code>","text":"<p>Return state trajectory.</p> <p>Returns:</p> <ul> <li> <code>trajs</code> (              <code>list of ndarrays</code> )          \u2013            <p>List of ndarrays holding the input data.</p> </li> </ul>"},{"location":"reference/statetraj/#msmhelper.statetraj.StateTraj.trajs_flatten","title":"<code>trajs_flatten</code>  <code>property</code>","text":"<p>Return flattened state trajectory.</p> <p>Returns:</p> <ul> <li> <code>trajs</code> (              <code>ndarray</code> )          \u2013            <p>1D ndarray representation of state trajectories.</p> </li> </ul>"},{"location":"reference/statetraj/#msmhelper.statetraj.StateTraj.index_trajs","title":"<code>index_trajs</code>  <code>property</code>","text":"<p>Return index trajectory.</p> <p>Returns:</p> <ul> <li> <code>trajs</code> (              <code>list of ndarrays</code> )          \u2013            <p>List of ndarrays holding the input data.</p> </li> </ul>"},{"location":"reference/statetraj/#msmhelper.statetraj.StateTraj.index_trajs_flatten","title":"<code>index_trajs_flatten</code>  <code>property</code>","text":"<p>Return flattened index trajectory.</p> <p>Returns:</p> <ul> <li> <code>trajs</code> (              <code>ndarray</code> )          \u2013            <p>1D ndarray representation of index trajectories.</p> </li> </ul>"},{"location":"reference/statetraj/#msmhelper.statetraj.StateTraj.estimate_markov_model","title":"<code>estimate_markov_model(lagtime)</code>","text":"<p>Estimates Markov State Model.</p> <p>This method estimates the MSM based on the transition count matrix.</p> <p>Parameters:</p> <ul> <li> <code>lagtime</code>               (<code>int</code>)           \u2013            <p>Lag time for estimating the markov model given in [frames].</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>T</code> (              <code>ndarray</code> )          \u2013            <p>Transition probability matrix \\(T_{ij}\\), containing the transition probability transition from state \\(i        o j\\).</p> </li> <li> <code>states</code> (              <code>ndarray</code> )          \u2013            <p>Array holding states corresponding to the columns of \\(T_{ij}\\).</p> </li> </ul> Source code in <code>src/msmhelper/statetraj.py</code> <pre><code>def estimate_markov_model(self, lagtime):\n    \"\"\"Estimates Markov State Model.\n\n    This method estimates the MSM based on the transition count matrix.\n\n    Parameters\n    ----------\n    lagtime : int\n        Lag time for estimating the markov model given in [frames].\n\n    Returns\n    -------\n    T : ndarray\n        Transition probability matrix $T_{ij}$, containing the transition\n        probability transition from state $i\\to j$.\n    states : ndarray\n        Array holding states corresponding to the columns of $T_{ij}$.\n\n    \"\"\"\n    return mh.msm.msm._estimate_markov_model(\n        self.index_trajs,\n        lagtime,\n        self.nstates,\n        self.states,\n    )\n</code></pre>"},{"location":"reference/statetraj/#msmhelper.statetraj.StateTraj.state_to_idx","title":"<code>state_to_idx(state)</code>","text":"<p>Get idx corresponding to state.</p> <p>Parameters:</p> <ul> <li> <code>state</code>               (<code>int</code>)           \u2013            <p>State to get idx of.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>idx</code> (              <code>int</code> )          \u2013            <p>Idx corresponding to state.</p> </li> </ul> Source code in <code>src/msmhelper/statetraj.py</code> <pre><code>def state_to_idx(self, state):\n    \"\"\"Get idx corresponding to state.\n\n    Parameters\n    ----------\n    state : int\n        State to get idx of.\n\n    Returns\n    -------\n    idx : int\n        Idx corresponding to state.\n\n    \"\"\"\n    idx = np.where(self.states == state)[0]\n    if not idx.size:\n        raise ValueError(\n            'State \"{state}\" does not exists in trajectory.'.format(\n                state=state,\n            ),\n        )\n    return idx[0]\n</code></pre>"},{"location":"reference/statetraj/#msmhelper.statetraj.LumpedStateTraj","title":"<code>LumpedStateTraj(macrotrajs, microtrajs=None, positive=False)</code>","text":"<p>               Bases: <code>StateTraj</code></p> <p>Class for using the Hummer-Szabo projection with state trajectories.</p> <p>Initialize LumpedStateTraj.</p> <p>If called with LumpedStateTraj instance, it will be returned instead. This class is an implementation of the Hummer-Szabo projection<sup>1</sup>.</p> <ol> <li> <p>Hummer and Szabo, Optimal Dimensionality Reduction of   Multistate Kinetic and Markov-State Models, J. Phys. Chem. B,   119 (29), 9029-9037 (2015),   doi: 10.1021/jp508375q \u21a9</p> </li> </ol> <p>Parameters:</p> <ul> <li> <code>macrotrajs</code>               (<code>list or ndarray or list of ndarray</code>)           \u2013            <p>Lumped state trajectory/trajectories. The states need to be integers and all states needs to correspond to union of microstates.</p> </li> <li> <code>microtrajs</code>               (<code>list or ndarray or list of ndarray</code>, default:                   <code>None</code> )           \u2013            <p>State trajectory/trajectories. EaThe states should start from zero and need to be integers.</p> </li> <li> <code>positive</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If <code>True</code> \\(T_ij\\ge0\\) will be enforced, else small negative values are possible.</p> </li> </ul> Source code in <code>src/msmhelper/statetraj.py</code> <pre><code>def __init__(self, macrotrajs, microtrajs=None, positive=False):\n    r\"\"\"Initialize LumpedStateTraj.\n\n    If called with LumpedStateTraj instance, it will be returned instead.\n    This class is an implementation of the Hummer-Szabo projection[^1].\n\n    [^1]: Hummer and Szabo, **Optimal Dimensionality Reduction of\n          Multistate Kinetic and Markov-State Models**, *J. Phys. Chem. B*,\n          119 (29), 9029-9037 (2015),\n          doi: [10.1021/jp508375q](https://doi.org/10.1021/jp508375q)\n\n    Parameters\n    ----------\n    macrotrajs : list or ndarray or list of ndarray\n        Lumped state trajectory/trajectories. The states need to be\n        integers and all states needs to correspond to union of\n        microstates.\n    microtrajs : list or ndarray or list of ndarray\n        State trajectory/trajectories. EaThe states should start from zero\n        and need to be integers.\n    positive : bool\n        If `True` $T_ij\\ge0$ will be enforced, else small negative values\n        are possible.\n\n    \"\"\"\n    if isinstance(macrotrajs, LumpedStateTraj):\n        return\n\n    if microtrajs is None:\n        raise TypeError(\n            'microtrajs may only be None when macrotrajs is of type ' +\n            'LumpedStateTraj.',\n        )\n\n    self.positive = positive\n\n    # parse macrotraj\n    macrotrajs = mh.utils.format_state_traj(macrotrajs)\n    self._macrostates = mh.utils.unique(macrotrajs)\n\n    # init microstate trajectories\n    super().__init__(microtrajs)\n\n    # cache flattened trajectories to speed up code for many states\n    macrotrajs_flatten = np.concatenate(macrotrajs)\n    microtrajs_flatten = self.microstate_trajs_flatten\n\n    self._state_assignment = np.zeros(self.nmicrostates, dtype=np.int64)\n    for idx, microstate in enumerate(self.microstates):\n        idx_first = mh.utils.find_first(microstate, microtrajs_flatten)\n        self._state_assignment[idx] = macrotrajs_flatten[idx_first]\n</code></pre>"},{"location":"reference/statetraj/#msmhelper.statetraj.LumpedStateTraj.states","title":"<code>states</code>  <code>property</code>","text":"<p>Return active set of macrostates.</p> <p>Returns:</p> <ul> <li> <code>states</code> (              <code>ndarray</code> )          \u2013            <p>Numpy array holding active set of states.</p> </li> </ul>"},{"location":"reference/statetraj/#msmhelper.statetraj.LumpedStateTraj.nstates","title":"<code>nstates</code>  <code>property</code>","text":"<p>Return number of macrostates.</p> <p>Returns:</p> <ul> <li> <code>nstates</code> (              <code>int</code> )          \u2013            <p>Number of states.</p> </li> </ul>"},{"location":"reference/statetraj/#msmhelper.statetraj.LumpedStateTraj.microstate_trajs","title":"<code>microstate_trajs</code>  <code>property</code>","text":"<p>Return microstate trajectory.</p> <p>Returns:</p> <ul> <li> <code>trajs</code> (              <code>list of ndarrays</code> )          \u2013            <p>List of ndarrays holding the input data.</p> </li> </ul>"},{"location":"reference/statetraj/#msmhelper.statetraj.LumpedStateTraj.microstate_trajs_flatten","title":"<code>microstate_trajs_flatten</code>  <code>property</code>","text":"<p>Return flattened state trajectory.</p> <p>Returns:</p> <ul> <li> <code>trajs</code> (              <code>ndarray</code> )          \u2013            <p>1D ndarrays representation of state trajectories.</p> </li> </ul>"},{"location":"reference/statetraj/#msmhelper.statetraj.LumpedStateTraj.microstate_index_trajs","title":"<code>microstate_index_trajs</code>  <code>property</code>","text":"<p>Return microstate index trajectory.</p> <p>Returns:</p> <ul> <li> <code>trajs</code> (              <code>list of ndarrays</code> )          \u2013            <p>List of ndarrays holding the microstate index trajectory.</p> </li> </ul>"},{"location":"reference/statetraj/#msmhelper.statetraj.LumpedStateTraj.microstate_index_trajs_flatten","title":"<code>microstate_index_trajs_flatten</code>  <code>property</code>","text":"<p>Return flattened microstate index trajectory.</p> <p>Returns:</p> <ul> <li> <code>trajs</code> (              <code>ndarray</code> )          \u2013            <p>1D ndarrays representation of microstate index trajectories.</p> </li> </ul>"},{"location":"reference/statetraj/#msmhelper.statetraj.LumpedStateTraj.trajs","title":"<code>trajs</code>  <code>property</code>","text":"<p>Return macrostate trajectory.</p> <p>Returns:</p> <ul> <li> <code>trajs</code> (              <code>list of ndarrays</code> )          \u2013            <p>List of ndarrays holding the input macrostate data.</p> </li> </ul>"},{"location":"reference/statetraj/#msmhelper.statetraj.LumpedStateTraj.index_trajs","title":"<code>index_trajs</code>  <code>property</code>","text":"<p>Return index trajectory.</p> <p>Returns:</p> <ul> <li> <code>trajs</code> (              <code>list of ndarrays</code> )          \u2013            <p>List of ndarrays holding the input data.</p> </li> </ul>"},{"location":"reference/statetraj/#msmhelper.statetraj.LumpedStateTraj.microstates","title":"<code>microstates</code>  <code>property</code>","text":"<p>Return active set of microstates.</p> <p>Returns:</p> <ul> <li> <code>states</code> (              <code>ndarray</code> )          \u2013            <p>Numpy array holding active set of states.</p> </li> </ul>"},{"location":"reference/statetraj/#msmhelper.statetraj.LumpedStateTraj.nmicrostates","title":"<code>nmicrostates</code>  <code>property</code>","text":"<p>Return number of active set of states.</p> <p>Returns:</p> <ul> <li> <code>states</code> (              <code>ndarray</code> )          \u2013            <p>Numpy array holding active set of states.</p> </li> </ul>"},{"location":"reference/statetraj/#msmhelper.statetraj.LumpedStateTraj.state_assignment","title":"<code>state_assignment</code>  <code>property</code>","text":"<p>Return micro to macrostate assignment vector.</p> <p>Returns:</p> <ul> <li> <code>state_assignment</code> (              <code>ndarray</code> )          \u2013            <p>Micro to macrostate assignment vector.</p> </li> </ul>"},{"location":"reference/statetraj/#msmhelper.statetraj.LumpedStateTraj.estimate_markov_model","title":"<code>estimate_markov_model(lagtime)</code>","text":"<p>Estimates Markov State Model.</p> <p>This method estimates the microstate MSM based on the transition count matrix, followed by Szabo-Hummer projection<sup>1</sup> formalism to macrostates.</p> <ol> <li> <p>Hummer and Szabo, Optimal Dimensionality Reduction of   Multistate Kinetic and Markov-State Models, J. Phys. Chem. B,   119 (29), 9029-9037 (2015),   doi: 10.1021/jp508375q \u21a9</p> </li> </ol> <p>Parameters:</p> <ul> <li> <code>lagtime</code>               (<code>int</code>)           \u2013            <p>Lag time for estimating the markov model given in [frames].</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>T</code> (              <code>ndarray</code> )          \u2013            <p>Transition probability matrix \\(T_{ij}\\), containing the transition probability transition from state \\(i\\to j\\).</p> </li> <li> <code>states</code> (              <code>ndarray</code> )          \u2013            <p>Array holding states corresponding to the columns of \\(T_{ij}\\).</p> </li> </ul> Source code in <code>src/msmhelper/statetraj.py</code> <pre><code>def estimate_markov_model(self, lagtime):\n    r\"\"\"Estimates Markov State Model.\n\n    This method estimates the microstate MSM based on the transition count\n    matrix, followed by Szabo-Hummer projection[^1] formalism to\n    macrostates.\n\n    [^1]: Hummer and Szabo, **Optimal Dimensionality Reduction of\n          Multistate Kinetic and Markov-State Models**, *J. Phys. Chem. B*,\n          119 (29), 9029-9037 (2015),\n          doi: [10.1021/jp508375q](https://doi.org/10.1021/jp508375q)\n\n    Parameters\n    ----------\n    lagtime : int\n        Lag time for estimating the markov model given in [frames].\n\n    Returns\n    -------\n    T : ndarray\n        Transition probability matrix $T_{ij}$, containing the transition\n        probability transition from state $i\\to j$.\n    states : ndarray\n        Array holding states corresponding to the columns of $T_{ij}$.\n\n    \"\"\"\n    # in the following corresponds 'i' to micro and 'a' to macro\n    msm_i, _ = mh.msm.msm._estimate_markov_model(\n        self.microstate_index_trajs,\n        lagtime,\n        self.nmicrostates,\n        self.microstates,\n    )\n    if not mh.utils.tests.is_ergodic(msm_i):\n        raise TypeError('tmat needs to be ergodic transition matrix.')\n    return (self._estimate_markov_model(msm_i), self.states)\n</code></pre>"},{"location":"reference/md/","title":"md","text":""},{"location":"reference/md/#msmhelper.md--time-series-analysis","title":"Time Series Analysis","text":"<p>This submodule offers techniques for the analysis of state trajectories\u2014commonly known as Molecular Dynamics (MD)\u2014without relying on Markov state models. It encompasses functions for determining timescales, recognizing significant events, correcting dynamical anomalies, and evaluating various state discretization methods.  These functions provide a comprehensive solution for analyzing time-series data and understanding the underlying dynamics of complex systems.</p> <p>The submodule is structured into the following submodules:</p> <ul> <li>comparison: This submodule holds methods to quantify the similarity of different state discretizations.</li> <li>corrections: This submodule provides an implementation of dynamical coring.</li> <li>timescales: This submodule contains methods for estimating various timescales based on discrete time series.</li> </ul>"},{"location":"reference/md/#msmhelper.md.compare_discretization","title":"<code>compare_discretization(traj1, traj2, method='symmetric')</code>","text":"<p>Compare similarity of two state discretizations.</p> <p>This method compares the similarity of two state discretizations of the same dataset. There are two different methods, 'directed' gives a measure on how high is the probable to assign a frame correclty knowing the <code>traj1</code>. Hence splitting a state into many is not penalized, while merging multiple into a single state is. Selecting 'symmetric' it is check in both directions, so it checks for each state if it is possible to assigned it forward or backward. Hence, splitting and merging states is not penalized.</p> <p>Parameters:</p> <ul> <li> <code>traj1</code>               (<code>StateTraj like</code>)           \u2013            <p>First state discretization.</p> </li> <li> <code>traj2</code>               (<code>StateTraj like</code>)           \u2013            <p>Second state discretization.</p> </li> <li> <code>method</code>               (<code>[symmetric, directed]</code>, default:                   <code>'symmetric'</code> )           \u2013            <p>Selecting similarity norm. 'symmetric' compares if each frame is forward or backward assignable, while 'directed' checks only if it is forard assignable.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>similarity</code> (              <code>float</code> )          \u2013            <p>Similarity going from [0, 1], where 1 means identical and 0 no similarity at all.</p> </li> </ul> Source code in <code>src/msmhelper/md/comparison.py</code> <pre><code>def compare_discretization(traj1, traj2, method='symmetric'):\n    \"\"\"Compare similarity of two state discretizations.\n\n    This method compares the similarity of two state discretizations of the\n    same dataset. There are two different methods, 'directed' gives a measure\n    on how high is the probable to assign a frame correclty knowing the\n    `traj1`. Hence splitting a state into many is not penalized, while merging\n    multiple into a single state is. Selecting 'symmetric' it is check in both\n    directions, so it checks for each state if it is possible to assigned it\n    forward or backward. Hence, splitting and merging states is not penalized.\n\n    Parameters\n    ----------\n    traj1 : StateTraj like\n        First state discretization.\n    traj2 : StateTraj like\n        Second state discretization.\n    method : ['symmetric', 'directed']\n        Selecting similarity norm. 'symmetric' compares if each frame is\n        forward or backward assignable, while 'directed' checks only if it is\n        forard assignable.\n\n    Returns\n    -------\n    similarity : float\n        Similarity going from [0, 1], where 1 means identical and 0 no\n        similarity at all.\n\n    \"\"\"\n    # format input\n    traj1, traj2 = StateTraj(traj1), StateTraj(traj2)\n    if method not in {'symmetric', 'directed'}:\n        raise ValueError(\n            'Only methods \"symmetric\" and \"directed\" are supported',\n        )\n\n    # check if same length\n    if traj1.nframes != traj2.nframes:\n        raise ValueError(\n            'Trajectories are of different length: ' +\n            '{0} vs {1}'.format(traj1.nframes, traj2.nframes),\n        )\n\n    # check if only single state\n    if traj1.nstates == 1 or traj2.nstates == 1:\n        raise ValueError(\n            'Trajectories needs to have at least two states: ' +\n            '{0} and {1}'.format(traj1.nstates, traj2.nstates),\n        )\n    return _compare_discretization(traj1, traj2, method)\n</code></pre>"},{"location":"reference/md/#msmhelper.md.dynamical_coring","title":"<code>dynamical_coring(trajs, lagtime, iterative=True)</code>","text":"<p>Fix spurious transitions with dynamical coring.</p> <p>Projecting high dimensional data onto low dimensional collective variables can result in spurious state transitions which can be correct for applying dynamical coring, for more details see Nagel et al. <sup>1</sup>.</p> <p>Note</p> <p>Applying dynamical coring on a msmhelper.LumpedStateTraj is not supported. The reason is that while applying dynamical coring on the microstate level leads to different coarse-graining, applying it on the macrostate level the HS-Projection is not well defined anymore.</p> <ol> <li> <p>Nagel et al., Dynamical coring of Markov state models, J. Chem. Phys., 150, 094111 (2019), doi:10.1063/1.5081767 \u21a9</p> </li> </ol> <p>Parameters:</p> <ul> <li> <code>trajs</code>               (<code>StateTraj or list or ndarray or list of ndarray</code>)           \u2013            <p>State trajectory/trajectories. The states should start from zero and need to be integers.</p> </li> <li> <code>lagtime</code>               (<code>int</code>)           \u2013            <p>Lagtime [frames] is the minimum time a trajectory is required to spend in a new state to be accepted.</p> </li> <li> <code>iterative</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If <code>True</code> dynamical coring is applied iteratively with increasing lagtimes, so lagtime=1, 2, ..., lagtimes.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>trajs</code> (              <code>StateTraj</code> )          \u2013            <p>Dynamically corrected state trajectory.</p> </li> </ul> Source code in <code>src/msmhelper/md/corrections.py</code> <pre><code>def dynamical_coring(trajs, lagtime, iterative=True):\n    \"\"\"Fix spurious transitions with dynamical coring.\n\n    Projecting high dimensional data onto low dimensional collective variables\n    can result in spurious state transitions which can be correct for applying\n    dynamical coring, for more details see Nagel et al. [^1].\n\n    !!! note\n        Applying dynamical coring on a [msmhelper.LumpedStateTraj][] is not\n        supported. The reason is that while applying dynamical coring on the\n        microstate level leads to different coarse-graining, applying it on the\n        macrostate level the HS-Projection is not well defined anymore.\n\n    [^1]: Nagel et al., **Dynamical coring of Markov state models**,\n        *J. Chem. Phys.*, 150, 094111 (2019),\n        doi:[10.1063/1.5081767](https://doi.org/10.1063/1.5081767)\n\n    Parameters\n    ----------\n    trajs : StateTraj or list or ndarray or list of ndarray\n        State trajectory/trajectories. The states should start from zero and\n        need to be integers.\n    lagtime : int\n        Lagtime [frames] is the minimum time a trajectory is required to spend\n        in a new state to be accepted.\n    iterative : bool, optional\n        If `True` dynamical coring is applied iteratively with increasing\n        lagtimes, so lagtime=1, 2, ..., lagtimes.\n\n    Returns\n    -------\n    trajs : StateTraj\n        Dynamically corrected state trajectory.\n\n    \"\"\"\n    trajs = StateTraj(trajs)\n\n    if isinstance(trajs, LumpedStateTraj):\n        raise NotImplementedError(\n            'Applying dynamical coring on a LumpedStateTraj is not supported. '\n            'The reason is that while applying dynamical coring on the '\n            'microstate level leads to different coarse-graining, applying it '\n            'on the macrostate level the HS-Projection is not well defined '\n            'anymore.'\n        )\n\n    # convert trajs to numba list # noqa: SC100\n    if numba.config.DISABLE_JIT:\n        cored_trajs = trajs.trajs\n    else:  # pragma: no cover\n        cored_trajs = numba.typed.List(trajs.trajs)\n\n    if lagtime &lt;= 0:\n        raise ValueError('The lagtime should be greater 0.')\n\n    # if lagtime == 1 nothing changes\n    if lagtime == 1:\n        return trajs\n\n    # catch if lagtime &lt;=1\n    return StateTraj(\n        _dynamical_coring(cored_trajs, lagtime, iterative),\n    )\n</code></pre>"},{"location":"reference/md/#msmhelper.md.estimate_waiting_times","title":"<code>estimate_waiting_times(trajs, start, final)</code>","text":"<p>Estimates waiting times between stated states.</p> <p>The stated states (from/to) will be treated as a basin. The function calculates all transitions from first entering the start-basin until first reaching the final-basin.</p> <p>Parameters:</p> <ul> <li> <code>trajs</code>               (<code>statetraj or list or ndarray or list of ndarray</code>)           \u2013            <p>State trajectory/trajectories. The states should start from zero and need to be integers.</p> </li> <li> <code>start</code>               (<code>int or list of</code>)           \u2013            <p>States to start counting.</p> </li> <li> <code>final</code>               (<code>int or list of</code>)           \u2013            <p>States to start counting.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>wt</code> (              <code>ndarray</code> )          \u2013            <p>List of waiting times, given in frames.</p> </li> </ul> Source code in <code>src/msmhelper/md/timescales.py</code> <pre><code>@decorit.alias('estimate_wt')\ndef estimate_waiting_times(trajs, start, final):\n    \"\"\"Estimates waiting times between stated states.\n\n    The stated states (from/to) will be treated as a basin. The function\n    calculates all transitions from first entering the start-basin until first\n    reaching the final-basin.\n\n    Parameters\n    ----------\n    trajs : statetraj or list or ndarray or list of ndarray\n        State trajectory/trajectories. The states should start from zero and\n        need to be integers.\n    start : int or list of\n        States to start counting.\n    final : int or list of\n        States to start counting.\n\n    Returns\n    -------\n    wt : ndarray\n        List of waiting times, given in frames.\n\n    \"\"\"\n    # check correct input format\n    trajs = StateTraj(trajs)\n\n    states_start, states_final = np.unique(start), np.unique(final)\n\n    if intersect(states_start, states_final):\n        raise ValueError('States `start` and `final` do overlap.')\n\n    # check that all states exist in trajectory\n    for states in (states_start, states_final):\n        if intersect(states, trajs.states) != len(states):\n            raise ValueError(\n                'Selected states does not exist in state trajectory.',\n            )\n\n    # do not convert for pytest coverage\n    if numba.config.DISABLE_JIT:\n        return _estimate_waiting_times(trajs, states_start, states_final)\n    return _estimate_waiting_times(  # pragma: no cover\n        numba.typed.List(trajs),\n        numba.typed.List(states_start),\n        numba.typed.List(states_final),\n    )\n</code></pre>"},{"location":"reference/md/#msmhelper.md.estimate_paths","title":"<code>estimate_paths(trajs, start, final)</code>","text":"<p>Estimates paths and waiting times between stated states.</p> <p>The stated states (from/to) will be treated as a basin. The function calculates all transitions from first entering the start-basin until first reaching the final-basin. The results will be listed by the corresponding pathways, where loops are removed occuring first.</p> <p>Parameters:</p> <ul> <li> <code>trajs</code>               (<code>statetraj or list or ndarray or list of ndarray</code>)           \u2013            <p>State trajectory/trajectories. The states should start from zero and need to be integers.</p> </li> <li> <code>start</code>               (<code>int or list of</code>)           \u2013            <p>States to start counting.</p> </li> <li> <code>final</code>               (<code>int or list of</code>)           \u2013            <p>States to start counting.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>paths</code> (              <code>dict</code> )          \u2013            <p>Dictionary containing the the paths as keys and and an array holding the times of all paths as value.</p> </li> </ul> Source code in <code>src/msmhelper/md/timescales.py</code> <pre><code>def estimate_paths(trajs, start, final):\n    \"\"\"Estimates paths and waiting times between stated states.\n\n    The stated states (from/to) will be treated as a basin. The function\n    calculates all transitions from first entering the start-basin until first\n    reaching the final-basin. The results will be listed by the corresponding\n    pathways, where loops are removed occuring first.\n\n    Parameters\n    ----------\n    trajs : statetraj or list or ndarray or list of ndarray\n        State trajectory/trajectories. The states should start from zero and\n        need to be integers.\n    start : int or list of\n        States to start counting.\n    final : int or list of\n        States to start counting.\n\n    Returns\n    -------\n    paths : dict\n        Dictionary containing the the paths as keys and and an array holding\n        the times of all paths as value.\n\n    \"\"\"\n    # check correct input format\n    trajs = StateTraj(trajs)\n\n    states_start, states_final = np.unique(start), np.unique(final)\n\n    if intersect(states_start, states_final):\n        raise ValueError('States `start` and `final` do overlap.')\n\n    # check that all states exist in trajectory\n    for states in (states_start, states_final):\n        if intersect(states, trajs.states) != len(states):\n            raise ValueError(\n                'Selected states does not exist in state trajectory.',\n            )\n\n    # do not convert for pytest coverage\n    if numba.config.DISABLE_JIT:  # pragma: no cover\n        path_tuples = _estimate_paths(trajs, states_start, states_final)\n    else:\n        path_tuples = _estimate_paths(  # pragma: no cover\n            numba.typed.List(trajs),\n            numba.typed.List(states_start),\n            numba.typed.List(states_final),\n        )\n    paths = defaultdict(list)\n    for path, time in path_tuples:\n        paths[tuple(path)].append(time)\n\n    return paths\n</code></pre>"},{"location":"reference/md/comparison/","title":"comparison","text":"<p>Set of helpful functions for comparing different state discretizations.</p> <p>BSD 3-Clause License Copyright \u00a9 2019-2023, Daniel Nagel All rights reserved.</p>"},{"location":"reference/md/comparison/#msmhelper.md.comparison.compare_discretization","title":"<code>compare_discretization(traj1, traj2, method='symmetric')</code>","text":"<p>Compare similarity of two state discretizations.</p> <p>This method compares the similarity of two state discretizations of the same dataset. There are two different methods, 'directed' gives a measure on how high is the probable to assign a frame correclty knowing the <code>traj1</code>. Hence splitting a state into many is not penalized, while merging multiple into a single state is. Selecting 'symmetric' it is check in both directions, so it checks for each state if it is possible to assigned it forward or backward. Hence, splitting and merging states is not penalized.</p> <p>Parameters:</p> <ul> <li> <code>traj1</code>               (<code>StateTraj like</code>)           \u2013            <p>First state discretization.</p> </li> <li> <code>traj2</code>               (<code>StateTraj like</code>)           \u2013            <p>Second state discretization.</p> </li> <li> <code>method</code>               (<code>[symmetric, directed]</code>, default:                   <code>'symmetric'</code> )           \u2013            <p>Selecting similarity norm. 'symmetric' compares if each frame is forward or backward assignable, while 'directed' checks only if it is forard assignable.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>similarity</code> (              <code>float</code> )          \u2013            <p>Similarity going from [0, 1], where 1 means identical and 0 no similarity at all.</p> </li> </ul> Source code in <code>src/msmhelper/md/comparison.py</code> <pre><code>def compare_discretization(traj1, traj2, method='symmetric'):\n    \"\"\"Compare similarity of two state discretizations.\n\n    This method compares the similarity of two state discretizations of the\n    same dataset. There are two different methods, 'directed' gives a measure\n    on how high is the probable to assign a frame correclty knowing the\n    `traj1`. Hence splitting a state into many is not penalized, while merging\n    multiple into a single state is. Selecting 'symmetric' it is check in both\n    directions, so it checks for each state if it is possible to assigned it\n    forward or backward. Hence, splitting and merging states is not penalized.\n\n    Parameters\n    ----------\n    traj1 : StateTraj like\n        First state discretization.\n    traj2 : StateTraj like\n        Second state discretization.\n    method : ['symmetric', 'directed']\n        Selecting similarity norm. 'symmetric' compares if each frame is\n        forward or backward assignable, while 'directed' checks only if it is\n        forard assignable.\n\n    Returns\n    -------\n    similarity : float\n        Similarity going from [0, 1], where 1 means identical and 0 no\n        similarity at all.\n\n    \"\"\"\n    # format input\n    traj1, traj2 = StateTraj(traj1), StateTraj(traj2)\n    if method not in {'symmetric', 'directed'}:\n        raise ValueError(\n            'Only methods \"symmetric\" and \"directed\" are supported',\n        )\n\n    # check if same length\n    if traj1.nframes != traj2.nframes:\n        raise ValueError(\n            'Trajectories are of different length: ' +\n            '{0} vs {1}'.format(traj1.nframes, traj2.nframes),\n        )\n\n    # check if only single state\n    if traj1.nstates == 1 or traj2.nstates == 1:\n        raise ValueError(\n            'Trajectories needs to have at least two states: ' +\n            '{0} and {1}'.format(traj1.nstates, traj2.nstates),\n        )\n    return _compare_discretization(traj1, traj2, method)\n</code></pre>"},{"location":"reference/md/corrections/","title":"corrections","text":"<p>Dynamical corrections.</p> <p>BSD 3-Clause License Copyright \u00a9 2022, Daniel Nagel All rights reserved.</p> <p>Authors: Daniel Nagel</p>"},{"location":"reference/md/corrections/#msmhelper.md.corrections.LagtimeError","title":"<code>LagtimeError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>An exception for the given lagtime was raised.</p>"},{"location":"reference/md/corrections/#msmhelper.md.corrections.dynamical_coring","title":"<code>dynamical_coring(trajs, lagtime, iterative=True)</code>","text":"<p>Fix spurious transitions with dynamical coring.</p> <p>Projecting high dimensional data onto low dimensional collective variables can result in spurious state transitions which can be correct for applying dynamical coring, for more details see Nagel et al. <sup>1</sup>.</p> <p>Note</p> <p>Applying dynamical coring on a msmhelper.LumpedStateTraj is not supported. The reason is that while applying dynamical coring on the microstate level leads to different coarse-graining, applying it on the macrostate level the HS-Projection is not well defined anymore.</p> <ol> <li> <p>Nagel et al., Dynamical coring of Markov state models, J. Chem. Phys., 150, 094111 (2019), doi:10.1063/1.5081767 \u21a9</p> </li> </ol> <p>Parameters:</p> <ul> <li> <code>trajs</code>               (<code>StateTraj or list or ndarray or list of ndarray</code>)           \u2013            <p>State trajectory/trajectories. The states should start from zero and need to be integers.</p> </li> <li> <code>lagtime</code>               (<code>int</code>)           \u2013            <p>Lagtime [frames] is the minimum time a trajectory is required to spend in a new state to be accepted.</p> </li> <li> <code>iterative</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If <code>True</code> dynamical coring is applied iteratively with increasing lagtimes, so lagtime=1, 2, ..., lagtimes.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>trajs</code> (              <code>StateTraj</code> )          \u2013            <p>Dynamically corrected state trajectory.</p> </li> </ul> Source code in <code>src/msmhelper/md/corrections.py</code> <pre><code>def dynamical_coring(trajs, lagtime, iterative=True):\n    \"\"\"Fix spurious transitions with dynamical coring.\n\n    Projecting high dimensional data onto low dimensional collective variables\n    can result in spurious state transitions which can be correct for applying\n    dynamical coring, for more details see Nagel et al. [^1].\n\n    !!! note\n        Applying dynamical coring on a [msmhelper.LumpedStateTraj][] is not\n        supported. The reason is that while applying dynamical coring on the\n        microstate level leads to different coarse-graining, applying it on the\n        macrostate level the HS-Projection is not well defined anymore.\n\n    [^1]: Nagel et al., **Dynamical coring of Markov state models**,\n        *J. Chem. Phys.*, 150, 094111 (2019),\n        doi:[10.1063/1.5081767](https://doi.org/10.1063/1.5081767)\n\n    Parameters\n    ----------\n    trajs : StateTraj or list or ndarray or list of ndarray\n        State trajectory/trajectories. The states should start from zero and\n        need to be integers.\n    lagtime : int\n        Lagtime [frames] is the minimum time a trajectory is required to spend\n        in a new state to be accepted.\n    iterative : bool, optional\n        If `True` dynamical coring is applied iteratively with increasing\n        lagtimes, so lagtime=1, 2, ..., lagtimes.\n\n    Returns\n    -------\n    trajs : StateTraj\n        Dynamically corrected state trajectory.\n\n    \"\"\"\n    trajs = StateTraj(trajs)\n\n    if isinstance(trajs, LumpedStateTraj):\n        raise NotImplementedError(\n            'Applying dynamical coring on a LumpedStateTraj is not supported. '\n            'The reason is that while applying dynamical coring on the '\n            'microstate level leads to different coarse-graining, applying it '\n            'on the macrostate level the HS-Projection is not well defined '\n            'anymore.'\n        )\n\n    # convert trajs to numba list # noqa: SC100\n    if numba.config.DISABLE_JIT:\n        cored_trajs = trajs.trajs\n    else:  # pragma: no cover\n        cored_trajs = numba.typed.List(trajs.trajs)\n\n    if lagtime &lt;= 0:\n        raise ValueError('The lagtime should be greater 0.')\n\n    # if lagtime == 1 nothing changes\n    if lagtime == 1:\n        return trajs\n\n    # catch if lagtime &lt;=1\n    return StateTraj(\n        _dynamical_coring(cored_trajs, lagtime, iterative),\n    )\n</code></pre>"},{"location":"reference/md/timescales/","title":"timescales","text":"<p>Set of functions for analyzing the MD trajectory.</p> <p>This submodule contains methods for estimating various timescales based on a given state trajectory.</p>"},{"location":"reference/md/timescales/#msmhelper.md.timescales.estimate_waiting_times","title":"<code>estimate_waiting_times(trajs, start, final)</code>","text":"<p>Estimates waiting times between stated states.</p> <p>The stated states (from/to) will be treated as a basin. The function calculates all transitions from first entering the start-basin until first reaching the final-basin.</p> <p>Parameters:</p> <ul> <li> <code>trajs</code>               (<code>statetraj or list or ndarray or list of ndarray</code>)           \u2013            <p>State trajectory/trajectories. The states should start from zero and need to be integers.</p> </li> <li> <code>start</code>               (<code>int or list of</code>)           \u2013            <p>States to start counting.</p> </li> <li> <code>final</code>               (<code>int or list of</code>)           \u2013            <p>States to start counting.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>wt</code> (              <code>ndarray</code> )          \u2013            <p>List of waiting times, given in frames.</p> </li> </ul> Source code in <code>src/msmhelper/md/timescales.py</code> <pre><code>@decorit.alias('estimate_wt')\ndef estimate_waiting_times(trajs, start, final):\n    \"\"\"Estimates waiting times between stated states.\n\n    The stated states (from/to) will be treated as a basin. The function\n    calculates all transitions from first entering the start-basin until first\n    reaching the final-basin.\n\n    Parameters\n    ----------\n    trajs : statetraj or list or ndarray or list of ndarray\n        State trajectory/trajectories. The states should start from zero and\n        need to be integers.\n    start : int or list of\n        States to start counting.\n    final : int or list of\n        States to start counting.\n\n    Returns\n    -------\n    wt : ndarray\n        List of waiting times, given in frames.\n\n    \"\"\"\n    # check correct input format\n    trajs = StateTraj(trajs)\n\n    states_start, states_final = np.unique(start), np.unique(final)\n\n    if intersect(states_start, states_final):\n        raise ValueError('States `start` and `final` do overlap.')\n\n    # check that all states exist in trajectory\n    for states in (states_start, states_final):\n        if intersect(states, trajs.states) != len(states):\n            raise ValueError(\n                'Selected states does not exist in state trajectory.',\n            )\n\n    # do not convert for pytest coverage\n    if numba.config.DISABLE_JIT:\n        return _estimate_waiting_times(trajs, states_start, states_final)\n    return _estimate_waiting_times(  # pragma: no cover\n        numba.typed.List(trajs),\n        numba.typed.List(states_start),\n        numba.typed.List(states_final),\n    )\n</code></pre>"},{"location":"reference/md/timescales/#msmhelper.md.timescales.estimate_paths","title":"<code>estimate_paths(trajs, start, final)</code>","text":"<p>Estimates paths and waiting times between stated states.</p> <p>The stated states (from/to) will be treated as a basin. The function calculates all transitions from first entering the start-basin until first reaching the final-basin. The results will be listed by the corresponding pathways, where loops are removed occuring first.</p> <p>Parameters:</p> <ul> <li> <code>trajs</code>               (<code>statetraj or list or ndarray or list of ndarray</code>)           \u2013            <p>State trajectory/trajectories. The states should start from zero and need to be integers.</p> </li> <li> <code>start</code>               (<code>int or list of</code>)           \u2013            <p>States to start counting.</p> </li> <li> <code>final</code>               (<code>int or list of</code>)           \u2013            <p>States to start counting.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>paths</code> (              <code>dict</code> )          \u2013            <p>Dictionary containing the the paths as keys and and an array holding the times of all paths as value.</p> </li> </ul> Source code in <code>src/msmhelper/md/timescales.py</code> <pre><code>def estimate_paths(trajs, start, final):\n    \"\"\"Estimates paths and waiting times between stated states.\n\n    The stated states (from/to) will be treated as a basin. The function\n    calculates all transitions from first entering the start-basin until first\n    reaching the final-basin. The results will be listed by the corresponding\n    pathways, where loops are removed occuring first.\n\n    Parameters\n    ----------\n    trajs : statetraj or list or ndarray or list of ndarray\n        State trajectory/trajectories. The states should start from zero and\n        need to be integers.\n    start : int or list of\n        States to start counting.\n    final : int or list of\n        States to start counting.\n\n    Returns\n    -------\n    paths : dict\n        Dictionary containing the the paths as keys and and an array holding\n        the times of all paths as value.\n\n    \"\"\"\n    # check correct input format\n    trajs = StateTraj(trajs)\n\n    states_start, states_final = np.unique(start), np.unique(final)\n\n    if intersect(states_start, states_final):\n        raise ValueError('States `start` and `final` do overlap.')\n\n    # check that all states exist in trajectory\n    for states in (states_start, states_final):\n        if intersect(states, trajs.states) != len(states):\n            raise ValueError(\n                'Selected states does not exist in state trajectory.',\n            )\n\n    # do not convert for pytest coverage\n    if numba.config.DISABLE_JIT:  # pragma: no cover\n        path_tuples = _estimate_paths(trajs, states_start, states_final)\n    else:\n        path_tuples = _estimate_paths(  # pragma: no cover\n            numba.typed.List(trajs),\n            numba.typed.List(states_start),\n            numba.typed.List(states_final),\n        )\n    paths = defaultdict(list)\n    for path, time in path_tuples:\n        paths[tuple(path)].append(time)\n\n    return paths\n</code></pre>"},{"location":"reference/msm/","title":"msm","text":""},{"location":"reference/msm/#msmhelper.msm--markov-state-modeling","title":"Markov State Modeling","text":"<p>This submodule contains methods related to Markov state modeling, a powerful technique for analyzing complex systems. It provides a set of functions for constructing and analyzing Markov models, including methods for calculating transition probabilities and estimating various time scales.</p> <p>The submodule is structured into the following submodules:</p> <ul> <li>msm: This submodule contains all methods related to estimate the Markov state model.</li> <li>tests: This submodule holds methods for validating Markov state models.</li> <li>timescales: This submodule contains methods for estimating various timescales based on a Markov model.</li> <li>utils: This submodule provides some useful linear algebra methods.</li> </ul>"},{"location":"reference/msm/#msmhelper.msm.chapman_kolmogorov_test","title":"<code>chapman_kolmogorov_test(trajs, lagtimes, tmax)</code>","text":"<p>Calculate the Chapman-Kolmogorov equation.</p> <p>This method evaluates both sides of the Chapman-Kolmogorov equation</p> \\[T(\\tau n) = T^n(\\tau)\\;.\\] <p>So to compare the transition probability estimated based on the lag time \\(n\\tau\\) (referred as \"MD\") with the transition probability estimated based on the lag time \\(\\tau\\) and propagated \\(n\\) times (referred as \"MSM\"), we can use the Chapman-Kolmogorov test. If the model is Markovian, both sides are identical, and the deviation indicates how Markovian the model is. The Chapman-Kolmogorov test is commonly projected onto the diagonal (so limiting to \\(T_{ii}\\)). For more details, see the review by Prinz et al. <sup>1</sup>.</p> <p>The returned dictionary can be visualized using msmhelper.plot.plot_ck_test. An example can be found in the tutorial.</p> <ol> <li> <p>Prinz et al., Markov models of molecular kinetics: Generation and validation, J. Chem. Phys., 134, 174105 (2011), doi:10.1063/1.3565032 \u21a9</p> </li> </ol> <p>Parameters:</p> <ul> <li> <code>trajs</code>               (<code>StateTraj or list or ndarray or list of ndarray</code>)           \u2013            <p>State trajectory/trajectories. The states should start from zero and need to be integers.</p> </li> <li> <code>lagtimes</code>               (<code>list or ndarray int</code>)           \u2013            <p>Lagtimes for estimating the markov model given in [frames].</p> </li> <li> <code>tmax</code>               (<code>int</code>)           \u2013            <p>Longest time to evaluate the CK equation given in [frames].</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>cktest</code> (              <code>dict</code> )          \u2013            <p>Dictionary holding for each lagtime the CK equation and with 'md' the reference.</p> </li> </ul> Source code in <code>src/msmhelper/msm/tests.py</code> <pre><code>@decorit.alias('ck_test')\ndef chapman_kolmogorov_test(trajs, lagtimes, tmax):\n    r\"\"\"Calculate the Chapman-Kolmogorov equation.\n\n    This method evaluates both sides of the Chapman-Kolmogorov equation\n\n    $$T(\\tau n) = T^n(\\tau)\\;.$$\n\n    So to compare the transition probability estimated based on the lag time\n    $n\\tau$ (referred as \"MD\") with the transition probability estimated based\n    on the lag time $\\tau$ and propagated $n$ times (referred as \"MSM\"), we can\n    use the Chapman-Kolmogorov test. If the model is Markovian, both sides are\n    identical, and the deviation indicates how Markovian the model is. The\n    Chapman-Kolmogorov test is commonly projected onto the diagonal (so\n    limiting to $T_{ii}$). For more details, see the review by Prinz et al.\n    [^1].\n\n    The returned dictionary can be visualized using\n    [msmhelper.plot.plot_ck_test][]. An example can be found in the\n    [tutorial](/msmhelper/tutorials/msm/#chapman-kolmogorov-test).\n\n    [^1]: Prinz et al., **Markov models of molecular kinetics: Generation and\n        validation**, *J. Chem. Phys.*, 134, 174105 (2011),\n        doi:[10.1063/1.3565032](https://doi.org/10.1063/1.3565032)\n\n    Parameters\n    ----------\n    trajs : StateTraj or list or ndarray or list of ndarray\n        State trajectory/trajectories. The states should start from zero and\n        need to be integers.\n    lagtimes : list or ndarray int\n        Lagtimes for estimating the markov model given in [frames].\n    tmax : int\n        Longest time to evaluate the CK equation given in [frames].\n\n    Returns\n    -------\n    cktest : dict\n        Dictionary holding for each lagtime the CK equation and with 'md' the\n        reference.\n\n    \"\"\"\n    # format input\n    trajs = StateTraj(trajs)\n    lagtimes = np.atleast_1d(lagtimes)\n    lagtimes = np.sort(lagtimes)\n\n    # check that lag times are array of integers\n    if not np.issubdtype(lagtimes.dtype, np.integer):\n        raise TypeError(\n            'Lagtimes needs to be integers but are {0}'.format(lagtimes.dtype),\n        )\n    if not (lagtimes &gt; 0).all():\n        raise TypeError('Lagtimes needs to be positive integers')\n\n    if lagtimes.ndim != 1:\n        raise TypeError(\n            'Lagtimes needs to be maximal 1d, but {0}'.format(lagtimes),\n        )\n\n    if not isinstance(tmax, int) or tmax &lt; 0:\n        raise TypeError('tmax needs to be a positive integer')\n\n    ckeqs = {}\n    for lagtime in lagtimes:\n        ckeqs[lagtime] = _chapman_kolmogorov_test(trajs, lagtime, tmax)\n    ckeqs['md'] = _chapman_kolmogorov_test_md(\n        trajs, tmin=lagtimes[0], tmax=tmax,\n    )\n\n    return ckeqs\n</code></pre>"},{"location":"reference/msm/#msmhelper.msm.estimate_markov_model","title":"<code>estimate_markov_model(trajs, lagtime)</code>","text":"<p>Estimates Markov State Model.</p> <p>This method estimates the MSM based on the transition count matrix.</p> <p>Parameters:</p> <ul> <li> <code>trajs</code>               (<code>StateTraj or list or ndarray or list of ndarray</code>)           \u2013            <p>State trajectory/trajectories used to estimate the MSM.</p> </li> <li> <code>lagtime</code>               (<code>int</code>)           \u2013            <p>Lag time for estimating the markov model given in [frames].</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>T</code> (              <code>ndarray</code> )          \u2013            <p>Transition probability matrix \\(T_{ij}\\), containing the transition probability transition from state \\(i    o j\\).</p> </li> <li> <code>states</code> (              <code>ndarray</code> )          \u2013            <p>Array holding states corresponding to the columns of \\(T_{ij}\\).</p> </li> </ul> Source code in <code>src/msmhelper/msm/msm.py</code> <pre><code>def estimate_markov_model(trajs, lagtime):\n    \"\"\"Estimates Markov State Model.\n\n    This method estimates the MSM based on the transition count matrix.\n\n    Parameters\n    ----------\n    trajs : StateTraj or list or ndarray or list of ndarray\n        State trajectory/trajectories used to estimate the MSM.\n    lagtime : int\n        Lag time for estimating the markov model given in [frames].\n\n    Returns\n    -------\n    T : ndarray\n        Transition probability matrix $T_{ij}$, containing the transition\n        probability transition from state $i\\to j$.\n    states : ndarray\n        Array holding states corresponding to the columns of $T_{ij}$.\n\n    \"\"\"\n    trajs = StateTraj(trajs)\n    return trajs.estimate_markov_model(lagtime)\n</code></pre>"},{"location":"reference/msm/#msmhelper.msm.equilibrium_population","title":"<code>equilibrium_population(tmat, allow_non_ergodic=True)</code>","text":"<p>Calculate equilibirum population.</p> <p>If there are non ergodic states, their population is set to zero.</p> <p>Parameters:</p> <ul> <li> <code>tmat</code>               (<code>ndarray</code>)           \u2013            <p>Quadratic transition matrix, needs to be ergodic.</p> </li> <li> <code>allow_non_ergodic</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True only the largest ergodic subset will be used. Otherwise it will throw an error if not ergodic.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>peq</code> (              <code>ndarray</code> )          \u2013            <p>Equilibrium population of input matrix.</p> </li> </ul> Source code in <code>src/msmhelper/msm/msm.py</code> <pre><code>@decorit.alias('peq')\ndef equilibrium_population(tmat, allow_non_ergodic=True):\n    \"\"\"Calculate equilibirum population.\n\n    If there are non ergodic states, their population is set to zero.\n\n    Parameters\n    ----------\n    tmat : ndarray\n        Quadratic transition matrix, needs to be ergodic.\n    allow_non_ergodic : bool\n        If True only the largest ergodic subset will be used. Otherwise it will\n        throw an error if not ergodic.\n\n    Returns\n    -------\n    peq : ndarray\n        Equilibrium population of input matrix.\n\n    \"\"\"\n    tmat = np.asarray(tmat)\n    is_ergodic = tests.is_ergodic(tmat)\n    if not allow_non_ergodic and not is_ergodic:\n        raise ValueError('tmat needs to be ergodic transition matrix.')\n\n    # calculate ev for ergodic subset\n    if is_ergodic:\n        _, eigenvectors = linalg.left_eigenvectors(tmat, nvals=1)\n        eigenvectors = eigenvectors[0]\n    else:\n        mask = tests.ergodic_mask(tmat)\n        _, evs_mask = linalg.left_eigenvectors(\n            row_normalize_matrix(\n                tmat[np.ix_(mask, mask)],\n            ),\n            nvals=1,\n        )\n\n        eigenvectors = np.zeros(len(tmat), dtype=tmat.dtype)\n        eigenvectors[mask] = evs_mask[0]\n\n    return eigenvectors / np.sum(eigenvectors)\n</code></pre>"},{"location":"reference/msm/#msmhelper.msm.row_normalize_matrix","title":"<code>row_normalize_matrix(mat)</code>","text":"<p>Row normalize the given 2d matrix.</p> <p>Parameters:</p> <ul> <li> <code>mat</code>               (<code>ndarray</code>)           \u2013            <p>Matrix to be row normalized.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>mat</code> (              <code>ndarray</code> )          \u2013            <p>Normalized matrix.</p> </li> </ul> Source code in <code>src/msmhelper/msm/msm.py</code> <pre><code>@numba.njit\ndef row_normalize_matrix(mat):\n    \"\"\"Row normalize the given 2d matrix.\n\n    Parameters\n    ----------\n    mat : ndarray\n        Matrix to be row normalized.\n\n    Returns\n    -------\n    mat : ndarray\n        Normalized matrix.\n\n    \"\"\"\n    row_sum = np.sum(mat, axis=1)\n    if not row_sum.all():\n        row_sum[row_sum == 0] = 1\n\n    # due to missing np.newaxis row_sum[:, np.newaxis] becomes # noqa: SC100\n    return mat / row_sum.reshape(mat.shape[0], 1)\n</code></pre>"},{"location":"reference/msm/#msmhelper.msm.implied_timescales","title":"<code>implied_timescales(trajs, lagtimes, ntimescales=None, reversible=False)</code>","text":"<p>Calculate the implied timescales.</p> <p>Calculate the implied timescales, which are defined by</p> \\[t_i = - \\frac{t_\\text{lag}}{\\log\\lambda_i}\\] <p>the \\(i\\)-th eigenvalue \\(\\lambda_i\\).</p> <p>Note</p> <p>It is not checked if for higher lagtimes the dimensionality changes.</p> <p>Parameters:</p> <ul> <li> <code>trajs</code>               (<code>StateTraj or list or ndarray or list of ndarray</code>)           \u2013            <p>State trajectory/trajectories. The states should start from zero and need to be integers.</p> </li> <li> <code>lagtimes</code>               (<code>list or ndarray int</code>)           \u2013            <p>Lagtimes for estimating the markov model given in [frames]. This is not implemented yet!</p> </li> <li> <code>ntimescales</code>               (<code>int</code>, default:                   <code>None</code> )           \u2013            <p>Number of returned lagtimes.</p> </li> <li> <code>reversible</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If reversibility should be enforced for the markov state model.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ts</code> (              <code>ndarray</code> )          \u2013            <p>Matrix containing the implied Timescales.</p> </li> </ul> Source code in <code>src/msmhelper/msm/timescales.py</code> <pre><code>def implied_timescales(trajs, lagtimes, ntimescales=None, reversible=False):\n    r\"\"\"Calculate the implied timescales.\n\n    Calculate the implied timescales, which are defined by\n\n    $$t_i = - \\frac{t_\\text{lag}}{\\log\\lambda_i}$$\n\n    the $i$-th eigenvalue $\\lambda_i$.\n\n    !!! note\n        It is not checked if for higher lagtimes the dimensionality changes.\n\n    Parameters\n    ----------\n    trajs : StateTraj or list or ndarray or list of ndarray\n        State trajectory/trajectories. The states should start from zero and\n        need to be integers.\n    lagtimes : list or ndarray int\n        Lagtimes for estimating the markov model given in [frames].\n        This is not implemented yet!\n    ntimescales : int, optional\n        Number of returned lagtimes.\n    reversible : bool\n        If reversibility should be enforced for the markov state model.\n\n    Returns\n    -------\n    ts : ndarray\n        Matrix containing the implied Timescales.\n\n    \"\"\"\n    # format input\n    trajs = StateTraj(trajs)\n    lagtimes = np.atleast_1d(lagtimes)\n\n    # check that lag times are array of integers\n    if not np.issubdtype(lagtimes.dtype, np.integer):\n        raise TypeError(\n            'Lagtimes needs to be integers but are {0}'.format(lagtimes.dtype),\n        )\n    if not (lagtimes &gt; 0).all():\n        raise TypeError('Lagtimes needs to be positive integers')\n    if reversible:\n        raise NotImplementedError(\n            'Reversible matrices are not anymore supported.'\n        )\n\n    if ntimescales is None:\n        ntimescales = trajs.nstates - 1\n\n    # initialize result\n    impl_timescales = np.zeros((len(lagtimes), ntimescales))\n\n    for idx, lagtime in enumerate(lagtimes):\n        transmat, _ = trajs.estimate_markov_model(lagtime)\n        impl_timescales[idx] = _implied_timescales(\n            transmat, lagtime, ntimescales=ntimescales,\n        )\n\n    return impl_timescales\n</code></pre>"},{"location":"reference/msm/#msmhelper.msm.estimate_waiting_times","title":"<code>estimate_waiting_times(*, trajs, lagtime, start, final, steps, return_list=False)</code>","text":"<p>Estimates waiting times between stated states.</p> <p>The stated states (from/to) will be treated as a basin. The function calculates all transitions from first entering the start-basin until first reaching the final-basin.</p> <p>Parameters:</p> <ul> <li> <code>trajs</code>               (<code>statetraj or list or ndarray or list of ndarray</code>)           \u2013            <p>State trajectory/trajectories. The states should start from zero and need to be integers.</p> </li> <li> <code>lagtime</code>               (<code>int</code>)           \u2013            <p>Lag time for estimating the markov model given in [frames].</p> </li> <li> <code>start</code>               (<code>int or list of</code>)           \u2013            <p>States to start counting.</p> </li> <li> <code>final</code>               (<code>int or list of</code>)           \u2013            <p>States to start counting.</p> </li> <li> <code>steps</code>               (<code>int</code>)           \u2013            <p>Number of MCMC propagation steps of MCMC run.</p> </li> <li> <code>return_list</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If true a list of all events is returned, else the probability density together with the edges is returned.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ts</code> (              <code>ndarray</code> )          \u2013            <p>Density probability of the time distribution. If <code>return_list=True</code>, return a sorted (!) list containing all times.</p> </li> <li> <code>edges</code> (              <code>ndarray</code> )          \u2013            <p>Array containing the edges corresponding to the probability, given in frames. Only for <code>return_list=False</code>.</p> </li> </ul> Source code in <code>src/msmhelper/msm/timescales.py</code> <pre><code>@decorit.alias('estimate_wt')\ndef estimate_waiting_times(\n    *,\n    trajs,\n    lagtime,\n    start,\n    final,\n    steps,\n    return_list=False,\n):\n    \"\"\"Estimates waiting times between stated states.\n\n    The stated states (from/to) will be treated as a basin. The function\n    calculates all transitions from first entering the start-basin until first\n    reaching the final-basin.\n\n    Parameters\n    ----------\n    trajs : statetraj or list or ndarray or list of ndarray\n        State trajectory/trajectories. The states should start from zero and\n        need to be integers.\n    lagtime : int\n        Lag time for estimating the markov model given in [frames].\n    start : int or list of\n        States to start counting.\n    final : int or list of\n        States to start counting.\n    steps : int\n        Number of MCMC propagation steps of MCMC run.\n    return_list : bool\n        If true a list of all events is returned, else the probability density\n        together with the edges is returned.\n\n    Returns\n    -------\n    ts : ndarray\n        Density probability of the time distribution. If `return_list=True`,\n        return a sorted (!) list containing all times.\n    edges : ndarray\n        Array containing the edges corresponding to the probability, given in\n        frames. Only for `return_list=False`.\n\n    \"\"\"\n    return _estimate_times(\n        trajs=trajs,\n        lagtime=lagtime,\n        start=start,\n        final=final,\n        steps=steps,\n        estimator=_estimate_waiting_times,\n        return_list=return_list,\n    )\n</code></pre>"},{"location":"reference/msm/#msmhelper.msm.estimate_waiting_time_dist","title":"<code>estimate_waiting_time_dist(trajs, max_lagtime, start, final, steps, n_lagtimes=50)</code>","text":"<p>Estimate waiting time distribution.</p> <p>Parameters:</p> <ul> <li> <code>trajs</code>               (<code>statetraj or list or ndarray or list of ndarray</code>)           \u2013            <p>State trajectory/trajectories. The states should start from zero and need to be integers.</p> </li> <li> <code>max_lagtime</code>               (<code>int</code>)           \u2013            <p>Maximal lag time for estimating the markov model given in [frames].</p> </li> <li> <code>start</code>               (<code>int or list of</code>)           \u2013            <p>States to start counting.</p> </li> <li> <code>final</code>               (<code>int or list of</code>)           \u2013            <p>States to start counting.</p> </li> <li> <code>steps</code>               (<code>int</code>)           \u2013            <p>Number of MCMC propagation steps of MCMC run.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>wtd</code> (              <code>dict</code> )          \u2013            <p>Dictionary containing waiting time distribution.</p> </li> </ul> Source code in <code>src/msmhelper/msm/timescales.py</code> <pre><code>@decorit.alias('estimate_wtd')\ndef estimate_waiting_time_dist(\n    trajs,\n    max_lagtime,\n    start,\n    final,\n    steps,\n    n_lagtimes=50,\n):\n    \"\"\"Estimate waiting time distribution.\n\n    Parameters\n    ----------\n    trajs : statetraj or list or ndarray or list of ndarray\n        State trajectory/trajectories. The states should start from zero and\n        need to be integers.\n    max_lagtime : int\n        Maximal lag time for estimating the markov model given in [frames].\n    start : int or list of\n        States to start counting.\n    final : int or list of\n        States to start counting.\n    steps : int\n        Number of MCMC propagation steps of MCMC run.\n\n    Returns\n    -------\n    wtd : dict\n        Dictionary containing waiting time distribution.\n\n    \"\"\"\n    lagtimes = np.unique(\n        np.linspace(1, max_lagtime, num=n_lagtimes, dtype=int),\n    )\n\n    # get stats\n    wtd = {\n        lagtime: boxplot_stats(\n            estimate_waiting_times(\n                trajs=trajs,\n                lagtime=lagtime,\n                start=start,\n                final=final,\n                steps=steps,\n                return_list=True,\n            ),\n        )[0]\n        for lagtime in lagtimes\n    }\n\n    # include MD\n    wtd['MD'] = boxplot_stats(\n        md_estimate_wt(\n            trajs=trajs,\n            start=start,\n            final=final,\n        ),\n    )\n    return wtd\n</code></pre>"},{"location":"reference/msm/#msmhelper.msm.estimate_paths","title":"<code>estimate_paths(*, trajs, lagtime, start, final, steps)</code>","text":"<p>Estimates paths and waiting times between stated states.</p> <p>The stated states (from/to) will be treated as a basin. The function estimates transitions from first entering the start-basin until first reaching the final-basin. The results will be listed by the corresponding pathways, where loops are removed occuring first.</p> <p>Note</p> <p>This function is a simple wrapper and in contrast to estimate_wt it stores the whole MCMC trajectory in memory. Hence, it memory-hungry.</p> <p>Parameters:</p> <ul> <li> <code>trajs</code>               (<code>statetraj or list or ndarray or list of ndarray</code>)           \u2013            <p>State trajectory/trajectories. The states should start from zero and need to be integers.</p> </li> <li> <code>lagtime</code>               (<code>int</code>)           \u2013            <p>Lag time for estimating the markov model given in [frames].</p> </li> <li> <code>start</code>               (<code>int or list of</code>)           \u2013            <p>States to start counting.</p> </li> <li> <code>final</code>               (<code>int or list of</code>)           \u2013            <p>States to start counting.</p> </li> <li> <code>steps</code>               (<code>int</code>)           \u2013            <p>Number of MCMC propagation steps of MCMC run.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>paths</code> (              <code>dict</code> )          \u2013            <p>Dictionary containing the the paths as keys and and an array holding the times of all paths as value.</p> </li> </ul> Source code in <code>src/msmhelper/msm/timescales.py</code> <pre><code>def estimate_paths(\n    *,\n    trajs,\n    lagtime,\n    start,\n    final,\n    steps,\n):\n    \"\"\"Estimates paths and waiting times between stated states.\n\n    The stated states (from/to) will be treated as a basin. The function\n    estimates transitions from first entering the start-basin until first\n    reaching the final-basin. The results will be listed by the corresponding\n    pathways, where loops are removed occuring first.\n\n    !!! note\n        This function is a simple wrapper and in contrast to\n        [estimate_wt][msmhelper.msm.estimate_waiting_times] it stores the whole\n        MCMC trajectory in memory. Hence, it memory-hungry.\n\n    Parameters\n    ----------\n    trajs : statetraj or list or ndarray or list of ndarray\n        State trajectory/trajectories. The states should start from zero and\n        need to be integers.\n    lagtime : int\n        Lag time for estimating the markov model given in [frames].\n    start : int or list of\n        States to start counting.\n    final : int or list of\n        States to start counting.\n    steps : int\n        Number of MCMC propagation steps of MCMC run.\n\n    Returns\n    -------\n    paths : dict\n        Dictionary containing the the paths as keys and and an array holding\n        the times of all paths as value.\n\n    \"\"\"\n    # check correct input format\n    trajs = StateTraj(trajs)\n\n    states_start, states_final = np.unique(start), np.unique(final)\n\n    if intersect(states_start, states_final):\n        raise ValueError('States `start` and `final` do overlap.')\n\n    # check that all states exist in trajectory\n    for states in (states_start, states_final):\n        if intersect(states, trajs.states) != len(states):\n            raise ValueError(\n                'Selected states does not exist in state trajectory.',\n            )\n\n    return md_estimate_paths(\n        propagate_MCMC(trajs, lagtime, steps),\n        start,\n        final,\n    )\n</code></pre>"},{"location":"reference/msm/msm/","title":"msm","text":"<p>Create Markov State Model.</p> <p>This submodule contains all methods related to estimate the Markov state model.</p>"},{"location":"reference/msm/msm/#msmhelper.msm.msm.estimate_markov_model","title":"<code>estimate_markov_model(trajs, lagtime)</code>","text":"<p>Estimates Markov State Model.</p> <p>This method estimates the MSM based on the transition count matrix.</p> <p>Parameters:</p> <ul> <li> <code>trajs</code>               (<code>StateTraj or list or ndarray or list of ndarray</code>)           \u2013            <p>State trajectory/trajectories used to estimate the MSM.</p> </li> <li> <code>lagtime</code>               (<code>int</code>)           \u2013            <p>Lag time for estimating the markov model given in [frames].</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>T</code> (              <code>ndarray</code> )          \u2013            <p>Transition probability matrix \\(T_{ij}\\), containing the transition probability transition from state \\(i    o j\\).</p> </li> <li> <code>states</code> (              <code>ndarray</code> )          \u2013            <p>Array holding states corresponding to the columns of \\(T_{ij}\\).</p> </li> </ul> Source code in <code>src/msmhelper/msm/msm.py</code> <pre><code>def estimate_markov_model(trajs, lagtime):\n    \"\"\"Estimates Markov State Model.\n\n    This method estimates the MSM based on the transition count matrix.\n\n    Parameters\n    ----------\n    trajs : StateTraj or list or ndarray or list of ndarray\n        State trajectory/trajectories used to estimate the MSM.\n    lagtime : int\n        Lag time for estimating the markov model given in [frames].\n\n    Returns\n    -------\n    T : ndarray\n        Transition probability matrix $T_{ij}$, containing the transition\n        probability transition from state $i\\to j$.\n    states : ndarray\n        Array holding states corresponding to the columns of $T_{ij}$.\n\n    \"\"\"\n    trajs = StateTraj(trajs)\n    return trajs.estimate_markov_model(lagtime)\n</code></pre>"},{"location":"reference/msm/msm/#msmhelper.msm.msm.row_normalize_matrix","title":"<code>row_normalize_matrix(mat)</code>","text":"<p>Row normalize the given 2d matrix.</p> <p>Parameters:</p> <ul> <li> <code>mat</code>               (<code>ndarray</code>)           \u2013            <p>Matrix to be row normalized.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>mat</code> (              <code>ndarray</code> )          \u2013            <p>Normalized matrix.</p> </li> </ul> Source code in <code>src/msmhelper/msm/msm.py</code> <pre><code>@numba.njit\ndef row_normalize_matrix(mat):\n    \"\"\"Row normalize the given 2d matrix.\n\n    Parameters\n    ----------\n    mat : ndarray\n        Matrix to be row normalized.\n\n    Returns\n    -------\n    mat : ndarray\n        Normalized matrix.\n\n    \"\"\"\n    row_sum = np.sum(mat, axis=1)\n    if not row_sum.all():\n        row_sum[row_sum == 0] = 1\n\n    # due to missing np.newaxis row_sum[:, np.newaxis] becomes # noqa: SC100\n    return mat / row_sum.reshape(mat.shape[0], 1)\n</code></pre>"},{"location":"reference/msm/msm/#msmhelper.msm.msm.equilibrium_population","title":"<code>equilibrium_population(tmat, allow_non_ergodic=True)</code>","text":"<p>Calculate equilibirum population.</p> <p>If there are non ergodic states, their population is set to zero.</p> <p>Parameters:</p> <ul> <li> <code>tmat</code>               (<code>ndarray</code>)           \u2013            <p>Quadratic transition matrix, needs to be ergodic.</p> </li> <li> <code>allow_non_ergodic</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True only the largest ergodic subset will be used. Otherwise it will throw an error if not ergodic.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>peq</code> (              <code>ndarray</code> )          \u2013            <p>Equilibrium population of input matrix.</p> </li> </ul> Source code in <code>src/msmhelper/msm/msm.py</code> <pre><code>@decorit.alias('peq')\ndef equilibrium_population(tmat, allow_non_ergodic=True):\n    \"\"\"Calculate equilibirum population.\n\n    If there are non ergodic states, their population is set to zero.\n\n    Parameters\n    ----------\n    tmat : ndarray\n        Quadratic transition matrix, needs to be ergodic.\n    allow_non_ergodic : bool\n        If True only the largest ergodic subset will be used. Otherwise it will\n        throw an error if not ergodic.\n\n    Returns\n    -------\n    peq : ndarray\n        Equilibrium population of input matrix.\n\n    \"\"\"\n    tmat = np.asarray(tmat)\n    is_ergodic = tests.is_ergodic(tmat)\n    if not allow_non_ergodic and not is_ergodic:\n        raise ValueError('tmat needs to be ergodic transition matrix.')\n\n    # calculate ev for ergodic subset\n    if is_ergodic:\n        _, eigenvectors = linalg.left_eigenvectors(tmat, nvals=1)\n        eigenvectors = eigenvectors[0]\n    else:\n        mask = tests.ergodic_mask(tmat)\n        _, evs_mask = linalg.left_eigenvectors(\n            row_normalize_matrix(\n                tmat[np.ix_(mask, mask)],\n            ),\n            nvals=1,\n        )\n\n        eigenvectors = np.zeros(len(tmat), dtype=tmat.dtype)\n        eigenvectors[mask] = evs_mask[0]\n\n    return eigenvectors / np.sum(eigenvectors)\n</code></pre>"},{"location":"reference/msm/tests/","title":"tests","text":"<p>Benchmark Markov State Model.</p> <p>This submodule holds methods for validating Markov state models.</p>"},{"location":"reference/msm/tests/#msmhelper.msm.tests.chapman_kolmogorov_test","title":"<code>chapman_kolmogorov_test(trajs, lagtimes, tmax)</code>","text":"<p>Calculate the Chapman-Kolmogorov equation.</p> <p>This method evaluates both sides of the Chapman-Kolmogorov equation</p> \\[T(\\tau n) = T^n(\\tau)\\;.\\] <p>So to compare the transition probability estimated based on the lag time \\(n\\tau\\) (referred as \"MD\") with the transition probability estimated based on the lag time \\(\\tau\\) and propagated \\(n\\) times (referred as \"MSM\"), we can use the Chapman-Kolmogorov test. If the model is Markovian, both sides are identical, and the deviation indicates how Markovian the model is. The Chapman-Kolmogorov test is commonly projected onto the diagonal (so limiting to \\(T_{ii}\\)). For more details, see the review by Prinz et al. <sup>1</sup>.</p> <p>The returned dictionary can be visualized using msmhelper.plot.plot_ck_test. An example can be found in the tutorial.</p> <ol> <li> <p>Prinz et al., Markov models of molecular kinetics: Generation and validation, J. Chem. Phys., 134, 174105 (2011), doi:10.1063/1.3565032 \u21a9</p> </li> </ol> <p>Parameters:</p> <ul> <li> <code>trajs</code>               (<code>StateTraj or list or ndarray or list of ndarray</code>)           \u2013            <p>State trajectory/trajectories. The states should start from zero and need to be integers.</p> </li> <li> <code>lagtimes</code>               (<code>list or ndarray int</code>)           \u2013            <p>Lagtimes for estimating the markov model given in [frames].</p> </li> <li> <code>tmax</code>               (<code>int</code>)           \u2013            <p>Longest time to evaluate the CK equation given in [frames].</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>cktest</code> (              <code>dict</code> )          \u2013            <p>Dictionary holding for each lagtime the CK equation and with 'md' the reference.</p> </li> </ul> Source code in <code>src/msmhelper/msm/tests.py</code> <pre><code>@decorit.alias('ck_test')\ndef chapman_kolmogorov_test(trajs, lagtimes, tmax):\n    r\"\"\"Calculate the Chapman-Kolmogorov equation.\n\n    This method evaluates both sides of the Chapman-Kolmogorov equation\n\n    $$T(\\tau n) = T^n(\\tau)\\;.$$\n\n    So to compare the transition probability estimated based on the lag time\n    $n\\tau$ (referred as \"MD\") with the transition probability estimated based\n    on the lag time $\\tau$ and propagated $n$ times (referred as \"MSM\"), we can\n    use the Chapman-Kolmogorov test. If the model is Markovian, both sides are\n    identical, and the deviation indicates how Markovian the model is. The\n    Chapman-Kolmogorov test is commonly projected onto the diagonal (so\n    limiting to $T_{ii}$). For more details, see the review by Prinz et al.\n    [^1].\n\n    The returned dictionary can be visualized using\n    [msmhelper.plot.plot_ck_test][]. An example can be found in the\n    [tutorial](/msmhelper/tutorials/msm/#chapman-kolmogorov-test).\n\n    [^1]: Prinz et al., **Markov models of molecular kinetics: Generation and\n        validation**, *J. Chem. Phys.*, 134, 174105 (2011),\n        doi:[10.1063/1.3565032](https://doi.org/10.1063/1.3565032)\n\n    Parameters\n    ----------\n    trajs : StateTraj or list or ndarray or list of ndarray\n        State trajectory/trajectories. The states should start from zero and\n        need to be integers.\n    lagtimes : list or ndarray int\n        Lagtimes for estimating the markov model given in [frames].\n    tmax : int\n        Longest time to evaluate the CK equation given in [frames].\n\n    Returns\n    -------\n    cktest : dict\n        Dictionary holding for each lagtime the CK equation and with 'md' the\n        reference.\n\n    \"\"\"\n    # format input\n    trajs = StateTraj(trajs)\n    lagtimes = np.atleast_1d(lagtimes)\n    lagtimes = np.sort(lagtimes)\n\n    # check that lag times are array of integers\n    if not np.issubdtype(lagtimes.dtype, np.integer):\n        raise TypeError(\n            'Lagtimes needs to be integers but are {0}'.format(lagtimes.dtype),\n        )\n    if not (lagtimes &gt; 0).all():\n        raise TypeError('Lagtimes needs to be positive integers')\n\n    if lagtimes.ndim != 1:\n        raise TypeError(\n            'Lagtimes needs to be maximal 1d, but {0}'.format(lagtimes),\n        )\n\n    if not isinstance(tmax, int) or tmax &lt; 0:\n        raise TypeError('tmax needs to be a positive integer')\n\n    ckeqs = {}\n    for lagtime in lagtimes:\n        ckeqs[lagtime] = _chapman_kolmogorov_test(trajs, lagtime, tmax)\n    ckeqs['md'] = _chapman_kolmogorov_test_md(\n        trajs, tmin=lagtimes[0], tmax=tmax,\n    )\n\n    return ckeqs\n</code></pre>"},{"location":"reference/msm/timescales/","title":"timescales","text":""},{"location":"reference/msm/timescales/#msmhelper.msm.timescales--set-of-functions-for-analyzing-the-md-trajectory","title":"Set of functions for analyzing the MD trajectory.","text":"<p>This submodule contains methods for estimating various timescales based on a Markov model.</p>"},{"location":"reference/msm/timescales/#msmhelper.msm.timescales.implied_timescales","title":"<code>implied_timescales(trajs, lagtimes, ntimescales=None, reversible=False)</code>","text":"<p>Calculate the implied timescales.</p> <p>Calculate the implied timescales, which are defined by</p> \\[t_i = - \\frac{t_\\text{lag}}{\\log\\lambda_i}\\] <p>the \\(i\\)-th eigenvalue \\(\\lambda_i\\).</p> <p>Note</p> <p>It is not checked if for higher lagtimes the dimensionality changes.</p> <p>Parameters:</p> <ul> <li> <code>trajs</code>               (<code>StateTraj or list or ndarray or list of ndarray</code>)           \u2013            <p>State trajectory/trajectories. The states should start from zero and need to be integers.</p> </li> <li> <code>lagtimes</code>               (<code>list or ndarray int</code>)           \u2013            <p>Lagtimes for estimating the markov model given in [frames]. This is not implemented yet!</p> </li> <li> <code>ntimescales</code>               (<code>int</code>, default:                   <code>None</code> )           \u2013            <p>Number of returned lagtimes.</p> </li> <li> <code>reversible</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If reversibility should be enforced for the markov state model.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ts</code> (              <code>ndarray</code> )          \u2013            <p>Matrix containing the implied Timescales.</p> </li> </ul> Source code in <code>src/msmhelper/msm/timescales.py</code> <pre><code>def implied_timescales(trajs, lagtimes, ntimescales=None, reversible=False):\n    r\"\"\"Calculate the implied timescales.\n\n    Calculate the implied timescales, which are defined by\n\n    $$t_i = - \\frac{t_\\text{lag}}{\\log\\lambda_i}$$\n\n    the $i$-th eigenvalue $\\lambda_i$.\n\n    !!! note\n        It is not checked if for higher lagtimes the dimensionality changes.\n\n    Parameters\n    ----------\n    trajs : StateTraj or list or ndarray or list of ndarray\n        State trajectory/trajectories. The states should start from zero and\n        need to be integers.\n    lagtimes : list or ndarray int\n        Lagtimes for estimating the markov model given in [frames].\n        This is not implemented yet!\n    ntimescales : int, optional\n        Number of returned lagtimes.\n    reversible : bool\n        If reversibility should be enforced for the markov state model.\n\n    Returns\n    -------\n    ts : ndarray\n        Matrix containing the implied Timescales.\n\n    \"\"\"\n    # format input\n    trajs = StateTraj(trajs)\n    lagtimes = np.atleast_1d(lagtimes)\n\n    # check that lag times are array of integers\n    if not np.issubdtype(lagtimes.dtype, np.integer):\n        raise TypeError(\n            'Lagtimes needs to be integers but are {0}'.format(lagtimes.dtype),\n        )\n    if not (lagtimes &gt; 0).all():\n        raise TypeError('Lagtimes needs to be positive integers')\n    if reversible:\n        raise NotImplementedError(\n            'Reversible matrices are not anymore supported.'\n        )\n\n    if ntimescales is None:\n        ntimescales = trajs.nstates - 1\n\n    # initialize result\n    impl_timescales = np.zeros((len(lagtimes), ntimescales))\n\n    for idx, lagtime in enumerate(lagtimes):\n        transmat, _ = trajs.estimate_markov_model(lagtime)\n        impl_timescales[idx] = _implied_timescales(\n            transmat, lagtime, ntimescales=ntimescales,\n        )\n\n    return impl_timescales\n</code></pre>"},{"location":"reference/msm/timescales/#msmhelper.msm.timescales.estimate_waiting_times","title":"<code>estimate_waiting_times(*, trajs, lagtime, start, final, steps, return_list=False)</code>","text":"<p>Estimates waiting times between stated states.</p> <p>The stated states (from/to) will be treated as a basin. The function calculates all transitions from first entering the start-basin until first reaching the final-basin.</p> <p>Parameters:</p> <ul> <li> <code>trajs</code>               (<code>statetraj or list or ndarray or list of ndarray</code>)           \u2013            <p>State trajectory/trajectories. The states should start from zero and need to be integers.</p> </li> <li> <code>lagtime</code>               (<code>int</code>)           \u2013            <p>Lag time for estimating the markov model given in [frames].</p> </li> <li> <code>start</code>               (<code>int or list of</code>)           \u2013            <p>States to start counting.</p> </li> <li> <code>final</code>               (<code>int or list of</code>)           \u2013            <p>States to start counting.</p> </li> <li> <code>steps</code>               (<code>int</code>)           \u2013            <p>Number of MCMC propagation steps of MCMC run.</p> </li> <li> <code>return_list</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If true a list of all events is returned, else the probability density together with the edges is returned.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ts</code> (              <code>ndarray</code> )          \u2013            <p>Density probability of the time distribution. If <code>return_list=True</code>, return a sorted (!) list containing all times.</p> </li> <li> <code>edges</code> (              <code>ndarray</code> )          \u2013            <p>Array containing the edges corresponding to the probability, given in frames. Only for <code>return_list=False</code>.</p> </li> </ul> Source code in <code>src/msmhelper/msm/timescales.py</code> <pre><code>@decorit.alias('estimate_wt')\ndef estimate_waiting_times(\n    *,\n    trajs,\n    lagtime,\n    start,\n    final,\n    steps,\n    return_list=False,\n):\n    \"\"\"Estimates waiting times between stated states.\n\n    The stated states (from/to) will be treated as a basin. The function\n    calculates all transitions from first entering the start-basin until first\n    reaching the final-basin.\n\n    Parameters\n    ----------\n    trajs : statetraj or list or ndarray or list of ndarray\n        State trajectory/trajectories. The states should start from zero and\n        need to be integers.\n    lagtime : int\n        Lag time for estimating the markov model given in [frames].\n    start : int or list of\n        States to start counting.\n    final : int or list of\n        States to start counting.\n    steps : int\n        Number of MCMC propagation steps of MCMC run.\n    return_list : bool\n        If true a list of all events is returned, else the probability density\n        together with the edges is returned.\n\n    Returns\n    -------\n    ts : ndarray\n        Density probability of the time distribution. If `return_list=True`,\n        return a sorted (!) list containing all times.\n    edges : ndarray\n        Array containing the edges corresponding to the probability, given in\n        frames. Only for `return_list=False`.\n\n    \"\"\"\n    return _estimate_times(\n        trajs=trajs,\n        lagtime=lagtime,\n        start=start,\n        final=final,\n        steps=steps,\n        estimator=_estimate_waiting_times,\n        return_list=return_list,\n    )\n</code></pre>"},{"location":"reference/msm/timescales/#msmhelper.msm.timescales.estimate_transition_times","title":"<code>estimate_transition_times(*, trajs, lagtime, start, final, steps, return_list=False)</code>","text":"<p>Estimates transition times between stated states.</p> <p>The stated states (from/to) will be treated as a basin. The function calculates all transitions from leaving the start-basin until first reaching the final-basin.</p> <p>Parameters:</p> <ul> <li> <code>trajs</code>               (<code>statetraj or list or ndarray or list of ndarray</code>)           \u2013            <p>State trajectory/trajectories. The states should start from zero and need to be integers.</p> </li> <li> <code>lagtime</code>               (<code>int</code>)           \u2013            <p>Lag time for estimating the markov model given in [frames].</p> </li> <li> <code>start</code>               (<code>int or list of</code>)           \u2013            <p>States to start counting.</p> </li> <li> <code>final</code>               (<code>int or list of</code>)           \u2013            <p>States to start counting.</p> </li> <li> <code>steps</code>               (<code>int</code>)           \u2013            <p>Number of MCMC propagation steps of MCMC run.</p> </li> <li> <code>return_list</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If true a list of all events is returned, else the probability density together with the edges is returned.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ts</code> (              <code>ndarray</code> )          \u2013            <p>Density probability of the time distribution. If <code>return_list=True</code>, return a sorted (!) list containing all times.</p> </li> <li> <code>edges</code> (              <code>ndarray</code> )          \u2013            <p>Array containing the edges corresponding to the probability, given in frames. Only for <code>return_list=False</code>.</p> </li> </ul> Source code in <code>src/msmhelper/msm/timescales.py</code> <pre><code>@decorit.alias('estimate_tt')\ndef estimate_transition_times(\n    *,\n    trajs,\n    lagtime,\n    start,\n    final,\n    steps,\n    return_list=False,\n):\n    \"\"\"Estimates transition times between stated states.\n\n    The stated states (from/to) will be treated as a basin. The function\n    calculates all transitions from leaving the start-basin until first\n    reaching the final-basin.\n\n    Parameters\n    ----------\n    trajs : statetraj or list or ndarray or list of ndarray\n        State trajectory/trajectories. The states should start from zero and\n        need to be integers.\n    lagtime : int\n        Lag time for estimating the markov model given in [frames].\n    start : int or list of\n        States to start counting.\n    final : int or list of\n        States to start counting.\n    steps : int\n        Number of MCMC propagation steps of MCMC run.\n    return_list : bool\n        If true a list of all events is returned, else the probability density\n        together with the edges is returned.\n\n    Returns\n    -------\n    ts : ndarray\n        Density probability of the time distribution. If `return_list=True`,\n        return a sorted (!) list containing all times.\n    edges : ndarray\n        Array containing the edges corresponding to the probability, given in\n        frames. Only for `return_list=False`.\n\n    \"\"\"\n    return _estimate_times(\n        trajs=trajs,\n        lagtime=lagtime,\n        start=start,\n        final=final,\n        steps=steps,\n        estimator=_estimate_transition_times,\n        return_list=return_list,\n    )\n</code></pre>"},{"location":"reference/msm/timescales/#msmhelper.msm.timescales.estimate_paths","title":"<code>estimate_paths(*, trajs, lagtime, start, final, steps)</code>","text":"<p>Estimates paths and waiting times between stated states.</p> <p>The stated states (from/to) will be treated as a basin. The function estimates transitions from first entering the start-basin until first reaching the final-basin. The results will be listed by the corresponding pathways, where loops are removed occuring first.</p> <p>Note</p> <p>This function is a simple wrapper and in contrast to estimate_wt it stores the whole MCMC trajectory in memory. Hence, it memory-hungry.</p> <p>Parameters:</p> <ul> <li> <code>trajs</code>               (<code>statetraj or list or ndarray or list of ndarray</code>)           \u2013            <p>State trajectory/trajectories. The states should start from zero and need to be integers.</p> </li> <li> <code>lagtime</code>               (<code>int</code>)           \u2013            <p>Lag time for estimating the markov model given in [frames].</p> </li> <li> <code>start</code>               (<code>int or list of</code>)           \u2013            <p>States to start counting.</p> </li> <li> <code>final</code>               (<code>int or list of</code>)           \u2013            <p>States to start counting.</p> </li> <li> <code>steps</code>               (<code>int</code>)           \u2013            <p>Number of MCMC propagation steps of MCMC run.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>paths</code> (              <code>dict</code> )          \u2013            <p>Dictionary containing the the paths as keys and and an array holding the times of all paths as value.</p> </li> </ul> Source code in <code>src/msmhelper/msm/timescales.py</code> <pre><code>def estimate_paths(\n    *,\n    trajs,\n    lagtime,\n    start,\n    final,\n    steps,\n):\n    \"\"\"Estimates paths and waiting times between stated states.\n\n    The stated states (from/to) will be treated as a basin. The function\n    estimates transitions from first entering the start-basin until first\n    reaching the final-basin. The results will be listed by the corresponding\n    pathways, where loops are removed occuring first.\n\n    !!! note\n        This function is a simple wrapper and in contrast to\n        [estimate_wt][msmhelper.msm.estimate_waiting_times] it stores the whole\n        MCMC trajectory in memory. Hence, it memory-hungry.\n\n    Parameters\n    ----------\n    trajs : statetraj or list or ndarray or list of ndarray\n        State trajectory/trajectories. The states should start from zero and\n        need to be integers.\n    lagtime : int\n        Lag time for estimating the markov model given in [frames].\n    start : int or list of\n        States to start counting.\n    final : int or list of\n        States to start counting.\n    steps : int\n        Number of MCMC propagation steps of MCMC run.\n\n    Returns\n    -------\n    paths : dict\n        Dictionary containing the the paths as keys and and an array holding\n        the times of all paths as value.\n\n    \"\"\"\n    # check correct input format\n    trajs = StateTraj(trajs)\n\n    states_start, states_final = np.unique(start), np.unique(final)\n\n    if intersect(states_start, states_final):\n        raise ValueError('States `start` and `final` do overlap.')\n\n    # check that all states exist in trajectory\n    for states in (states_start, states_final):\n        if intersect(states, trajs.states) != len(states):\n            raise ValueError(\n                'Selected states does not exist in state trajectory.',\n            )\n\n    return md_estimate_paths(\n        propagate_MCMC(trajs, lagtime, steps),\n        start,\n        final,\n    )\n</code></pre>"},{"location":"reference/msm/timescales/#msmhelper.msm.timescales.propagate_MCMC","title":"<code>propagate_MCMC(trajs, lagtime, steps, start=-1)</code>","text":"<p>Propagate Monte Carlo Markov chain.</p> <p>Parameters:</p> <ul> <li> <code>trajs</code>               (<code>statetraj or list or ndarray or list of ndarray</code>)           \u2013            <p>State trajectory/trajectories. The states should start from zero and need to be integers.</p> </li> <li> <code>lagtime</code>               (<code>int</code>)           \u2013            <p>Lag time for estimating the markov model given in [frames].</p> </li> <li> <code>steps</code>               (<code>int</code>)           \u2013            <p>Number of MCMC propagation steps.</p> </li> <li> <code>start</code>               (<code>int or list of</code>, default:                   <code>-1</code> )           \u2013            <p>State to start propagating. Default (-1) is random state.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>mcmc</code> (              <code>ndarray</code> )          \u2013            <p>Monte Carlo Markov chain state trajectory.</p> </li> </ul> Source code in <code>src/msmhelper/msm/timescales.py</code> <pre><code>def propagate_MCMC(\n    trajs,\n    lagtime,\n    steps,\n    start=-1,\n):\n    \"\"\"Propagate Monte Carlo Markov chain.\n\n    Parameters\n    ----------\n    trajs : statetraj or list or ndarray or list of ndarray\n        State trajectory/trajectories. The states should start from zero and\n        need to be integers.\n    lagtime : int\n        Lag time for estimating the markov model given in [frames].\n    steps : int\n        Number of MCMC propagation steps.\n    start : int or list of, optional\n        State to start propagating. Default (-1) is random state.\n\n    Returns\n    -------\n    mcmc : ndarray\n        Monte Carlo Markov chain state trajectory.\n\n    \"\"\"\n    # check correct input format\n    trajs = StateTraj(trajs)\n\n    # check that all states exist in trajectory\n    if start == -1:\n        start = np.random.choice(trajs.states)\n    elif start not in trajs.states:\n        raise ValueError(\n            'Selected starting state does not exist in state trajectory.',\n        )\n\n    # convert states to idx\n    idx_start = trajs.state_to_idx(start)\n\n    # estimate permuted cumulative transition matrix\n    cummat = _get_cummat(trajs=trajs, lagtime=lagtime)\n\n    # do not convert for pytest coverage\n    return shift_data(\n        _propagate_MCMC(  # pragma: no cover\n            cummat=cummat,\n            start=idx_start,\n            steps=steps,\n        ),\n        np.arange(trajs.nstates),\n        trajs.states,\n    )\n</code></pre>"},{"location":"reference/msm/timescales/#msmhelper.msm.timescales.estimate_waiting_time_dist","title":"<code>estimate_waiting_time_dist(trajs, max_lagtime, start, final, steps, n_lagtimes=50)</code>","text":"<p>Estimate waiting time distribution.</p> <p>Parameters:</p> <ul> <li> <code>trajs</code>               (<code>statetraj or list or ndarray or list of ndarray</code>)           \u2013            <p>State trajectory/trajectories. The states should start from zero and need to be integers.</p> </li> <li> <code>max_lagtime</code>               (<code>int</code>)           \u2013            <p>Maximal lag time for estimating the markov model given in [frames].</p> </li> <li> <code>start</code>               (<code>int or list of</code>)           \u2013            <p>States to start counting.</p> </li> <li> <code>final</code>               (<code>int or list of</code>)           \u2013            <p>States to start counting.</p> </li> <li> <code>steps</code>               (<code>int</code>)           \u2013            <p>Number of MCMC propagation steps of MCMC run.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>wtd</code> (              <code>dict</code> )          \u2013            <p>Dictionary containing waiting time distribution.</p> </li> </ul> Source code in <code>src/msmhelper/msm/timescales.py</code> <pre><code>@decorit.alias('estimate_wtd')\ndef estimate_waiting_time_dist(\n    trajs,\n    max_lagtime,\n    start,\n    final,\n    steps,\n    n_lagtimes=50,\n):\n    \"\"\"Estimate waiting time distribution.\n\n    Parameters\n    ----------\n    trajs : statetraj or list or ndarray or list of ndarray\n        State trajectory/trajectories. The states should start from zero and\n        need to be integers.\n    max_lagtime : int\n        Maximal lag time for estimating the markov model given in [frames].\n    start : int or list of\n        States to start counting.\n    final : int or list of\n        States to start counting.\n    steps : int\n        Number of MCMC propagation steps of MCMC run.\n\n    Returns\n    -------\n    wtd : dict\n        Dictionary containing waiting time distribution.\n\n    \"\"\"\n    lagtimes = np.unique(\n        np.linspace(1, max_lagtime, num=n_lagtimes, dtype=int),\n    )\n\n    # get stats\n    wtd = {\n        lagtime: boxplot_stats(\n            estimate_waiting_times(\n                trajs=trajs,\n                lagtime=lagtime,\n                start=start,\n                final=final,\n                steps=steps,\n                return_list=True,\n            ),\n        )[0]\n        for lagtime in lagtimes\n    }\n\n    # include MD\n    wtd['MD'] = boxplot_stats(\n        md_estimate_wt(\n            trajs=trajs,\n            start=start,\n            final=final,\n        ),\n    )\n    return wtd\n</code></pre>"},{"location":"reference/msm/utils/","title":"utils","text":"<p>Utils Methods for MSM</p>"},{"location":"reference/msm/utils/linalg/","title":"linalg","text":"<p>Basic linear algebra method.</p> <p>BSD 3-Clause License Copyright \u00a9 2019-2020, Daniel Nagel All rights reserved.</p>"},{"location":"reference/msm/utils/linalg/#msmhelper.msm.utils.linalg.left_eigenvectors","title":"<code>left_eigenvectors(matrix, nvals=None)</code>","text":"<p>Estimate left eigenvectors.</p> <p>Estimates the left eigenvectors and corresponding eigenvalues of a quadratic matrix.</p> <p>Parameters:</p> <ul> <li> <code>matrix</code>               (<code>ndarray</code>)           \u2013            <p>Quadratic 2d matrix eigenvectors and eigenvalues or determined of.</p> </li> <li> <code>nvals</code>               (<code>int</code>, default:                   <code>None</code> )           \u2013            <p>Number of returned eigenvalues and -vectors. Using ensures probability of real valued matrices.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>eigenvalues</code> (              <code>ndarray</code> )          \u2013            <p>N eigenvalues sorted by their value (descending).</p> </li> <li> <code>eigenvectors</code> (              <code>ndarray</code> )          \u2013            <p>N eigenvectors sorted by descending eigenvalues.</p> </li> </ul> Source code in <code>src/msmhelper/msm/utils/linalg.py</code> <pre><code>@decorit.alias('eigl')\ndef left_eigenvectors(matrix, nvals=None):\n    \"\"\"Estimate left eigenvectors.\n\n    Estimates the left eigenvectors and corresponding eigenvalues of a\n    quadratic matrix.\n\n    Parameters\n    ----------\n    matrix : ndarray\n        Quadratic 2d matrix eigenvectors and eigenvalues or determined of.\n    nvals : int, optional\n        Number of returned eigenvalues and -vectors. Using ensures probability\n        of real valued matrices.\n\n    Returns\n    -------\n    eigenvalues : ndarray\n        N eigenvalues sorted by their value (descending).\n    eigenvectors : ndarray\n        N eigenvectors sorted by descending eigenvalues.\n\n    \"\"\"\n    matrix = np.asarray(matrix)\n    return _eigenvectors(matrix.transpose(), nvals)\n</code></pre>"},{"location":"reference/msm/utils/linalg/#msmhelper.msm.utils.linalg.right_eigenvectors","title":"<code>right_eigenvectors(matrix, nvals=None)</code>","text":"<p>Estimate right eigenvectors.</p> <p>Estimates the right eigenvectors and corresponding eigenvalues of a quadratic matrix.</p> <p>Parameters:</p> <ul> <li> <code>matrix</code>               (<code>ndarray</code>)           \u2013            <p>Quadratic 2d matrix eigenvectors and eigenvalues or determined of.</p> </li> <li> <code>nvals</code>               (<code>int</code>, default:                   <code>None</code> )           \u2013            <p>Number of returned eigenvalues and -vectors. Using ensures probability of real valued matrices.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>eigenvalues</code> (              <code>ndarray</code> )          \u2013            <p>N eigenvalues sorted by their value (descending).</p> </li> <li> <code>eigenvectors</code> (              <code>ndarray</code> )          \u2013            <p>N eigenvectors sorted by descending eigenvalues.</p> </li> </ul> Source code in <code>src/msmhelper/msm/utils/linalg.py</code> <pre><code>@decorit.alias('eig')\ndef right_eigenvectors(matrix, nvals=None):\n    \"\"\"Estimate right eigenvectors.\n\n    Estimates the right eigenvectors and corresponding eigenvalues of a\n    quadratic matrix.\n\n    Parameters\n    ----------\n    matrix : ndarray\n        Quadratic 2d matrix eigenvectors and eigenvalues or determined of.\n    nvals : int, optional\n        Number of returned eigenvalues and -vectors. Using ensures probability\n        of real valued matrices.\n\n    Returns\n    -------\n    eigenvalues : ndarray\n        N eigenvalues sorted by their value (descending).\n    eigenvectors : ndarray\n        N eigenvectors sorted by descending eigenvalues.\n\n    \"\"\"\n    matrix = np.asarray(matrix)\n    return _eigenvectors(matrix, nvals)\n</code></pre>"},{"location":"reference/msm/utils/linalg/#msmhelper.msm.utils.linalg.left_eigenvalues","title":"<code>left_eigenvalues(matrix, nvals=None)</code>","text":"<p>Estimate left eigenvalues.</p> <p>Estimates the left eigenvalues of a quadratic matrix.</p> <p>Parameters:</p> <ul> <li> <code>matrix</code>               (<code>ndarray</code>)           \u2013            <p>Quadratic 2d matrix eigenvalues or determined of.</p> </li> <li> <code>nvals</code>               (<code>int</code>, default:                   <code>None</code> )           \u2013            <p>Number of returned eigenvalues and -vectors. Using ensures probability of real valued matrices.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>eigenvalues</code> (              <code>ndarray</code> )          \u2013            <p>N eigenvalues sorted by their value (descending).</p> </li> </ul> Source code in <code>src/msmhelper/msm/utils/linalg.py</code> <pre><code>@decorit.alias('eiglvals')\ndef left_eigenvalues(matrix, nvals=None):\n    \"\"\"Estimate left eigenvalues.\n\n    Estimates the left eigenvalues of a quadratic matrix.\n\n    Parameters\n    ----------\n    matrix : ndarray\n        Quadratic 2d matrix eigenvalues or determined of.\n    nvals : int, optional\n        Number of returned eigenvalues and -vectors. Using ensures probability\n        of real valued matrices.\n\n    Returns\n    -------\n    eigenvalues : ndarray\n        N eigenvalues sorted by their value (descending).\n\n    \"\"\"\n    matrix = np.asarray(matrix)\n    return _eigenvalues(np.transpose(matrix), nvals)\n</code></pre>"},{"location":"reference/msm/utils/linalg/#msmhelper.msm.utils.linalg.right_eigenvalues","title":"<code>right_eigenvalues(matrix, nvals=None)</code>","text":"<p>Estimate right eigenvalues.</p> <p>Estimates the right eigenvalues of a quadratic matrix.</p> <p>Parameters:</p> <ul> <li> <code>matrix</code>               (<code>ndarray</code>)           \u2013            <p>Quadratic 2d matrix eigenvalues or determined of.</p> </li> <li> <code>nvals</code>               (<code>int</code>, default:                   <code>None</code> )           \u2013            <p>Number of returned eigenvalues and -vectors. Using ensures probability of real valued matrices.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>eigenvalues</code> (              <code>ndarray</code> )          \u2013            <p>N eigenvalues sorted by their value (descending).</p> </li> </ul> Source code in <code>src/msmhelper/msm/utils/linalg.py</code> <pre><code>@decorit.alias('eigvals')\ndef right_eigenvalues(matrix, nvals=None):\n    \"\"\"Estimate right eigenvalues.\n\n    Estimates the right eigenvalues of a quadratic matrix.\n\n    Parameters\n    ----------\n    matrix : ndarray\n        Quadratic 2d matrix eigenvalues or determined of.\n    nvals : int, optional\n        Number of returned eigenvalues and -vectors. Using ensures probability\n        of real valued matrices.\n\n    Returns\n    -------\n    eigenvalues : ndarray\n        N eigenvalues sorted by their value (descending).\n\n    \"\"\"\n    matrix = np.asarray(matrix)\n    return _eigenvalues(matrix, nvals)\n</code></pre>"},{"location":"reference/plot/","title":"plot","text":""},{"location":"reference/plot/#msmhelper.plot--matplotlib-based-plotting-routines","title":"Matplotlib-Based Plotting Routines","text":"<p>This submodule contains methods related to visualize some of the standard Markov state plots.</p>"},{"location":"reference/plot/#msmhelper.plot.plot_ck_test","title":"<code>plot_ck_test(ck, states=None, frames_per_unit=1, unit='frames', grid=(3, 3))</code>","text":"<p>Plot CK-Test results.</p> <p>This routine is a basic helper function to visualize the results of msmhelper.msm.chapman_kolmogorov_test.</p> <p>Parameters:</p> <ul> <li> <code>ck</code>               (<code>dict</code>)           \u2013            <p>Dictionary holding for each lagtime the CK equation and with 'md' the reference.</p> </li> <li> <code>states</code>               (<code>ndarray</code>, default:                   <code>None</code> )           \u2013            <p>List containing all states to plot the CK-test.</p> </li> <li> <code>frames_per_unit</code>               (<code>float</code>, default:                   <code>1</code> )           \u2013            <p>Number of frames per given unit. This is used to scale the axis accordingly.</p> </li> <li> <code>unit</code>               (<code>[frames, fs, ps, ns, us]</code>, default:                   <code>'frames'</code> )           \u2013            <p>Unit to use for label.</p> </li> <li> <code>grid</code>               (<code>(int, int)</code>, default:                   <code>(3, 3)</code> )           \u2013            <p>The number of <code>(n_rows, n_cols)</code> to use for the grid layout.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>fig</code> (              <code>Figure</code> )          \u2013            <p>Figure holding plots.</p> </li> </ul> Source code in <code>src/msmhelper/plot/_ck_test.py</code> <pre><code>def plot_ck_test(\n    ck,\n    states=None,\n    frames_per_unit=1,\n    unit='frames',\n    grid=(3, 3),\n):\n    \"\"\"Plot CK-Test results.\n\n    This routine is a basic helper function to visualize the results of\n    [msmhelper.msm.chapman_kolmogorov_test][].\n\n    Parameters\n    ----------\n    ck : dict\n        Dictionary holding for each lagtime the CK equation and with 'md' the\n        reference.\n    states : ndarray, optional\n        List containing all states to plot the CK-test.\n    frames_per_unit : float, optional\n        Number of frames per given unit. This is used to scale the axis\n        accordingly.\n    unit : ['frames', 'fs', 'ps', 'ns', 'us'], optional\n        Unit to use for label.\n    grid : (int, int), optional\n        The number of `(n_rows, n_cols)` to use for the grid layout.\n\n    Returns\n    -------\n    fig : matplotlib.Figure\n        Figure holding plots.\n\n    \"\"\"\n    # load colors\n    pplt.load_cmaps()\n    pplt.load_colors()\n\n    lagtimes = np.array([key for key in ck.keys() if key != 'md'])\n    if states is None:\n        states = np.array(\n            list(ck['md']['ck'].keys())\n        )\n\n    nrows, ncols = grid\n    needed_rows = int(np.ceil(len(states) / ncols))\n\n    fig, axs = plt.subplots(\n        needed_rows,\n        ncols,\n        sharex=True,\n        sharey='row',\n        gridspec_kw={'wspace': 0, 'hspace': 0},\n    )\n    axs = np.atleast_2d(axs)\n\n    max_time = np.max(ck['md']['time'])\n    for irow, states_row in enumerate(_split_array(states, ncols)):\n        for icol, state in enumerate(states_row):\n            ax = axs[irow, icol]\n\n            pplt.plot(\n                ck['md']['time'] / frames_per_unit,\n                ck['md']['ck'][state],\n                '--',\n                ax=ax,\n                color='pplt:gray',\n                label='MD',\n            )\n            for lagtime in lagtimes:\n                pplt.plot(\n                    ck[lagtime]['time'] / frames_per_unit,\n                    ck[lagtime]['ck'][state],\n                    ax=ax,\n                    label=lagtime / frames_per_unit,\n                )\n            pplt.text(\n                0.5,\n                0.9,\n                'S{0}'.format(state),\n                contour=True,\n                va='top',\n                transform=ax.transAxes,\n                ax=ax,\n            )\n\n            # set scale\n            ax.set_xscale('log')\n            ax.set_xlim([\n                lagtimes[0] / frames_per_unit,\n                max_time / frames_per_unit,\n            ])\n            ax.set_ylim([0, 1])\n            if irow &lt; len(axs) - 1:\n                ax.set_yticks([0.5, 1])\n            else:\n                ax.set_yticks([0, 0.5, 1])\n\n            ax.grid(True, which='major', linestyle='--')\n            ax.grid(True, which='minor', linestyle='dotted')\n            ax.set_axisbelow(True)\n\n    # set legend\n    legend_kw = {\n        'outside': 'right',\n        'bbox_to_anchor': (2.0, (1 - nrows), 0.2, nrows),\n    } if ncols in {1, 2} else {\n        'outside': 'top',\n        'bbox_to_anchor': (0.0, 1.0, ncols, 0.01),\n    }\n    if ncols == 3:\n        legend_kw['ncol'] = 3\n    pplt.legend(\n        ax=axs[0, 0],\n        **legend_kw,\n        title=fr'$\\tau_\\mathrm{{lag}}$ [{unit}]',\n        frameon=False,\n    )\n\n    ylabel = (\n        r'self-transition probability $P_{i\\to i}$'\n    ) if nrows &gt;= 3 else (\n        r'$P_{i\\to i}$'\n    )\n\n    pplt.hide_empty_axes()\n    pplt.label_outer()\n    pplt.subplot_labels(\n        ylabel=ylabel,\n        xlabel=r'time $t$ [{unit}]'.format(unit=unit),\n    )\n    return fig\n</code></pre>"},{"location":"reference/plot/#msmhelper.plot.plot_wtd","title":"<code>plot_wtd(wtd, frames_per_unit=1, unit='frames', ax=None, show_md=True, show_fliers=False)</code>","text":"<p>Plot waiting time distribution.</p> <p>This is a wrapper function to plot the return value of msmhelper.msm.estimate_waiting_time_dist.</p> <p>Parameters:</p> <ul> <li> <code>wtd</code>               (<code>dict</code>)           \u2013            <p>Dictionary returned from <code>msmhelper.msm.estimate_wtd</code>, holding stats of waiting time distributions.</p> </li> <li> <code>frames_per_unit</code>               (<code>float</code>, default:                   <code>1</code> )           \u2013            <p>Number of frames per given unit. This is used to scale the axis accordingly.</p> </li> <li> <code>unit</code>               (<code>[frames, fs, ps, ns, us]</code>, default:                   <code>'frames'</code> )           \u2013            <p>Unit to use for label.</p> </li> <li> <code>ax</code>               (<code>Axes</code>, default:                   <code>None</code> )           \u2013            <p>Axes to plot figure in. With <code>None</code> the current axes is used.</p> </li> <li> <code>show_md</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Include boxplot of MD data.</p> </li> <li> <code>show_fliers</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Show fliers (outliers) in MD and MSM prediction.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ax</code> (              <code>Axes</code> )          \u2013            <p>Return axes holding the plot.</p> </li> </ul> Source code in <code>src/msmhelper/plot/_wtd.py</code> <pre><code>def plot_wtd(\n    wtd,\n    frames_per_unit=1,\n    unit='frames',\n    ax=None,\n    show_md=True,\n    show_fliers=False,\n):\n    \"\"\"Plot waiting time distribution.\n\n    This is a wrapper function to plot the return value of\n    [msmhelper.msm.estimate_waiting_time_dist][].\n\n    Parameters\n    ----------\n    wtd : dict\n        Dictionary returned from `msmhelper.msm.estimate_wtd`, holding stats of\n        waiting time distributions.\n    frames_per_unit : float, optional\n        Number of frames per given unit. This is used to scale the axis\n        accordingly.\n    unit : ['frames', 'fs', 'ps', 'ns', 'us'], optional\n        Unit to use for label.\n    ax : matplotlib.Axes, optional\n        Axes to plot figure in. With `None` the current axes is used.\n    show_md : bool, optional\n        Include boxplot of MD data.\n    show_fliers : bool, optional\n        Show fliers (outliers) in MD and MSM prediction.\n\n    Returns\n    -------\n    ax : matplotlib.Axes\n        Return axes holding the plot.\n\n    \"\"\"\n    if ax is None:\n        ax = plt.gca()\n\n    lagtimes = np.array(\n        [time for time in wtd.keys() if time != 'MD'], dtype=int,\n    )\n    max_lagtime = lagtimes.max()\n\n    # convert stats to array\n    LB, UB, Q1, Q2, Q3 = np.array([\n        np.array([\n            wtd[lagtime][key] for lagtime in lagtimes\n        ]) / frames_per_unit\n        for key in ['whislo', 'whishi', 'q1', 'med', 'q3']\n    ])\n    FL = np.array([\n        min(\n            np.min(wtd[lagtime]['fliers']),\n            wtd[lagtime]['whislo'],\n        ) for lagtime in lagtimes\n    ]) / frames_per_unit\n    FU = np.array([\n        max(\n            np.max(wtd[lagtime]['fliers']),\n            wtd[lagtime]['whishi'],\n        ) for lagtime in lagtimes\n    ]) / frames_per_unit\n\n    # plot results\n    colors = pplt.categorical_color(4, 'C0')\n    lagtimes = lagtimes / frames_per_unit\n    if show_fliers:\n        ax.fill_between(\n            lagtimes, FL, FU, color=colors[3], label=r'fliers',\n        )\n    ax.fill_between(\n        lagtimes,\n        LB,\n        UB,\n        color=colors[2],\n        label=r'$Q_{1/3}\\pm1.5\\mathrm{IQR}$',\n    )\n    ax.fill_between(lagtimes, Q1, Q3, color=colors[1], label='IQR')\n    ax.plot(lagtimes, Q2, color=colors[0], label='$Q_2$')\n\n    max_lagtime_unit = max_lagtime / frames_per_unit\n    if show_md:\n        bxp = ax.bxp(\n            [{\n                key: time / frames_per_unit\n                for key, time in wtd['MD'][0].items()\n            }],\n            positions=[max_lagtime_unit * 1.125],\n            widths=max_lagtime_unit * 0.075,\n            showfliers=show_fliers,\n        )\n        for median in bxp['medians']:\n            median.set_color('k')\n\n        ax.axvline(\n            max_lagtime_unit,\n            0,\n            1,\n            lw=plt.rcParams['axes.linewidth'],\n            color='pplt:axes',\n        )\n\n    if show_md:\n        ax.set_xlim([0, max_lagtime_unit * 1.25])\n        xticks = np.array([\n            *np.linspace(0, max_lagtime_unit, 4).astype(int),\n            max_lagtime_unit * 1.125,\n        ])\n        xticklabels = [\n            f'{xtick:.0f}' if idx + 1 &lt; len(xticks) else 'MD'\n            for idx, xtick in enumerate(xticks)\n        ]\n        ax.set_xticks(xticks)\n        ax.set_xticklabels(xticklabels)\n    else:\n        ax.set_xlim([0, max_lagtime_unit])\n\n    # use scientific notation for large values\n    ax.ticklabel_format(\n        axis='y', style='scientific', scilimits=[0, 2], useMathText=True,\n    )\n    ax.get_yaxis().get_offset_text().set_ha('right')\n\n    # set legend and labels\n    pplt.legend(ax=ax, outside='top', frameon=False)\n    ax.set_ylabel(f'time $t$ [{unit}]')\n    ax.set_xlabel(fr'$\\tau_\\mathrm{{lag}}$ [{unit}]')\n\n    return ax\n</code></pre>"},{"location":"reference/utils/","title":"utils","text":""},{"location":"reference/utils/#msmhelper.utils--utils","title":"Utils","text":"<p>This submodule provides utility functions that can be used to manipulate and test data, such as filtering and validation methods. The functions in this submodule can be used in conjunction with other parts of the software to perform a variety of tasks, making it an essential part of the package.</p> <p>The submodule is structured into the following submodules:</p> <ul> <li>datasets: This submodule contains all methods related to create example datasets. This submodule needs to be imported explicitly!</li> <li>filtering: This submodule contains all methods related to dynamical smoothening.</li> <li>tests: This submodule holds functions to tests for given properties, e.g., if a matrix is ergodic, quadratic, etc.</li> </ul>"},{"location":"reference/utils/#msmhelper.utils.find_first","title":"<code>find_first(search_val, array)</code>","text":"<p>Return first occurance of item in array.</p> Source code in <code>src/msmhelper/utils/_utils.py</code> <pre><code>@numba.njit\ndef find_first(search_val, array):\n    \"\"\"Return first occurance of item in array.\"\"\"\n    for idx, idx_val in enumerate(array):\n        if search_val == idx_val:\n            return idx\n    return -1\n</code></pre>"},{"location":"reference/utils/#msmhelper.utils.format_state_traj","title":"<code>format_state_traj(trajs)</code>","text":"<p>Convert state trajectory to list of ndarrays.</p> <p>Parameters:</p> <ul> <li> <code>trajs</code>               (<code>list or ndarray or list of ndarray</code>)           \u2013            <p>State trajectory/trajectories. The states should start from zero and need to be integers.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>trajs</code> (              <code>list of ndarray</code> )          \u2013            <p>Return list of ndarrays of integers.</p> </li> </ul> Source code in <code>src/msmhelper/utils/_utils.py</code> <pre><code>def format_state_traj(trajs):\n    \"\"\"Convert state trajectory to list of ndarrays.\n\n    Parameters\n    ----------\n    trajs : list or ndarray or list of ndarray\n        State trajectory/trajectories. The states should start from zero and\n        need to be integers.\n\n    Returns\n    -------\n    trajs : list of ndarray\n        Return list of ndarrays of integers.\n\n    \"\"\"\n    # list or tuple\n    if isinstance(trajs, (tuple, list)):\n        # list of integers\n        if all((np.issubdtype(type(state), np.integer) for state in trajs)):\n            trajs = [np.array(trajs)]\n        # list of lists\n        elif all((isinstance(traj, list) for traj in trajs)):\n            trajs = [np.array(traj) for traj in trajs]\n    # ndarray\n    if isinstance(trajs, np.ndarray):\n        if len(trajs.shape) == 1:\n            trajs = [trajs]\n        elif len(trajs.shape) == 2:\n            trajs = list(trajs)\n\n    # check for integers\n    _check_state_traj(trajs)\n\n    return trajs\n</code></pre>"},{"location":"reference/utils/#msmhelper.utils.matrix_power","title":"<code>matrix_power(matrix, power)</code>","text":"<p>Calculate matrix power with np.linalg.matrix_power.</p> <p>Numba wrapper for numpy.linalg.matrix_power. Only for float matrices.</p> <p>Parameters:</p> <ul> <li> <code>matrix</code>               (<code>ndarray</code>)           \u2013            <p>2d matrix of type float.</p> </li> <li> <code>power</code>               (<code>(int, float)</code>)           \u2013            <p>Power of matrix.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>matpow</code> (              <code>ndarray</code> )          \u2013            <p>Matrix power.</p> </li> </ul> Source code in <code>src/msmhelper/utils/_utils.py</code> <pre><code>@numba.njit\ndef matrix_power(matrix, power):\n    \"\"\"Calculate matrix power with np.linalg.matrix_power.\n\n    Numba wrapper for [numpy.linalg.matrix_power][]. Only for float matrices.\n\n    Parameters\n    ----------\n    matrix : ndarray\n        2d matrix of type float.\n    power : int, float\n        Power of matrix.\n\n    Returns\n    -------\n    matpow : ndarray\n        Matrix power.\n\n    \"\"\"\n    return np.linalg.matrix_power(matrix, power)\n</code></pre>"},{"location":"reference/utils/#msmhelper.utils.rename_by_index","title":"<code>rename_by_index(trajs, return_permutation=False)</code>","text":"<p>Rename states sorted by their numerical values starting from 0.</p> <p>Parameters:</p> <ul> <li> <code>trajs</code>               (<code>list or ndarray or list of ndarrays</code>)           \u2013            <p>State trajectory or list of state trajectories.</p> </li> <li> <code>return_permutation</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Return additionaly the permutation to achieve performed renaming. Default is False.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>trajs</code> (              <code>ndarray</code> )          \u2013            <p>Renamed data.</p> </li> <li> <code>permutation</code> (              <code>ndarray</code> )          \u2013            <p>Permutation going from old to new state nameing. So the <code>i</code>th state of the new naming corresponds to the old state <code>permutation[i-1]</code>.</p> </li> </ul> Source code in <code>src/msmhelper/utils/_utils.py</code> <pre><code>def rename_by_index(trajs, return_permutation=False):\n    r\"\"\"Rename states sorted by their numerical values starting from 0.\n\n    Parameters\n    ----------\n    trajs : list or ndarray or list of ndarrays\n        State trajectory or list of state trajectories.\n    return_permutation : bool\n        Return additionaly the permutation to achieve performed renaming.\n        Default is False.\n\n    Returns\n    -------\n    trajs : ndarray\n        Renamed data.\n    permutation : ndarray\n        Permutation going from old to new state nameing. So the `i`th state\n        of the new naming corresponds to the old state `permutation[i-1]`.\n\n    \"\"\"\n    # get unique states\n    states = unique(trajs)\n\n    # rename states\n    trajs_renamed = shift_data(\n        trajs,\n        val_old=states,\n        val_new=np.arange(len(states)),\n    )\n    if return_permutation:\n        return trajs_renamed, states\n    return trajs_renamed\n</code></pre>"},{"location":"reference/utils/#msmhelper.utils.rename_by_population","title":"<code>rename_by_population(trajs, return_permutation=False)</code>","text":"<p>Rename states sorted by their population starting from 1.</p> <p>Parameters:</p> <ul> <li> <code>trajs</code>               (<code>list or ndarray or list of ndarrays</code>)           \u2013            <p>State trajectory or list of state trajectories.</p> </li> <li> <code>return_permutation</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Return additionaly the permutation to achieve performed renaming. Default is False.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>trajs</code> (              <code>ndarray</code> )          \u2013            <p>Renamed data.</p> </li> <li> <code>permutation</code> (              <code>ndarray</code> )          \u2013            <p>Permutation going from old to new state nameing. So the <code>i</code>th state of the new naming corresponds to the old state <code>permutation[i-1]</code>.</p> </li> </ul> Source code in <code>src/msmhelper/utils/_utils.py</code> <pre><code>def rename_by_population(trajs, return_permutation=False):\n    r\"\"\"Rename states sorted by their population starting from 1.\n\n    Parameters\n    ----------\n    trajs : list or ndarray or list of ndarrays\n        State trajectory or list of state trajectories.\n    return_permutation : bool\n        Return additionaly the permutation to achieve performed renaming.\n        Default is False.\n\n    Returns\n    -------\n    trajs : ndarray\n        Renamed data.\n    permutation : ndarray\n        Permutation going from old to new state nameing. So the `i`th state\n        of the new naming corresponds to the old state `permutation[i-1]`.\n\n    \"\"\"\n    # get unique states with population\n    states, pop = unique(trajs, return_counts=True)\n\n    # get decreasing order\n    idx_sort = np.argsort(pop)[::-1]\n    states = states[idx_sort]\n\n    # rename states\n    trajs_renamed = shift_data(\n        trajs,\n        val_old=states,\n        val_new=np.arange(len(states)) + 1,\n    )\n    if return_permutation:\n        return trajs_renamed, states\n    return trajs_renamed\n</code></pre>"},{"location":"reference/utils/#msmhelper.utils.runningmean","title":"<code>runningmean(array, window)</code>","text":"<p>Compute centered running average with given window size.</p> <p>This function returns the centered based running average of the given data. The output of this function is of the same length as the input, by assuming that the given data is zero before and after the given series. Hence, there are border affects which are not corrected.</p> <p>Warning</p> <p>If the given window is even (not symmetric) it will be shifted towards the beginning of the current value. So for <code>window=4</code>, it will consider the current position \\(i\\), the two to the left \\(i-2\\) and \\(i-1\\) and one to the right \\(i+1\\).</p> <p>Function is taken from lapis: https://stackoverflow.com/questions/13728392/moving-average-or-running-mean</p> <p>Parameters:</p> <ul> <li> <code>array</code>               (<code>ndarray</code>)           \u2013            <p>One dimensional numpy array.</p> </li> <li> <code>window</code>               (<code>int</code>)           \u2013            <p>Integer which specifies window-width.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>array_rmean</code> (              <code>ndarray</code> )          \u2013            <p>Data which is time-averaged over the specified window.</p> </li> </ul> Source code in <code>src/msmhelper/utils/_utils.py</code> <pre><code>def runningmean(array, window):\n    r\"\"\"Compute centered running average with given window size.\n\n    This function returns the centered based running average of the given\n    data. The output of this function is of the same length as the input,\n    by assuming that the given data is zero before and after the given\n    series. Hence, there are border affects which are not corrected.\n\n    !!! warning\n        If the given window is even (not symmetric) it will be shifted towards\n        the beginning of the current value. So for `window=4`, it will consider\n        the current position \\(i\\), the two to the left \\(i-2\\) and \\(i-1\\) and\n        one to the right \\(i+1\\).\n\n    Function is taken from lapis:\n    https://stackoverflow.com/questions/13728392/moving-average-or-running-mean\n\n    Parameters\n    ----------\n    array : ndarray\n        One dimensional numpy array.\n    window : int\n        Integer which specifies window-width.\n\n    Returns\n    -------\n    array_rmean : ndarray\n        Data which is time-averaged over the specified window.\n\n    \"\"\"\n    # Calculate running mean\n    return np.convolve(\n        array,\n        np.ones(window) / window,\n        mode='same',\n    )\n</code></pre>"},{"location":"reference/utils/#msmhelper.utils.shift_data","title":"<code>shift_data(array, val_old, val_new, dtype=np.int64)</code>","text":"<p>Shift integer array (data) from old to new values.</p> <p>Warning</p> <p>The values of <code>val_old</code>, <code>val_new</code> and <code>data</code> needs to be integers.</p> <p>The basic function is based on Ashwini_Chaudhary solution: https://stackoverflow.com/a/29408060</p> <p>Parameters:</p> <ul> <li> <code>array</code>               (<code>StateTraj or ndarray or list or list of ndarrays</code>)           \u2013            <p>1D data or a list of data.</p> </li> <li> <code>val_old</code>               (<code>ndarray or list</code>)           \u2013            <p>Values in data which should be replaced. All values needs to be within the range of <code>[data.min(), data.max()]</code></p> </li> <li> <code>val_new</code>               (<code>ndarray or list</code>)           \u2013            <p>Values which will be used instead of old ones.</p> </li> <li> <code>dtype</code>               (<code>data - type</code>, default:                   <code>int64</code> )           \u2013            <p>The desired data-type. Needs to be of type unsigned integer.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>array</code> (              <code>ndarray</code> )          \u2013            <p>Shifted data in same shape as input.</p> </li> </ul> Source code in <code>src/msmhelper/utils/_utils.py</code> <pre><code>def shift_data(array, val_old, val_new, dtype=np.int64):\n    \"\"\"Shift integer array (data) from old to new values.\n\n    !!! warning\n        The values of `val_old`, `val_new` and `data` needs to be integers.\n\n    The basic function is based on Ashwini_Chaudhary solution:\n    https://stackoverflow.com/a/29408060\n\n    Parameters\n    ----------\n    array : StateTraj or ndarray or list or list of ndarrays\n        1D data or a list of data.\n    val_old : ndarray or list\n        Values in data which should be replaced. All values needs to be within\n        the range of `[data.min(), data.max()]`\n    val_new : ndarray or list\n        Values which will be used instead of old ones.\n    dtype : data-type, optional\n        The desired data-type. Needs to be of type unsigned integer.\n\n    Returns\n    -------\n    array : ndarray\n        Shifted data in same shape as input.\n\n    \"\"\"\n    # check data-type\n    if not np.issubdtype(dtype, np.integer):\n        raise TypeError('An unsigned integer type is needed.')\n\n    # flatten data\n    array, shape_kwargs = _flatten_data(array)\n\n    # offset data and val_old to allow negative values\n    offset = np.min([np.min(array), np.min(val_new)])\n\n    # convert to np.array\n    val_old = (np.asarray(val_old) - offset).astype(dtype)\n    val_new = (np.asarray(val_new) - offset).astype(dtype)\n\n    # convert data and shift\n    array = (array - offset).astype(dtype)\n\n    # shift data\n    conv = np.arange(array.max() + 1, dtype=dtype)\n    conv[val_old] = val_new\n    array = conv[array]\n\n    # shift data back\n    array = array.astype(np.int32) + offset\n\n    # reshape and return\n    return _unflatten_data(array, shape_kwargs)\n</code></pre>"},{"location":"reference/utils/#msmhelper.utils.swapcols","title":"<code>swapcols(array, indicesold, indicesnew)</code>","text":"<p>Interchange cols of an ndarray.</p> <p>This method swaps the specified columns.</p> <p>Parameters:</p> <ul> <li> <code>array</code>               (<code>ndarray</code>)           \u2013            <p>2D numpy array.</p> </li> <li> <code>indicesold</code>               (<code>integer or ndarray</code>)           \u2013            <p>1D array of indices.</p> </li> <li> <code>indicesnew</code>               (<code>integer or ndarray</code>)           \u2013            <p>1D array of new indices</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>array_swapped</code> (              <code>ndarray</code> )          \u2013            <p>2D numpy array with swappend columns.</p> </li> </ul> Source code in <code>src/msmhelper/utils/_utils.py</code> <pre><code>def swapcols(array, indicesold, indicesnew):\n    r\"\"\"Interchange cols of an ndarray.\n\n    This method swaps the specified columns.\n\n    Parameters\n    ----------\n    array : ndarray\n        2D numpy array.\n    indicesold : integer or ndarray\n        1D array of indices.\n    indicesnew : integer or ndarray\n        1D array of new indices\n\n    Returns\n    -------\n    array_swapped : ndarray\n        2D numpy array with swappend columns.\n\n    \"\"\"\n    # cast to 1d arrays\n    indicesnew = _asindex(indicesnew)\n    indicesold = _asindex(indicesold)\n\n    if len(indicesnew) != len(indicesold):\n        raise ValueError('Indices needs to be of same shape.')\n\n    # cast data\n    array = np.asarray(array)\n\n    if np.all(indicesnew == indicesold):\n        return array\n\n    # fails for large data sets\n    # noqa: E800 # array.T[indicesold] = array.T[indicesnew]\n    array_swapped = np.copy(array)\n    array_swapped.T[indicesold] = array.T[indicesnew]\n\n    return array_swapped\n</code></pre>"},{"location":"reference/utils/#msmhelper.utils.unique","title":"<code>unique(trajs, **kwargs)</code>","text":"<p>Apply numpy.unique to traj.</p> <p>Parameters:</p> <ul> <li> <code>trajs</code>               (<code>list or ndarray or list of ndarrays</code>)           \u2013            <p>State trajectory or list of state trajectories.</p> </li> <li> <code>**kwargs</code>           \u2013            <p>Arguments of numpy.unique</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>unique</code> (              <code>ndarray</code> )          \u2013            <p>Array containing all states, see numpy for more details.</p> </li> </ul> Source code in <code>src/msmhelper/utils/_utils.py</code> <pre><code>def unique(trajs, **kwargs):\n    r\"\"\"Apply numpy.unique to traj.\n\n    Parameters\n    ----------\n    trajs : list or ndarray or list of ndarrays\n        State trajectory or list of state trajectories.\n    **kwargs\n        Arguments of [numpy.unique][]\n\n    Returns\n    -------\n    unique : ndarray\n        Array containing all states, see numpy for more details.\n\n    \"\"\"\n    # flatten data\n    trajs, _ = _flatten_data(trajs)\n\n    # get unique states with population\n    return np.unique(trajs, **kwargs)\n</code></pre>"},{"location":"reference/utils/datasets/","title":"datasets","text":"<p>Set of datasets to use for the tutorials.</p>"},{"location":"reference/utils/datasets/#msmhelper.utils.datasets.propagate_tmat","title":"<code>propagate_tmat(tmat, nsteps, start=None)</code>","text":"<p>Markov chain Monte Carlo propagation of transition matrix for nsteps.</p> <p>Parameters:</p> <ul> <li> <code>tmat</code>               (<code>ndarray</code>)           \u2013            <p>Transition matrix to propagate.</p> </li> <li> <code>nsteps</code>               (<code>int</code>)           \u2013            <p>Number of steps to propagate.</p> </li> <li> <code>start</code>               (<code>int</code>, default:                   <code>None</code> )           \u2013            <p>Index where to start. If <code>None</code> a random number will be used.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>traj</code> (              <code>ndarray</code> )          \u2013            <p>Markov chain Monte Carlo state trajectory of given tmat.</p> </li> </ul> Source code in <code>src/msmhelper/utils/datasets.py</code> <pre><code>def propagate_tmat(tmat, nsteps, start=None):\n    \"\"\"Markov chain Monte Carlo propagation of transition matrix for nsteps.\n\n    Parameters\n    ----------\n    tmat : ndarray\n        Transition matrix to propagate.\n    nsteps : int\n        Number of steps to propagate.\n    start : int\n        Index where to start. If `None` a random number will be used.\n\n    Returns\n    -------\n    traj : ndarray\n        Markov chain Monte Carlo state trajectory of given tmat.\n\n    \"\"\"\n    if not is_transition_matrix(tmat):\n        raise ValueError('tmat needs to be a row-normalized matrix.')\n\n    n_states = len(tmat)\n    cummat = np.cumsum(  # enforce exact normalization\n        row_normalize_matrix(tmat),\n        axis=1,\n    )\n    cummat_perm = np.tile(np.arange(n_states), (n_states, 1))\n\n    if start is None:\n        start = np.random.randint(n_states)\n\n    return _propagate_MCMC(\n        cummat=(cummat, cummat_perm),\n        start=start,\n        steps=nsteps,\n    )\n</code></pre>"},{"location":"reference/utils/datasets/#msmhelper.utils.datasets.hummer15_4state","title":"<code>hummer15_4state(rate_k, rate_h, nsteps, return_macrotraj=False)</code>","text":"<p>Four state model taken from Hummer and Szabo 15.</p> <p>Gerhard Hummer and Attila Szabo The Journal of Physical Chemistry B 2015 119 (29), 9029-9037 DOI: 10.1021/jp508375q</p> <p>Parameters:</p> <ul> <li> <code>rate_k</code>               (<code>float</code>)           \u2013            <p>Rate between state 1&lt;-&gt;2 and 3&lt;-&gt;4.</p> </li> <li> <code>rate_h</code>               (<code>float</code>)           \u2013            <p>Rate between state 2&lt;-&gt;3.</p> </li> <li> <code>nsteps</code>               (<code>int</code>)           \u2013            <p>Number of steps to propagate.</p> </li> <li> <code>return_macrotraj</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If <code>True</code> return a macrotraj where state (1,2) and (3,4) are lumped as well.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>traj</code> (              <code>ndarray</code> )          \u2013            <p>Markov chain Monte Carlo state trajectory.</p> </li> <li> <code>macrotraj</code> (              <code>ndarray</code> )          \u2013            <p>Markov chain Monte Carlo macrostate trajectory if <code>macrotraj=True</code>.</p> </li> </ul> Source code in <code>src/msmhelper/utils/datasets.py</code> <pre><code>def hummer15_4state(rate_k, rate_h, nsteps, return_macrotraj=False):\n    \"\"\"Four state model taken from Hummer and Szabo 15.\n\n    Gerhard Hummer and Attila Szabo\n    The Journal of Physical Chemistry B 2015 119 (29), 9029-9037\n    DOI: [10.1021/jp508375q](https://pubs.acs.org/doi/10.1021/jp508375q)\n\n    Parameters\n    ----------\n    rate_k : float\n        Rate between state 1&lt;-&gt;2 and 3&lt;-&gt;4.\n    rate_h : float\n        Rate between state 2&lt;-&gt;3.\n    nsteps : int\n        Number of steps to propagate.\n    return_macrotraj : bool, optional\n        If `True` return a macrotraj where state (1,2) and (3,4) are lumped\n        as well.\n\n    Returns\n    -------\n    traj : ndarray\n        Markov chain Monte Carlo state trajectory.\n    macrotraj : ndarray\n        Markov chain Monte Carlo macrostate trajectory if `macrotraj=True`.\n\n    \"\"\"\n    return _hummer15_nstate(\n        n_states=4,\n        rate_k=rate_k,\n        rate_h=rate_h,\n        nsteps=nsteps,\n        return_macrotraj=return_macrotraj,\n    )\n</code></pre>"},{"location":"reference/utils/datasets/#msmhelper.utils.datasets.hummer15_8state","title":"<code>hummer15_8state(rate_k, rate_h, nsteps, return_macrotraj=False)</code>","text":"<p>Eight state model inspired by Hummer and Szabo 15.</p> <p>Gerhard Hummer and Attila Szabo The Journal of Physical Chemistry B 2015 119 (29), 9029-9037 DOI: 10.1021/jp508375q</p> <p>Parameters:</p> <ul> <li> <code>rate_k</code>               (<code>float</code>)           \u2013            <p>Rate between state 1&lt;-&gt;2, 3&lt;-&gt;4, 5&lt;-&gt;6, 7&lt;-&gt;8.</p> </li> <li> <code>rate_h</code>               (<code>float</code>)           \u2013            <p>Rate between state 2&lt;-&gt;3, 4&lt;-&gt;5, 6&lt;-&gt;7.</p> </li> <li> <code>nsteps</code>               (<code>int</code>)           \u2013            <p>Number of steps to propagate.</p> </li> <li> <code>return_macrotraj</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If <code>True</code> return a macrotraj where state (1,2), (3,4), (5,6), and (7,8) are lumped as well.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>traj</code> (              <code>ndarray</code> )          \u2013            <p>Markov chain Monte Carlo state trajectory.</p> </li> <li> <code>macrotraj</code> (              <code>ndarray</code> )          \u2013            <p>Markov chain Monte Carlo macrostate trajectory if <code>macrotraj=True</code>.</p> </li> </ul> Source code in <code>src/msmhelper/utils/datasets.py</code> <pre><code>def hummer15_8state(rate_k, rate_h, nsteps, return_macrotraj=False):\n    \"\"\"Eight state model inspired by Hummer and Szabo 15.\n\n    Gerhard Hummer and Attila Szabo\n    The Journal of Physical Chemistry B 2015 119 (29), 9029-9037\n    DOI: [10.1021/jp508375q](https://pubs.acs.org/doi/10.1021/jp508375q)\n\n    Parameters\n    ----------\n    rate_k : float\n        Rate between state 1&lt;-&gt;2, 3&lt;-&gt;4, 5&lt;-&gt;6, 7&lt;-&gt;8.\n    rate_h : float\n        Rate between state 2&lt;-&gt;3, 4&lt;-&gt;5, 6&lt;-&gt;7.\n    nsteps : int\n        Number of steps to propagate.\n    return_macrotraj : bool, optional\n        If `True` return a macrotraj where state (1,2), (3,4), (5,6), and (7,8)\n        are lumped as well.\n\n    Returns\n    -------\n    traj : ndarray\n        Markov chain Monte Carlo state trajectory.\n    macrotraj : ndarray\n        Markov chain Monte Carlo macrostate trajectory if `macrotraj=True`.\n\n    \"\"\"\n    return _hummer15_nstate(\n        n_states=8,\n        rate_k=rate_k,\n        rate_h=rate_h,\n        nsteps=nsteps,\n        return_macrotraj=return_macrotraj,\n    )\n</code></pre>"},{"location":"reference/utils/datasets/#msmhelper.utils.datasets.nagel20_4state","title":"<code>nagel20_4state(nsteps)</code>","text":"<p>Four state model taken from Nagel et al. 20.</p> <p>Daniel Nagel, Anna Weber, and Gerhard Stock Journal of Chemical Theory and Computation 2020 16 (12), 7874-7882 DOI: 10.1021/acs.jctc.0c00774</p> <p>Parameters:</p> <ul> <li> <code>nsteps</code>               (<code>int</code>)           \u2013            <p>Number of steps to propagate.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>traj</code> (              <code>ndarray</code> )          \u2013            <p>Markov chain Monte Carlo state trajectory.</p> </li> </ul> Source code in <code>src/msmhelper/utils/datasets.py</code> <pre><code>@_decorate_tmat(_NAGEL20_4STATE_TMAT)\ndef nagel20_4state(nsteps):\n    \"\"\"Four state model taken from Nagel et al. 20.\n\n    Daniel Nagel, Anna Weber, and Gerhard Stock\n    Journal of Chemical Theory and Computation 2020 16 (12), 7874-7882\n    DOI: [10.1021/acs.jctc.0c00774](https://doi.org/10.1021/acs.jctc.0c00774)\n\n    Parameters\n    ----------\n    nsteps : int\n        Number of steps to propagate.\n\n    Returns\n    -------\n    traj : ndarray\n        Markov chain Monte Carlo state trajectory.\n\n    \"\"\"\n    return propagate_tmat(_NAGEL20_4STATE_TMAT, nsteps) + 1\n</code></pre>"},{"location":"reference/utils/datasets/#msmhelper.utils.datasets.nagel20_6state","title":"<code>nagel20_6state(nsteps)</code>","text":"<p>Six state model taken from Nagel et al. 20.</p> <p>Daniel Nagel, Anna Weber, and Gerhard Stock Journal of Chemical Theory and Computation 2020 16 (12), 7874-7882 DOI: 10.1021/acs.jctc.0c00774</p> <p>Parameters:</p> <ul> <li> <code>nsteps</code>               (<code>int</code>)           \u2013            <p>Number of steps to propagate.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>traj</code> (              <code>ndarray</code> )          \u2013            <p>Markov chain Monte Carlo state trajectory.</p> </li> </ul> Source code in <code>src/msmhelper/utils/datasets.py</code> <pre><code>@_decorate_tmat(_NAGEL20_6STATE_TMAT)\ndef nagel20_6state(nsteps):\n    \"\"\"Six state model taken from Nagel et al. 20.\n\n    Daniel Nagel, Anna Weber, and Gerhard Stock\n    Journal of Chemical Theory and Computation 2020 16 (12), 7874-7882\n    DOI: [10.1021/acs.jctc.0c00774](https://doi.org/10.1021/acs.jctc.0c00774)\n\n    Parameters\n    ----------\n    nsteps : int\n        Number of steps to propagate.\n\n    Returns\n    -------\n    traj : ndarray\n        Markov chain Monte Carlo state trajectory.\n\n    \"\"\"\n    return propagate_tmat(_NAGEL20_6STATE_TMAT, nsteps) + 1\n</code></pre>"},{"location":"reference/utils/filtering/","title":"filtering","text":"<p>Set of filtering functions.</p> <p>Todo</p> <ul> <li>Correct border effects of running mean</li> </ul>"},{"location":"reference/utils/filtering/#msmhelper.utils.filtering.runningmean","title":"<code>runningmean(array, window)</code>","text":"<p>Compute centered running average with given window size.</p> <p>This function returns the centered based running average of the given data. The output of this function is of the same length as the input, by assuming that the given data is zero before and after the given series. Hence, there are border affects which are not corrected.</p> <p>Warning</p> <p>If the given window is even (not symmetric) it will be shifted towards the beginning of the current value. So for <code>window=4</code>, it will consider the current position \\(i\\), the two to the left \\(i-2\\) and \\(i-1\\) and one to the right \\(i+1\\).</p> <p>Function is taken from lapis: https://stackoverflow.com/questions/13728392/moving-average-or-running-mean</p> <p>Parameters:</p> <ul> <li> <code>array</code>               (<code>ndarray</code>)           \u2013            <p>One dimensional numpy array.</p> </li> <li> <code>window</code>               (<code>int</code>)           \u2013            <p>Integer which specifies window-width.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>array_rmean</code> (              <code>ndarray</code> )          \u2013            <p>Data which is time-averaged over the specified window.</p> </li> </ul> Source code in <code>src/msmhelper/utils/filtering.py</code> <pre><code>def runningmean(array, window):\n    r\"\"\"Compute centered running average with given window size.\n\n    This function returns the centered based running average of the given\n    data. The output of this function is of the same length as the input,\n    by assuming that the given data is zero before and after the given series.\n    Hence, there are border affects which are not corrected.\n\n    !!! warning\n        If the given window is even (not symmetric) it will be shifted towards\n        the beginning of the current value. So for `window=4`, it will consider\n        the current position \\(i\\), the two to the left \\(i-2\\) and \\(i-1\\) and\n        one to the right \\(i+1\\).\n\n    Function is taken from lapis:\n    https://stackoverflow.com/questions/13728392/moving-average-or-running-mean\n\n    Parameters\n    ----------\n    array : ndarray\n        One dimensional numpy array.\n    window : int\n        Integer which specifies window-width.\n\n    Returns\n    -------\n    array_rmean : ndarray\n        Data which is time-averaged over the specified window.\n\n    \"\"\"\n    ndim = _np.asarray(array).ndim\n    if ndim &gt; 1:\n        raise ValueError(\n            'Runningmean is only defined for 1D data, but'\n            f'{ndim:.0f}D data were provided.'\n        )\n\n    # Calculate running mean\n    return _np.convolve(\n        array,\n        _np.ones(window) / window,\n        mode='same',\n    )\n</code></pre>"},{"location":"reference/utils/filtering/#msmhelper.utils.filtering.gaussian_filter","title":"<code>gaussian_filter(array, sigma)</code>","text":"<p>Compute Gaussian filter along axis=0.</p> <p>Parameters:</p> <ul> <li> <code>array</code>               (<code>ndarray</code>)           \u2013            <p>One dimensional numpy array.</p> </li> <li> <code>sigma</code>               (<code>float</code>)           \u2013            <p>Float which specifies the standard deviation of the Gaussian kernel (window-width).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>array_filtered</code> (              <code>ndarray</code> )          \u2013            <p>Data which is time-averaged with the specified Gaussian kernel.</p> </li> </ul> Source code in <code>src/msmhelper/utils/filtering.py</code> <pre><code>def gaussian_filter(array, sigma):\n    r\"\"\"Compute Gaussian filter along axis=0.\n\n    Parameters\n    ----------\n    array : ndarray\n        One dimensional numpy array.\n    sigma : float\n        Float which specifies the standard deviation of the Gaussian kernel\n        (window-width).\n\n    Returns\n    -------\n    array_filtered : ndarray\n        Data which is time-averaged with the specified Gaussian kernel.\n\n    \"\"\"\n    array = _np.asarray(array, dtype=_np.float64)\n    ndim = array.ndim\n    if ndim &gt; 2:\n        raise ValueError(\n            'Gaussian filtering is only defined for 1D and 2D data, but'\n            f'{ndim:.0f}D data were provided.'\n        )\n\n    # Calculate running mean\n    if ndim == 1:\n        return _gaussian_filter_1d(\n            array,\n            sigma=sigma,\n            mode='nearest',\n        )\n    return _gaussian_filter(\n        array,\n        sigma=(sigma, 0),\n        mode='nearest',\n    )\n</code></pre>"},{"location":"reference/utils/tests/","title":"tests","text":"<p>Set of helpful test functions.</p>"},{"location":"reference/utils/tests/#msmhelper.utils.tests.is_quadratic","title":"<code>is_quadratic(matrix)</code>","text":"<p>Check if matrix is quadratic.</p> <p>Parameters:</p> <ul> <li> <code>matrix</code>               (<code>ndarray, list of lists</code>)           \u2013            <p>Matrix which is checked if is 2d array.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>is_quadratic</code> (              <code>bool</code> )          \u2013            </li> </ul> Source code in <code>src/msmhelper/utils/tests.py</code> <pre><code>def is_quadratic(matrix):\n    \"\"\"Check if matrix is quadratic.\n\n    Parameters\n    ----------\n    matrix : ndarray, list of lists\n        Matrix which is checked if is 2d array.\n\n    Returns\n    -------\n    is_quadratic : bool\n\n    \"\"\"\n    # cast to 2d for easier error checking\n\n    matrix = np.atleast_2d(matrix)\n    shape = np.shape(matrix)\n\n    # Check whether matrix is quadratic.\n    if shape[0] != shape[1]:\n        return False\n    # check if scalar or tensor higher than 2d\n    if shape[0] == 1 or matrix.ndim &gt; 2:\n        return False\n\n    return True\n</code></pre>"},{"location":"reference/utils/tests/#msmhelper.utils.tests.is_state_traj","title":"<code>is_state_traj(trajs)</code>","text":"<p>Check if state trajectory is correct formatted.</p> <p>Parameters:</p> <ul> <li> <code>trajs</code>               (<code>list of ndarray</code>)           \u2013            <p>State trajectory/trajectories need to be lists of ndarrays of integers.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>is_state_traj</code> (              <code>bool</code> )          \u2013            </li> </ul> Source code in <code>src/msmhelper/utils/tests.py</code> <pre><code>def is_state_traj(trajs):\n    \"\"\"Check if state trajectory is correct formatted.\n\n    Parameters\n    ----------\n    trajs : list of ndarray\n        State trajectory/trajectories need to be lists of ndarrays of integers.\n\n    Returns\n    -------\n    is_state_traj : bool\n\n    \"\"\"\n    try:\n        _utils._check_state_traj(trajs)  # noqa: WPS437\n    except TypeError:\n        return False\n    else:\n        return True\n</code></pre>"},{"location":"reference/utils/tests/#msmhelper.utils.tests.is_index_traj","title":"<code>is_index_traj(trajs)</code>","text":"<p>Check if states can be used as indices.</p> <p>Parameters:</p> <ul> <li> <code>trajs</code>               (<code>list of ndarray</code>)           \u2013            <p>State trajectory/trajectories need to be lists of ndarrays of integers.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>is_index</code> (              <code>bool</code> )          \u2013            </li> </ul> Source code in <code>src/msmhelper/utils/tests.py</code> <pre><code>def is_index_traj(trajs):\n    \"\"\"Check if states can be used as indices.\n\n    Parameters\n    ----------\n    trajs : list of ndarray\n        State trajectory/trajectories need to be lists of ndarrays of integers.\n\n    Returns\n    -------\n    is_index : bool\n\n    \"\"\"\n    if isinstance(trajs, StateTraj):\n        return True\n    if is_state_traj(trajs):\n        states = _utils.unique(trajs)\n        return np.array_equal(states, np.arange(len(states)))\n    return False\n</code></pre>"},{"location":"reference/utils/tests/#msmhelper.utils.tests.is_transition_matrix","title":"<code>is_transition_matrix(matrix, atol=1e-08)</code>","text":"<p>Check if transition matrix.</p> <p>Rows and cols of zeros (non-visited states) are accepted.</p> <p>Parameters:</p> <ul> <li> <code>matrix</code>               (<code>ndarray</code>)           \u2013            <p>Transition matrix.</p> </li> <li> <code>atol</code>               (<code>float</code>, default:                   <code>1e-08</code> )           \u2013            <p>Absolute tolerance.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>is_tmat</code> (              <code>bool</code> )          \u2013            </li> </ul> Source code in <code>src/msmhelper/utils/tests.py</code> <pre><code>@decorit.alias('is_tmat')\ndef is_transition_matrix(matrix, atol=1e-8):\n    \"\"\"Check if transition matrix.\n\n    Rows and cols of zeros (non-visited states) are accepted.\n\n    Parameters\n    ----------\n    matrix : ndarray\n        Transition matrix.\n    atol : float, optional\n        Absolute tolerance.\n\n    Returns\n    -------\n    is_tmat : bool\n\n    \"\"\"\n    matrix = np.atleast_2d(matrix)\n    visited = np.logical_or(\n        matrix.sum(axis=-1),\n        matrix.sum(axis=0),\n    )\n    return (\n        is_quadratic(matrix) and\n        np.logical_or(\n            np.abs(matrix.sum(axis=-1) - 1) &lt;= atol,\n            ~visited,\n        ).all()\n    )\n</code></pre>"},{"location":"reference/utils/tests/#msmhelper.utils.tests.is_ergodic","title":"<code>is_ergodic(matrix, atol=1e-08)</code>","text":"<p>Check if matrix is ergodic.</p> <p>Parameters:</p> <ul> <li> <code>matrix</code>               (<code>ndarray</code>)           \u2013            <p>Transition matrix.</p> </li> <li> <code>atol</code>               (<code>float</code>, default:                   <code>1e-08</code> )           \u2013            <p>Absolute tolerance.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>is_ergodic</code> (              <code>bool</code> )          \u2013            </li> </ul> References <p>Wielandt, Unzerlegbare, Nicht Negativen Matrizen. Mathematische Zeitschrift Vol. 52, 1950, pp. 642\u2013648.</p> Source code in <code>src/msmhelper/utils/tests.py</code> <pre><code>def is_ergodic(matrix, atol=1e-8):\n    \"\"\"Check if matrix is ergodic.\n\n    Parameters\n    ----------\n    matrix : ndarray\n        Transition matrix.\n    atol : float, optional\n        Absolute tolerance.\n\n    Returns\n    -------\n    is_ergodic : bool\n\n    References\n    ----------\n    Wielandt, **Unzerlegbare, Nicht Negativen Matrizen.**\n        *Mathematische Zeitschrift* Vol. 52, 1950, pp. 642\u2013648.\n\n    \"\"\"\n    if not is_transition_matrix(matrix):\n        return False\n\n    matrix = np.atleast_2d(matrix)\n\n    nstates = len(matrix)\n    exponent = (nstates - 1)**2 + 1\n\n    matrix = _utils.matrix_power(matrix, exponent)\n    return (matrix &gt; atol).all()\n</code></pre>"},{"location":"reference/utils/tests/#msmhelper.utils.tests.is_fuzzy_ergodic","title":"<code>is_fuzzy_ergodic(matrix, atol=1e-08)</code>","text":"<p>Check if matrix is ergodic, up to missing states or trap states.</p> <p>If there are two or more disjoint</p> <p>Parameters:</p> <ul> <li> <code>matrix</code>               (<code>ndarray</code>)           \u2013            <p>Transition matrix.</p> </li> <li> <code>atol</code>               (<code>float</code>, default:                   <code>1e-08</code> )           \u2013            <p>Absolute tolerance.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>is_fuzzy_ergodic</code> (              <code>bool</code> )          \u2013            </li> </ul> Source code in <code>src/msmhelper/utils/tests.py</code> <pre><code>def is_fuzzy_ergodic(matrix, atol=1e-8):\n    \"\"\"Check if matrix is ergodic, up to missing states or trap states.\n\n    If there are two or more disjoint\n\n    Parameters\n    ----------\n    matrix : ndarray\n        Transition matrix.\n    atol : float, optional\n        Absolute tolerance.\n\n    Returns\n    -------\n    is_fuzzy_ergodic : bool\n\n    \"\"\"\n    if not is_transition_matrix(matrix):\n        return False\n\n    matrix = np.atleast_2d(matrix)\n    row_col_sum = matrix.sum(axis=-1) + matrix.sum(axis=0)\n\n    is_trap_state = np.logical_or(\n        np.abs(row_col_sum - 2) &lt;= atol,\n        np.abs(row_col_sum) &lt;= atol,\n    )\n    is_trap_state = np.logical_or(\n        is_trap_state[:, np.newaxis],\n        is_trap_state[np.newaxis, :],\n    )\n\n    nstates = len(matrix)\n    exponent = (nstates - 1)**2 + 1\n    matrix = _utils.matrix_power(matrix, exponent)\n\n    return np.logical_or(matrix &gt; 0, is_trap_state).all()\n</code></pre>"},{"location":"reference/utils/tests/#msmhelper.utils.tests.ergodic_mask","title":"<code>ergodic_mask(matrix, atol=1e-08)</code>","text":"<p>Create mask for filtering ergodic submatrix.</p> <p>Parameters:</p> <ul> <li> <code>matrix</code>               (<code>ndarray</code>)           \u2013            <p>Transition matrix.</p> </li> <li> <code>atol</code>               (<code>float</code>, default:                   <code>1e-08</code> )           \u2013            <p>Absolute tolerance.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>mask</code> (              <code>bool ndarray</code> )          \u2013            </li> </ul> Source code in <code>src/msmhelper/utils/tests.py</code> <pre><code>def ergodic_mask(matrix, atol=1e-8):\n    \"\"\"Create mask for filtering ergodic submatrix.\n\n    Parameters\n    ----------\n    matrix : ndarray\n        Transition matrix.\n    atol : float, optional\n        Absolute tolerance.\n\n    Returns\n    -------\n    mask : bool ndarray\n\n    \"\"\"\n    if not is_transition_matrix(matrix):\n        raise ValueError(\"Input matrix needs to be of kind transition matrix.\")\n\n    matrix = np.atleast_2d(matrix)\n    nstates = len(matrix)\n    exponent = (nstates - 1)**2 + 1\n\n    matrix = _utils.matrix_power(matrix, exponent) &gt; atol\n    matrix = np.logical_and(matrix, matrix.T)\n\n    # find minimum row counts to identify largest connected block\n    maxstates = np.max(matrix.sum(axis=-1))\n    return matrix.sum(axis=-1) == maxstates\n</code></pre>"},{"location":"tutorials/","title":"Getting Started with <code>msmhelper</code>","text":""},{"location":"tutorials/#introduction","title":"Introduction","text":"<p>If you are interested in analyzing protein dynamics using Markov state modeling, this tutorial will provide you with a step-by-step guide to use <code>msmhelper</code>, a Python package, that is designed specifically for this purpose. The tutorial is divided into several sections, each of which covers a specific aspect of Markov state modeling, from the theoretical background to the practical implementation using this package. Whether you are a beginner or an experienced user, this tutorial will help you get up and running with Markov state modeling and enable you to explore the dynamics of complex protein systems.</p>"},{"location":"tutorials/#disclaimer","title":"Disclaimer","text":"<p>Please note that the Python package <code>msmhelper</code> for Markov state modeling that we will be discussing in this tutorial provides only methods and tools for analyzing preprocessed data, in the form of a given state trajectory. The remaining workflow from the raw molecular dynamics (MD) trajectory, consisting of feature extraction, feature selection, dimensionality reduction, geometrical clustering, and dynamical lumping of states, is not provided by this package.</p> <p>We recommend using established packages like MDAnalysis for feature extraction in molecular dynamics simulations. For dimensionality reduction methods, such as principal component analysis (PCA) or time-lagged independent component analysis (tICA), we suggest using scikit-learn or PyEMMA. These libraries offer a variety of clustering algorithms, including commonly used methods like \\(k\\)-means and hierarchical clustering. To perform dynamical coarse-graining, we recommend using packages like pyGPCCA and MPP. For a more comprehensive review of available methods, we recommend reading the article \"Perspective: Identification of collective variables and metastable states of protein dynamics\" by Sittel and Stock, which can be accessed at \"https://doi.org/10.1063/1.5049637\".</p> <p>By combining the methods and tools provided by the Markov state modeling package with these other packages, you can perform a complete analysis of protein dynamics from a raw MD trajectory.</p>"},{"location":"tutorials/#installation","title":"Installation","text":"<p>Before you can use the Python package for Markov state modeling, you will need to install it on your machine. The package is available on both <code>pip</code> and <code>conda-forge</code>, so you can choose the installation method that suits your preferences.</p> <p>To install the package using pip, open a terminal or command prompt and enter the following command:</p> <pre><code>python -m pip install msmhelper\n</code></pre> <p>where <code>msmhelper</code> is the name of the package.</p> <p>If you prefer to use conda, you can install the package by entering the following command in your terminal:</p> <pre><code>conda install -c conda-forge msmhelper\n</code></pre> <p>Once you have installed the package, you are ready to head over to the tutorial!</p>"},{"location":"tutorials/#sections","title":"Sections","text":"<ul> <li> <p>Theoretical Background: In this section, you will learn the basic concepts behind Markov state modeling and how it can be used to analyze protein dynamics. We will cover the key mathematical concepts, including transition matrices, equilibrium distributions, and Markov chains.</p> </li> <li> <p>Structure of <code>msmhelper</code>: This section gives a brief overview of the structure of the module, by describing the usage of every submodule itself. For more details refer to the code reference.</p> </li> <li> <p>Estimation and Validation of an MSM: Here, we will walk you through the process of constructing a Markov state model from clustered state trajectory of a protein dynamics simulation. We will cover data model creation, and model validation.</p> </li> <li> <p>Estimation of Waiting Times and Pathways: In this section, we will show you how to estimate the timescales of protein conformational transitions and how to extract the most probable pathways from an MSM.</p> </li> <li> <p>HS-Projection: Here, we will introduce you to the concept of the Hummer-Szabo (HS) projection, which allows for the optimal coarse-graining/reduction together with PCCA or MPP. We will show the dramatic improvements relying on this technique.</p> </li> <li> <p>Command Line Interface: In this section, we will provide a short guide to the command line interface of <code>msmhelper</code>, which provides some common analysis and visualization functionality.</p> </li> </ul>"},{"location":"tutorials/#conclusion","title":"Conclusion","text":"<p>By the end of this tutorial, you will have a good understanding of the theoretical underpinnings of Markov state modeling and how to use <code>msmhelper</code> to perform the practical analysis. You will also have learned about some advanced concepts, such as the Hummer-Szabo projection, and gained experience with the command line interface. We hope that this tutorial will provide you with the tools and knowledge you need to explore the fascinating world of protein dynamics!</p>"},{"location":"tutorials/cli/","title":"CLI","text":"In\u00a0[1]: Copied! <pre>%%bash\npython -m msmhelper\n</pre> %%bash python -m msmhelper <pre>Usage: python -m msmhelper [OPTIONS] COMMAND [ARGS]...\n</pre> <pre>\n</pre> <pre>  msmhelper v1.1.1\n</pre> <pre>\n</pre> <pre>  Unlock the power of protein dynamics time series with Markov state modeling,\n</pre> <pre>  by simplifying scientific analysis.\n</pre> <pre>\n</pre> <pre>  Copyright (c) 2019-2023, Daniel Nagel\n</pre> <pre>\n</pre> <pre>Options:\n</pre> <pre>  --help  Show this message and exit.\n</pre> <pre>\n</pre> <pre>Commands:\n</pre> <pre>  ck-test                 Estimation and visualization of the...\n</pre> <pre>  compare-discretization  Similarity measure of two different state...\n</pre> <pre>  contact-rep             Contact representation of states.\n</pre> <pre>  dynamical-coring        Applying dynamical coring on state trajectory.\n</pre> <pre>  gaussian-filtering      Applying gaussian filter on time series.\n</pre> <pre>  implied-timescales      Estimation and visualization of the implied...\n</pre> <pre>  waiting-time-dist       Estimation and visualization of the waiting...\n</pre> <pre>  waiting-times           Estimation and visualization of the waiting times.\n</pre> <p>Further, every submodule gives detailed help, simply run</p> In\u00a0[2]: Copied! <pre>%%bash\npython -m msmhelper ck-test\n</pre> %%bash python -m msmhelper ck-test <pre>Usage: python -m msmhelper ck-test [OPTIONS]\n</pre> <pre>\n</pre> <pre>  Estimation and visualization of the Chapman-Kolmogorov test.\n</pre> <pre>\n</pre> <pre>Options:\n</pre> <pre>  -f, --filename PATH          Path to state trajectory file (single column\n</pre> <pre>                               ascii file).  [required]\n</pre> <pre>  --microfilename PATH         Path to microstate trajectory file (single\n</pre> <pre>                               column ascii file) to use Hummer-Szabo\n</pre> <pre>                               projection.\n</pre> <pre>  -c, --concat-limits PATH     Path to concatination limit file given the\n</pre> <pre>                               length of all trajectories, e.g. \"3\\n3\\n5\"\n</pre> <pre>  -o, --output PATH            Output basename of figure. Needs to have a\n</pre> <pre>                               valid extension (\".pdf\", \".svg\", \".png\").\n</pre> <pre>                               Default format is pdf.\n</pre> <pre>  --lagtimes INTEGER RANGE...  5 (!) Lag times given in frames to estimate\n</pre> <pre>                               Markov state model.  [x&gt;=1; required]\n</pre> <pre>  --frames-per-unit FLOAT      Number of frames per unit.  [required]\n</pre> <pre>  --unit [fs|ps|ns|us|frames]  Unit of data.  [required]\n</pre> <pre>  --grid INTEGER RANGE...      Number of rows and cols.  [x&gt;=1]\n</pre> <pre>  --max-time INTEGER RANGE     Largest time value to evaluate and plot the\n</pre> <pre>                               test.  [x&gt;=1]\n</pre> <pre>  --help                       Show this message and exit.\n</pre> <p>A simple example of an Chapman-Kolmogorov test produced with a 4 state toy model.</p> <p></p>"},{"location":"tutorials/cli/#command-line-interface","title":"Command Line Interface\u00b6","text":"<p>Our Python package not only provides a powerful Markov state modeling framework for analyzing biomolecular dynamics simulations, but it also includes a command line interface for incorporating key tasks into your bash pipelines. With our CLI, users can easily integrate our package into their workflow, streamlining the analysis process and increasing efficiency.</p> <p>In addition, our package includes powerful tools for generating publication-ready figures, making it easy for users to create visually stunning and informative data visualizations for their research papers and presentations.</p> <p>To get an overview over all modules simply run the following command in the shell, or take a look at the reference documentation.</p>"},{"location":"tutorials/hummerszabo/","title":"HS-Projection","text":"In\u00a0[1]: Copied! <pre>import msmhelper as mh\nimport numpy as np\nimport prettypyplot as pplt\nfrom matplotlib import pyplot as plt\nfrom msmhelper.utils import datasets\nfrom IPython.display import display, display_markdown\n\npplt.use_style(figsize=(6, 2.5), latex=False, colors='pastel_autumn')\n\n# rate of h, k\nrates = ((0.2, 0.05), (0.1, 0.1), (0.1, 0.2))\ntrajs = {\n    rate: {\n        label: traj\n        for label, traj in zip(\n            ('micro', 'macro'),\n            datasets.hummer15_8state(*rate, nsteps=int(1e5), return_macrotraj=True),\n        )\n    }\n    for rate in rates\n}\n</pre> import msmhelper as mh import numpy as np import prettypyplot as pplt from matplotlib import pyplot as plt from msmhelper.utils import datasets from IPython.display import display, display_markdown  pplt.use_style(figsize=(6, 2.5), latex=False, colors='pastel_autumn')  # rate of h, k rates = ((0.2, 0.05), (0.1, 0.1), (0.1, 0.2)) trajs = {     rate: {         label: traj         for label, traj in zip(             ('micro', 'macro'),             datasets.hummer15_8state(*rate, nsteps=int(1e5), return_macrotraj=True),         )     }     for rate in rates } In\u00a0[2]: Copied! <pre>lagtimes = np.arange(1, 25)\n_, axs = plt.subplots(2, len(rates), sharey=True, sharex=True)\nfor idx_rate, (rate, traj) in enumerate(trajs.items()):\n    eq_traj = mh.StateTraj(traj['macro'])\n    hummer_szabo_traj = mh.LumpedStateTraj(traj['macro'], traj['micro'])\n    \n    for idx_macro, macrotraj in enumerate((eq_traj, hummer_szabo_traj)):\n        ax = axs[idx_macro, idx_rate]\n        \n        impl_times = mh.msm.implied_timescales(macrotraj, lagtimes, ntimescales=3)\n        for idx, impl_time in enumerate(impl_times.T):\n            ax.plot(lagtimes, impl_time, label=f'$t_{idx + 1}$')\n        \n        ax.set_xlim(lagtimes[0], lagtimes[-1])\n        # highlight diagonal\n        ax.fill_between(ax.get_xlim(), ax.get_xlim(), color='pplt:grid')\n\npplt.subplot_labels(\n    xlabel=r'lagtime $\\tau$ [frames]',\n    ylabel='time scale [frames]',\n)\n</pre> lagtimes = np.arange(1, 25) _, axs = plt.subplots(2, len(rates), sharey=True, sharex=True) for idx_rate, (rate, traj) in enumerate(trajs.items()):     eq_traj = mh.StateTraj(traj['macro'])     hummer_szabo_traj = mh.LumpedStateTraj(traj['macro'], traj['micro'])          for idx_macro, macrotraj in enumerate((eq_traj, hummer_szabo_traj)):         ax = axs[idx_macro, idx_rate]                  impl_times = mh.msm.implied_timescales(macrotraj, lagtimes, ntimescales=3)         for idx, impl_time in enumerate(impl_times.T):             ax.plot(lagtimes, impl_time, label=f'$t_{idx + 1}$')                  ax.set_xlim(lagtimes[0], lagtimes[-1])         # highlight diagonal         ax.fill_between(ax.get_xlim(), ax.get_xlim(), color='pplt:grid')  pplt.subplot_labels(     xlabel=r'lagtime $\\tau$ [frames]',     ylabel='time scale [frames]', ) In\u00a0[3]: Copied! <pre>pplt.update_style(figsize=(5, 1.0))\nplt.ioff()  # deactivate automatically showing figures\nlagtimes = [1, 2, 3, 4]\ntmax = 445\n\nfor rate, traj in trajs.items():\n    display_markdown(fr'## Rates $h={rate[0]:.2f}, k={rate[1]:.2f}$', raw=True)\n    \n    eq_traj = mh.StateTraj(traj['macro'])\n    hummer_szabo_traj = mh.LumpedStateTraj(traj['macro'], traj['micro'])\n    \n    for label, macrotraj in (\n        ('EQ', eq_traj), ('HS-projection', hummer_szabo_traj),\n    ):\n        ck = mh.msm.ck_test(macrotraj, lagtimes, tmax)\n        fig = mh.plot.plot_ck_test(ck=ck, grid=(1, 4))\n        display_markdown(fr'### {label}', raw=True)\n        display(fig)\n        plt.close()\n</pre> pplt.update_style(figsize=(5, 1.0)) plt.ioff()  # deactivate automatically showing figures lagtimes = [1, 2, 3, 4] tmax = 445  for rate, traj in trajs.items():     display_markdown(fr'## Rates $h={rate[0]:.2f}, k={rate[1]:.2f}$', raw=True)          eq_traj = mh.StateTraj(traj['macro'])     hummer_szabo_traj = mh.LumpedStateTraj(traj['macro'], traj['micro'])          for label, macrotraj in (         ('EQ', eq_traj), ('HS-projection', hummer_szabo_traj),     ):         ck = mh.msm.ck_test(macrotraj, lagtimes, tmax)         fig = mh.plot.plot_ck_test(ck=ck, grid=(1, 4))         display_markdown(fr'### {label}', raw=True)         display(fig)         plt.close()"},{"location":"tutorials/hummerszabo/#hummer-szabo-projection","title":"Hummer-Szabo Projection\u00b6","text":"<p>This section is based on the finding of</p> <p>Optimal Dimensionality Reduction of Multistate Kinetic and Markov-State Models Gerhard Hummer and Attila Szabo, J. Phys. Chem. B 2015 119 (29), 9029-9037 doi: 10.1021/jp508375q</p>"},{"location":"tutorials/hummerszabo/#theory","title":"Theory\u00b6","text":"<p>Molecular simulations are often used to study the behavior of complex biomolecular systems. These simulations can generate large amounts of data, including information on the conformational states of the system. However, the high dimensionality of the state space can make it difficult to analyze and understand the underlying dynamics of the system.</p> <p>To address this issue, we often use Markov state models (MSMs) to analyze the dynamics of complex systems. MSMs are constructed by dividing the state space of the system into discrete states and then using the transition probabilities between these states to construct a Markov chain that describes the dynamics of the system. However, using common techniques, the number of microstates can be very large, sometimes in the hundreds. While the dynamics among these microstates may be approximately Markovian, discussing so many states is not feasible. To address this problem, we often lump the microstates into a few so-called macrostates, which can more easily be discussed and analyzed using, e.g., PCCA or MPP.</p> <p>However, if the timescale separation between the intra- and interstate dynamics is not given, lumping the states can introduce non-Markovian effects, which can materially distort the analysis of the system's dynamics. To overcome this issue, Hummer and Szabo have developed a projection formalism for optimally coarse-graining MSMs, by projecting the microstate dynamics onto the macrostate space. They showed, that this procedure can reduce their dimensionality while preserving the essential dynamical of the microstates. Here, we introduce a simple and fast implementation of the method.</p>"},{"location":"tutorials/hummerszabo/#implementation-in-msmhelper","title":"Implementation in <code>msmhelper</code>\u00b6","text":"<p>Using the Hummer-Szabo projection within the <code>msmhelper</code> package is rather easy. Simply create an <code>mh.LumpedStateTraj</code> instance via</p> <pre>traj = mh.LumpedStateTraj(macrotrajs, microtrajs)\n</pre> <p>and use this instead of <code>mh.StateTraj</code>. Passing now <code>traj</code> to any function within the <code>msm</code> module uses the HS projection.</p>"},{"location":"tutorials/hummerszabo/#impact-of-hummer-szabo-projection","title":"Impact of Hummer-Szabo Projection\u00b6","text":""},{"location":"tutorials/hummerszabo/#model","title":"Model\u00b6","text":"<p>In the original article, the authors used a 4 state model, where all states are chained up and connected only to their direct neighbors, $$ 1 \\stackrel{k}{\\longleftrightarrow} 2 \\stackrel{h}{\\longleftrightarrow} 3 \\stackrel{k}{\\longleftrightarrow} 4  $$ To introduce a second timescale (inner macrostate vs. border macrostate) we generalize this model to 8 microstates. $$ 1 \\stackrel{k}{\\longleftrightarrow} 2 \\stackrel{h}{\\longleftrightarrow} 3 \\stackrel{k}{\\longleftrightarrow} 4 \\stackrel{h}{\\longleftrightarrow} \\ldots \\stackrel{k}{\\longleftrightarrow} 8 $$</p> <p>Just like the HS Projection, we assume here that we found the optimal lumping by simple lump very two other to a macrostates, so $$ \\underbrace{(1 \\stackrel{k}{\\longleftrightarrow} 2)}_{S1} \\stackrel{h}{\\longleftrightarrow} \\underbrace{(3 \\stackrel{k}{\\longleftrightarrow} 4)}_{S2} \\stackrel{h}{\\longleftrightarrow} \\underbrace{(5 \\stackrel{k}{\\longleftrightarrow} 6)}_{S3} \\stackrel{h}{\\longleftrightarrow} \\underbrace{(7 \\stackrel{k}{\\longleftrightarrow} 8)}_{S4} $$ This means, that we assume that the times scale corresponding to the transition probability $k$ is much faster than the time scale corresponding to $h$.</p> <p>It should be noted that, the microstate trajectories are sampled from the transition matrix and are therefore perfectly Markovian (up to a statistical, but here neglegtable, error). The only source of non-Markovianty is due to the memory effects of not equilibrating within the macrostate before leaving.</p>"},{"location":"tutorials/hummerszabo/#create-trajectories","title":"Create Trajectories\u00b6","text":"<p>To demonstrate the effect we create 3 sets of trajectories. Starting with $h\\gg k$ were we have an optimal lumping, $h=k$ were the lumping is not justified, to $h &lt;k$ were the lumping is poorly chosen.</p>"},{"location":"tutorials/hummerszabo/#implied-timescales","title":"Implied Timescales\u00b6","text":"<p>We find here that for all three cases, the HS-projection is able to completely reproduce the Markovian microstate dynamics. Even for the first case, were $h = 4*k$, we find that we need a lag time $\\tau\\approx10$ to converge close to the true time scale.</p>"},{"location":"tutorials/hummerszabo/#chapman-kolmogorov-tests","title":"Chapman-Kolmogorov Tests\u00b6","text":"<p>The same picture emerges for the Chapman-Kolmogorov tests. Here we see that HS-projection overestimates slightly the metastability, but besides of that, it is captures for all rate pairs the correct dynamics.</p>"},{"location":"tutorials/hummerszabo/#rates-h020-k005","title":"Rates $h=0.20, k=0.05$\u00b6","text":""},{"location":"tutorials/hummerszabo/#eq","title":"EQ\u00b6","text":""},{"location":"tutorials/hummerszabo/#hs-projection","title":"HS-projection\u00b6","text":""},{"location":"tutorials/hummerszabo/#rates-h010-k010","title":"Rates $h=0.10, k=0.10$\u00b6","text":""},{"location":"tutorials/hummerszabo/#eq","title":"EQ\u00b6","text":""},{"location":"tutorials/hummerszabo/#hs-projection","title":"HS-projection\u00b6","text":""},{"location":"tutorials/hummerszabo/#rates-h010-k020","title":"Rates $h=0.10, k=0.20$\u00b6","text":""},{"location":"tutorials/hummerszabo/#eq","title":"EQ\u00b6","text":""},{"location":"tutorials/hummerszabo/#hs-projection","title":"HS-projection\u00b6","text":""},{"location":"tutorials/msm/","title":"Estimation and Validation of MSM","text":"In\u00a0[1]: Copied! <pre>import msmhelper as mh\nfrom msmhelper.utils import datasets\n\nlagtime = 1  # given in units of timesteps\n\n# to mimic real MD data, here we use a non-Markovian trajectory\n_, traj = datasets.hummer15_8state(0.2, 0.1, int(1e6), return_macrotraj=True)\n</pre> import msmhelper as mh from msmhelper.utils import datasets  lagtime = 1  # given in units of timesteps  # to mimic real MD data, here we use a non-Markovian trajectory _, traj = datasets.hummer15_8state(0.2, 0.1, int(1e6), return_macrotraj=True) In\u00a0[2]: Copied! <pre>tmat, states = mh.msm.estimate_markov_model(traj, lagtime)\nprint(f'T_ij = \\n{tmat}\\nstates = {states}')\n</pre> tmat, states = mh.msm.estimate_markov_model(traj, lagtime) print(f'T_ij = \\n{tmat}\\nstates = {states}') <pre>T_ij = \n[[0.9500412  0.0499588  0.         0.        ]\n [0.04964252 0.90086997 0.04948752 0.        ]\n [0.         0.05020706 0.89969475 0.05009819]\n [0.         0.         0.04962434 0.95037566]]\nstates = [1 2 3 4]\n</pre> In\u00a0[3]: Copied! <pre>straj = mh.StateTraj(traj)\ntmat, states = straj.estimate_markov_model(lagtime)\nprint(f'T_ij = \\n{tmat}\\nstates = {states}')\n</pre> straj = mh.StateTraj(traj) tmat, states = straj.estimate_markov_model(lagtime) print(f'T_ij = \\n{tmat}\\nstates = {states}') <pre>T_ij = \n[[0.9500412  0.0499588  0.         0.        ]\n [0.04964252 0.90086997 0.04948752 0.        ]\n [0.         0.05020706 0.89969475 0.05009819]\n [0.         0.         0.04962434 0.95037566]]\nstates = [1 2 3 4]\n</pre> <p>At first glance, creating an instance of the <code>StateTraj</code> class may seem like an unnecessary additional step, but it offers several advantages. First, when estimating the Markov model multiple times, the object-oriented approach has a major performance boost by converting the trajectory to the <code>StateTraj</code> format once before. Second, using the Hummer-Szabo projection requires the use of the object-oriented approach, specifically the <code>LumpedStateTraj</code> class.</p> <p>Once the Markov model is estimated, it's important to validate it to ensure that it accurately represents the system being studied. In the following section, we will cover the validation of a Markov model using <code>msmhelper</code>.</p> In\u00a0[4]: Copied! <pre>lagtimes = range(1, 15)\nimpl_times = mh.msm.implied_timescales(traj, lagtimes, ntimescales=3)\n</pre> lagtimes = range(1, 15) impl_times = mh.msm.implied_timescales(traj, lagtimes, ntimescales=3) <p>To visualize the results we will use matplotlib.</p> In\u00a0[5]: Copied! <pre>import prettypyplot as pplt\nfrom matplotlib import pyplot as plt\n\npplt.use_style(figsize=(5, 2), colors='pastel_autumn', latex=False)\n\ndef plot_impl_times(impl_times):\n    \"\"\"Plot the implied timescales\"\"\"\n    _, ax = plt.subplots()\n    for idx, impl_time in enumerate(impl_times.T):\n        ax.plot(lagtimes, impl_time, label=f'$t_{idx + 1}$')\n\n    ax.set_xlim(lagtimes[0], lagtimes[-1])\n    # highlight diagonal\n    ax.fill_between(ax.get_xlim(), ax.get_xlim(), color='pplt:grid')\n    ax.set_ylim(0, impl_times.max() * 1.05)\n    ax.set_xlabel(r'lag time $\\tau$ [frames]')\n    ax.set_ylabel('time scale [frames]')\n    pplt.legend(outside='right', frameon=False)\n\nplot_impl_times(impl_times)\n</pre> import prettypyplot as pplt from matplotlib import pyplot as plt  pplt.use_style(figsize=(5, 2), colors='pastel_autumn', latex=False)  def plot_impl_times(impl_times):     \"\"\"Plot the implied timescales\"\"\"     _, ax = plt.subplots()     for idx, impl_time in enumerate(impl_times.T):         ax.plot(lagtimes, impl_time, label=f'$t_{idx + 1}$')      ax.set_xlim(lagtimes[0], lagtimes[-1])     # highlight diagonal     ax.fill_between(ax.get_xlim(), ax.get_xlim(), color='pplt:grid')     ax.set_ylim(0, impl_times.max() * 1.05)     ax.set_xlabel(r'lag time $\\tau$ [frames]')     ax.set_ylabel('time scale [frames]')     pplt.legend(outside='right', frameon=False)  plot_impl_times(impl_times) <p>We find that the third time scale $t_3$ is constant for all lag times. The second time scale converges around $\\tau\\approx 5$ and the slowest timescales $t_1$ at around $\\tau\\approx 10$.</p> In\u00a0[6]: Copied! <pre># change figsize\npplt.update_style(figsize=(5, 1))\n\nlagtimes = [1, 5, 10]\ntmax = 650\n\n# estimating the CK test\nck = mh.msm.ck_test(traj, lagtimes, tmax)\n\n# plot the results\n_ = mh.plot.plot_ck_test(ck=ck, grid=(1, 4))\n</pre> # change figsize pplt.update_style(figsize=(5, 1))  lagtimes = [1, 5, 10] tmax = 650  # estimating the CK test ck = mh.msm.ck_test(traj, lagtimes, tmax)  # plot the results _ = mh.plot.plot_ck_test(ck=ck, grid=(1, 4)) <p>In this simple 4 state model, we see directly the connection between both approaches. The slowest time scale $t_1\\approx 45$ describes the escape time of the first and last state (S1/S4). The non-convergence of time scale $t_1$ at $\\tau=5$ results directly to the offset between the black curve (MD) and the model prediction for state S1 and S4.</p>"},{"location":"tutorials/msm/#estimation-and-validation-of-a-markov-state-model","title":"Estimation and Validation of a Markov State Model\u00b6","text":"<p>For the interested user, we recommend to read \"Markov models of molecular kinetics: Generation and validation\" by Prinz et al..</p>"},{"location":"tutorials/msm/#estimation-of-a-markov-state-model","title":"Estimation of a Markov State Model\u00b6","text":"<p>Now that we have covered the theoretical background of Markov state modeling, let us dive into how to generate a Markov model using <code>msmhelper</code>. The package provides two approaches for creating a Markov model: a method-based approach and an object-oriented approach via the <code>StateTraj</code> class.</p> <p>Let's start by importing the module and create a toy state trajectory. If you want to follow along this tutorial directly with your data, feel free to load your data, e.g. with <code>traj = np.loadtxt(filename)</code>. It should be noted that, the lag time is here chosen arbitrary. In the second section, we will discuss on how to choose an appropriate lag time.</p>"},{"location":"tutorials/msm/#method-based-approach","title":"Method-Based Approach\u00b6","text":"<p>Let's start with the estimation of a Markov model using the method approach. With the method <code>mh.estimate_markov_model</code>, the estimation of a Markov model can be achieved.</p>"},{"location":"tutorials/msm/#object-oriented-approach-via-statetraj","title":"Object-Oriented Approach via <code>StateTraj</code>\u00b6","text":"<p>Alternatively, the object-oriented approach involves creating an instance of the <code>StateTraj</code> class and calling its methods to estimate the Markov state model.</p>"},{"location":"tutorials/msm/#validation-of-a-markov-state-model","title":"Validation of a Markov State Model\u00b6","text":"<p>Once we have estimated a Markov state model, it is important to validate it to ensure that it accurately represents the system being studied. Two commonly used validation techniques are the implied timescales and Chapman-Kolmogorov tests.</p> <p>In the following, we will show how to use the implied timescales and Chapman-Kolmogorov tests to validate a Markov state model using <code>msmhelper</code>. While this is a more didactic approach, it is easier to simply use the provided command line interface, e.g. <code>$ msmhelper ck-test</code>.</p>"},{"location":"tutorials/msm/#implied-timescales","title":"Implied Timescales\u00b6","text":"<p>Implied timescales are a measure of the time scales of the Markov state model. They can be used to assess the convergence of the Markov state model, if the model converged the time scales is constant. They are defined by $$t_i = - \\frac{t_\\text{lag}}{\\log(\\lambda_i)}$$ where $\\lambda_i$ is the $i$-th lefthanded eigenvalue of the row-normalized transition probability matrix $T_{kl}$.</p> <p>Estimating the implied timescales is straight forward and can be achieved via</p>"},{"location":"tutorials/msm/#chapman-kolmogorov-test","title":"Chapman-Kolmogorov Test\u00b6","text":"<p>The Chapman-Kolmogorov (CK) test, on the other hand, is a statistical test that measures how well the Markov state model reproduces the dynamics of the original system. The test involves propagating the Markov state model for a given amount of time steps and comparing the distribution of states obtained from the simulation to the distribution of states obtained from the original trajectory, so if $$T(\\tau n) = T^n(\\tau)$$ holds.</p> <p>Estimating the CK test we need to specify for which lag times we want to validate the model. This is straight forward and can be achieved via</p>"},{"location":"tutorials/msmhelper/","title":"msmhelper","text":"<p>This package is designed for the analysis of discrete time series data from Molecular Dynamics (MD) simulations. It focuses on Markov state modeling (MSM), a powerful technique for analyzing complex systems, and provides a set of functions for constructing and analyzing Markov models, including methods calculating transition probabilities, and fitting models to data. The package is suitable for researchers and engineers who need to analyze large and complex datasets in order to gain insights into the behavior of the underlying dynamics.</p> <p>The module is structured into the following submodules:</p> <ul> <li> <p>io: This submodule contains all methods related to reading data from text files and writing data to text files, including helpful header comments.</p> </li> <li> <p>md: This submodule offers techniques for the analysis of state trajectories\u2014commonly known as Molecular Dynamics (MD)\u2014without relying on Markov state models. It encompasses functions for determining timescales, recognizing significant events, correcting dynamical anomalies, and evaluating various state discretization methods.  These functions provide a comprehensive solution for analyzing time-series data and understanding the underlying dynamics of complex systems.</p> </li> <li> <p>msm: This submodule contains methods related to Markov state modeling, a powerful technique for analyzing complex systems. It provides a set of functions for constructing and analyzing Markov models, including methods for calculating transition probabilities and estimating various time scales.</p> </li> <li> <p>plot: This submodule is dedicated to visualizing results. It offers a collection of functions for generating frequently used figures, such as the CK-test, implied timescales, and waiting times.</p> </li> <li> <p>statetraj: This submodule contains the two classes StateTraj and LumpedStateTraj which are used to represent the time series and allows for an improved performance.</p> </li> <li> <p>utils: This submodule provides utility functions that can be used to manipulate and test data, such as filtering and validation methods. The functions in this submodule can be used in conjunction with other parts of the software to perform a variety of tasks, making it an essential part of the package.</p> </li> </ul>"},{"location":"tutorials/theory/","title":"Theory of Markov State Modeling","text":""},{"location":"tutorials/theory/#introduction","title":"Introduction","text":"<p>Markov state models (MSMs) are used to analyze and understand the kinetics of protein conformational dynamics based on molecular dynamics (MD) simulations. In this context, MSMs are a type of statistical model that describe the transitions between different conformations (often referred to as states) over time by means of memoryless jumps. MD simulations provide atomistic details about the movement of the protein over time, but the resulting data can be difficult to analyze and interpret, especially when the protein undergoes complex conformational changes. Therefore, MSMs can be used to reduce the complex MD data to a simpler, more manageable representation of the protein's conformational dynamics, which allows understanding of the biological process of interest.</p> <p>In an MSM, the states are defined as discrete clusters of protein conformations and the transitions between states are modeled as a Markov process. This means that the probability of transition from one state to another depends only on the current state and not on the history of previous states. The resulting MSM can be used to calculate various quantities, such as the rate constants for transitions between states and the equilibrium populations of each state.</p> <p>Overall, MSMs are a useful tool for studying the kinetics of protein conformational changes in MD simulations, providing a simplified representation of complex protein dynamics that can be used to gain insight into the underlying mechanisms of protein behavior.</p>"},{"location":"tutorials/theory/#theoretical-background","title":"Theoretical Background","text":"<p>Markov state models are mathematical models that describe the transition probabilities between discrete states in a system of discrete time steps. The basic equation for a Markov state model is the following</p> \\[P(x_t = j | x_{t-1} = i) = T_{ij}\\] <p>where \\(T_{ij}\\) is the transition probability from state \\(i\\) to state \\(j\\) at time \\(t\\), and \\(P(x_t = j | x_{t-1} = i)\\) is the probability of the system being in state \\(j\\) at time \\(t\\), given that it was in state \\(i\\) at time \\(t-1\\).</p> <p>The transition probabilities are usually estimated from time-series data, such as molecular dynamics simulations, and can be organized into a transition matrix \\(T\\)</p> \\[T = \\{T_{ij}\\}\\] <p>where \\(T_{ij}\\) is the \\((i, j)\\)-th element of the matrix. The transition matrix defines the probability of moving from any one state to any other state in a single time step.</p> <p>The stationary distribution, \\(\\pi\\), is a probability distribution over the states that satisfies the following equation</p> \\[\\pi T = \\pi\\] <p>where the left-hand side is the distribution after one time step and the right-hand side is the distribution at the current time step. The stationary distribution represents the long-term behavior of the system and can be used to calculate various quantities, such as the equilibrium populations of each state.</p> <p>Further information can be found (freely available) on the following website, which provides a good introduction to the topic docs.markovmodel.org or the following article \"Markov models of molecular kinetics: Generation and validation\" by Prinz et al..</p>"},{"location":"tutorials/timescales/","title":"Waiting Times and Pathways","text":"In\u00a0[1]: Copied! <pre>import msmhelper as mh\nfrom msmhelper.utils import datasets\n\nprint(\n    f'4 state model:\\nT =\\n{datasets.nagel20_4state.tmat}\\n\\n'\n    f'6 tate model:\\nT =\\n{datasets.nagel20_6state.tmat}'\n)\n\n# generate random trajectories from transition matrices\nn_steps = int(5e4)\ntraj_4state = datasets.nagel20_4state(n_steps)\ntraj_6state = datasets.nagel20_6state(n_steps)\n</pre> import msmhelper as mh from msmhelper.utils import datasets  print(     f'4 state model:\\nT =\\n{datasets.nagel20_4state.tmat}\\n\\n'     f'6 tate model:\\nT =\\n{datasets.nagel20_6state.tmat}' )  # generate random trajectories from transition matrices n_steps = int(5e4) traj_4state = datasets.nagel20_4state(n_steps) traj_6state = datasets.nagel20_6state(n_steps) <pre>4 state model:\nT =\n[[0.92 0.04 0.04 0.  ]\n [0.1  0.7  0.1  0.1 ]\n [0.1  0.1  0.7  0.1 ]\n [0.   0.04 0.04 0.92]]\n\n6 tate model:\nT =\n[[0.9  0.03 0.07 0.   0.   0.  ]\n [0.05 0.63 0.15 0.07 0.1  0.  ]\n [0.08 0.04 0.6  0.14 0.14 0.  ]\n [0.   0.12 0.15 0.5  0.15 0.08]\n [0.   0.04 0.16 0.1  0.6  0.1 ]\n [0.   0.   0.   0.08 0.02 0.9 ]]\n</pre> In\u00a0[2]: Copied! <pre>start, final = 1, 4\nwts = mh.md.estimate_wt(traj_4state, start, final)\n\nprint(f'Identified waiting times [frames]:\\n{wts}')\n</pre> start, final = 1, 4 wts = mh.md.estimate_wt(traj_4state, start, final)  print(f'Identified waiting times [frames]:\\n{wts}') <pre>Identified waiting times [frames]:\n[  4  39 141  33  26  18 136  34  22  17 147 123  12  62  23  68  18  70\n  25 110  34  42  36  14  29  21  25  15  18  60  36  34  77  29  60   5\n  19  89   9  18   7  29  52  37  19  60  38   8   5  14  18  19  20  26\n  33  51  54  74  29   9  10   8  13   7  12  68   8  13  11  14   6   3\n   7  10  23  22  30  15  17   6  40  16   7  11  33  21  31  16  14  50\n  34  12  10  20  31   4   4   6  22   7   6   5 106  46   5  63  35   6\n  27   4  59  20  23  93  16  62  25   6  10   2  15  26   7  30  51   7\n 145 157  60  57  95  46  20   9   7   5   3  98  16  44  12  26  65  19\n  61   4  54  66  67  66  56  32  22  47  24  66  23  18  30   3   6  34\n  26  51  16  15  40 100  45  28   4  56 132  19  58  64  14  12  86  34\n  84   5  14  90  19  72  43   5  13   9  27  35  21  64  43  16  22   8\n  83  34  22  93  41  23  32   2  13  64  47  12  71  84  27  23  15  21\n   5  17  46 107  85  27  24  15  11   7  22  82  28  57  19  22  26  13\n  13  16  32  58  65  60  44  14  46  25   4  30   4 127  46  97  60  32\n  25   3  18  12   5  40  21   7  14  14 108  11  87  74  15  22  20   9\n  49  47  43  32  11  12  42  18   5 101  56  29   4  13   4  36  25  35\n  12  28  37   4  31  87  56  60  14  18  29  24  21  21  38  13  52  50\n  45  18  32  11  27  24  20   8  37 138   7  23  54   9  53  14  15  23\n  36  19  11  26  48  31   6  20  23  12   9   9   7  21  39  11  31  15\n  71  51  18  45  70  11  59   5  37   9  14  35  65  16  56  37  21  45\n  66  30 123   5  43  17  54  87  11  13  11  16  73  93  18   3   3  18\n  49  18  17  55  63  22  32 132  22  11  36  41  80   2   6  36  10  12\n  36   5  31   8 104  25  23  15  26  33   7  18  38  38  22  22  17  65\n  25  22   9  18  33  31  19 132  42  56   6  82  82  62 109   3  88  80\n  67 133  27  55  22  66  28  21  50  11  28  22  32   8  38  49  18  38\n   4  40  32  29  17  41  18  31  46  34  66  41  13  12   6 133 142  18\n   2  26   8  53   5  77  19  67  44  11   4  56  44  28  97  17  22  29\n  20  30  50  22   3  99  77  10  12  56  57  41  64  27  48  39  23  41\n  43  52  10  20   8  77  41  22  41  16  30  29  20  21  56  91  28  22\n  21  16  14   9  27   2  14  28   2  60  10  74  53  63 109   9  13  35\n  27 128  26  25  59  11 134  11  14  53  40  10  19  11  32  14  26  21\n  15  16  35  32  56  37  25  21  31  22   6  42   6  37  22 152  11  20\n  70  28 100 125  14  36  13  13  14  80  14  46  65   5  38  11  24  11\n   9  24  60  35  19  75   4  11  11  85  21   9  64  13  11  14  16  17\n  12  28  73   6  20   2  10  94  21  16   5  61  10  16  22   8  41  24\n  12   3  15  13  13  25  12  14   7  41  18  14  34   6  13  32   6  28\n  22 109   9  73 128  18  49  10   5   4  32  10  16  76  89  53  18  85\n  25  63  46  18  15  38  38   2  15  27  13  26   4  17   5  21  32  31\n  55  23   5  16  65  78  15  74  11  23  43  15  18  32   8  31  32  22\n  58  72  34  14   7  19  57  30   3  26   8  14  60  14  17  56  17  54\n 105  13]\n</pre> <p>This list reveals directly that the waiting times are not normally distributed. To make it clearer, we visualize them results by a simple histogram</p> In\u00a0[3]: Copied! <pre>import numpy as np\nimport prettypyplot as pplt\nfrom matplotlib import pyplot as plt\n\npplt.use_style(figsize=(5,2), latex=False, colors='paula')\n\nfig, ax = plt.subplots()\n# ensure that bins are integers.\nbins = np.arange(0, wts.max() + 5, 5)\nax.hist(wts, bins=bins, density=True)\nax.set_xlabel(r'waiting time $t^\\mathrm{wt}$')\nax.set_ylabel(r'$P(t^\\mathrm{wt})$')\nplt.show()\n</pre> import numpy as np import prettypyplot as pplt from matplotlib import pyplot as plt  pplt.use_style(figsize=(5,2), latex=False, colors='paula')  fig, ax = plt.subplots() # ensure that bins are integers. bins = np.arange(0, wts.max() + 5, 5) ax.hist(wts, bins=bins, density=True) ax.set_xlabel(r'waiting time $t^\\mathrm{wt}$') ax.set_ylabel(r'$P(t^\\mathrm{wt})$') plt.show() In\u00a0[4]: Copied! <pre>paths = mh.md.estimate_paths(traj_4state, start, final)\n\n# Let's format the output\nprint(f'Identified pathways with time of events given in [frames]:')\nfor path, pathtimes in paths.items():\n    print(f'{path}: {pathtimes}')\n</pre> paths = mh.md.estimate_paths(traj_4state, start, final)  # Let's format the output print(f'Identified pathways with time of events given in [frames]:') for path, pathtimes in paths.items():     print(f'{path}: {pathtimes}') <pre>Identified pathways with time of events given in [frames]:\n(1, 3, 4): [4, 39, 141, 17, 147, 123, 23, 110, 34, 36, 21, 29, 19, 89, 9, 29, 52, 37, 60, 8, 14, 20, 33, 51, 54, 8, 13, 7, 8, 13, 3, 22, 15, 6, 11, 21, 31, 16, 12, 31, 6, 6, 20, 23, 2, 26, 51, 7, 5, 3, 16, 44, 54, 66, 67, 32, 47, 23, 34, 26, 15, 100, 56, 19, 12, 86, 5, 14, 5, 13, 9, 35, 64, 43, 16, 22, 84, 23, 15, 21, 5, 85, 15, 22, 57, 19, 22, 26, 13, 60, 14, 30, 4, 5, 21, 87, 15, 9, 49, 12, 5, 101, 29, 4, 25, 12, 87, 14, 18, 18, 32, 27, 7, 11, 12, 39, 71, 51, 18, 5, 35, 16, 45, 123, 11, 13, 3, 3, 55, 63, 132, 41, 80, 36, 12, 36, 8, 15, 26, 18, 17, 25, 18, 19, 132, 56, 3, 80, 22, 28, 28, 22, 32, 66, 142, 26, 53, 5, 77, 19, 4, 44, 28, 97, 29, 20, 50, 99, 77, 10, 12, 23, 8, 22, 41, 21, 56, 91, 28, 14, 27, 2, 14, 2, 109, 9, 13, 26, 11, 14, 53, 11, 14, 21, 16, 32, 56, 31, 42, 70, 125, 14, 36, 80, 14, 46, 5, 11, 24, 9, 24, 60, 35, 19, 75, 11, 85, 21, 13, 16, 17, 12, 6, 10, 21, 22, 41, 24, 3, 14, 14, 6, 22, 109, 10, 5, 32, 10, 16, 89, 18, 63, 18, 38, 15, 5, 5, 15, 74, 8, 72, 34, 7, 3, 26, 13]\n(1, 2, 4): [33, 18, 12, 68, 70, 25, 36, 34, 5, 7, 38, 5, 19, 26, 74, 9, 68, 11, 14, 10, 23, 30, 17, 40, 7, 33, 50, 34, 10, 4, 4, 6, 22, 5, 5, 63, 27, 4, 59, 93, 16, 25, 15, 145, 157, 60, 57, 95, 46, 98, 12, 65, 19, 61, 4, 24, 18, 30, 3, 6, 51, 45, 28, 4, 132, 58, 14, 34, 84, 90, 19, 43, 8, 41, 23, 32, 2, 64, 12, 27, 46, 107, 27, 24, 11, 7, 82, 13, 16, 65, 44, 127, 46, 97, 60, 32, 25, 3, 40, 108, 74, 22, 20, 47, 43, 32, 11, 4, 36, 35, 28, 37, 4, 31, 24, 38, 13, 50, 45, 20, 8, 37, 23, 54, 53, 15, 36, 19, 6, 20, 9, 7, 11, 31, 15, 45, 70, 11, 59, 37, 9, 56, 66, 30, 5, 43, 11, 93, 18, 18, 17, 22, 32, 11, 36, 2, 6, 10, 5, 31, 25, 23, 38, 38, 22, 65, 9, 33, 31, 6, 62, 109, 88, 66, 11, 49, 18, 38, 40, 32, 29, 18, 46, 34, 41, 13, 18, 2, 44, 11, 17, 22, 3, 56, 57, 64, 41, 52, 10, 20, 77, 41, 16, 30, 20, 21, 9, 74, 63, 35, 27, 59, 11, 19, 32, 26, 21, 6, 6, 11, 20, 28, 100, 13, 13, 11, 11, 73, 2, 94, 16, 5, 10, 16, 8, 12, 15, 13, 25, 18, 34, 28, 73, 128, 18, 4, 76, 25, 46, 15, 38, 2, 27, 4, 32, 31, 55, 23, 65, 78, 23, 32, 32, 22, 19, 57, 60, 17, 17, 54]\n(1, 2, 3, 4): [26, 136, 34, 62, 18, 77, 60, 18, 18, 6, 7, 16, 20, 62, 30, 7, 20, 26, 56, 66, 16, 72, 93, 13, 47, 17, 32, 4, 12, 14, 18, 56, 56, 29, 11, 138, 14, 23, 26, 48, 23, 21, 65, 21, 17, 16, 73, 22, 104, 7, 22, 55, 50, 38, 17, 12, 133, 8, 67, 56, 41, 27, 48, 39, 22, 60, 10, 40, 10, 15, 35, 22, 37, 22, 152, 14, 65, 38, 9, 28, 13, 12, 41, 49, 26, 17, 21, 16, 58, 14, 8]\n(1, 3, 2, 4): [22, 18, 42, 14, 29, 25, 15, 60, 19, 29, 10, 12, 14, 7, 106, 46, 35, 6, 10, 7, 9, 66, 22, 40, 64, 27, 21, 83, 34, 22, 71, 28, 58, 46, 25, 18, 7, 14, 11, 42, 13, 60, 21, 21, 52, 24, 9, 31, 9, 14, 37, 54, 87, 49, 18, 33, 22, 42, 82, 82, 67, 133, 27, 21, 8, 4, 41, 31, 6, 22, 30, 43, 29, 16, 28, 53, 128, 25, 134, 37, 25, 4, 11, 64, 14, 20, 61, 7, 13, 32, 6, 9, 53, 85, 13, 11, 43, 15, 18, 31, 30, 14, 14, 56, 105]\n</pre> <p>If we now want to see how frequent these different pathways occur, we can simply reduce the above result via</p> In\u00a0[5]: Copied! <pre>path_frequencies = sorted(\n    ((path, len(pathtimes)) for path, pathtimes in paths.items()),\n    key=lambda pathfreq: pathfreq[1],\n    reverse=True,\n)\nn_sampled_paths = np.sum([freq for _, freq in path_frequencies])\n\n# Let's format the output\nprint(f'Identified pathways with time of events given in [frames]:')\nfor path, freq in path_frequencies:\n    print(f'{path}:\\t{freq / n_sampled_paths:.1%}')\n</pre> path_frequencies = sorted(     ((path, len(pathtimes)) for path, pathtimes in paths.items()),     key=lambda pathfreq: pathfreq[1],     reverse=True, ) n_sampled_paths = np.sum([freq for _, freq in path_frequencies])  # Let's format the output print(f'Identified pathways with time of events given in [frames]:') for path, freq in path_frequencies:     print(f'{path}:\\t{freq / n_sampled_paths:.1%}') <pre>Identified pathways with time of events given in [frames]:\n(1, 2, 4):\t37.4%\n(1, 3, 4):\t35.5%\n(1, 3, 2, 4):\t14.5%\n(1, 2, 3, 4):\t12.6%\n</pre> <p>Comparing these results to the true values of $37.5\\%$ and $12.5\\%$ (see Nagel et al. 20), we find a rather good agreement.</p> In\u00a0[6]: Copied! <pre>nsteps = int(1e7)\nlagtime = 1\nwts_msm = mh.msm.estimate_wt(\n    trajs=traj_4state,\n    lagtime=lagtime,\n    start=start,\n    final=final,\n    steps=nsteps,\n    return_list=True,\n)\n\nprint(f'Identified number of waiting times events: {len(wts_msm)}')\n\nfig, ax = plt.subplots()\n# ensure that bins are integers.\nbins_msm = np.arange(0, wts_msm.max() + 1)\nax.hist(wts, bins=bins, color='C4', density=True, alpha=0.8)\nax.hist(wts_msm, bins=bins_msm, density=True, alpha=0.8)\nax.set_xlabel(r'waiting time $t^\\mathrm{wt}$')\nax.set_ylabel(r'$P(t^\\mathrm{wt})$')\nplt.show()\n</pre> nsteps = int(1e7) lagtime = 1 wts_msm = mh.msm.estimate_wt(     trajs=traj_4state,     lagtime=lagtime,     start=start,     final=final,     steps=nsteps,     return_list=True, )  print(f'Identified number of waiting times events: {len(wts_msm)}')  fig, ax = plt.subplots() # ensure that bins are integers. bins_msm = np.arange(0, wts_msm.max() + 1) ax.hist(wts, bins=bins, color='C4', density=True, alpha=0.8) ax.hist(wts_msm, bins=bins_msm, density=True, alpha=0.8) ax.set_xlabel(r'waiting time $t^\\mathrm{wt}$') ax.set_ylabel(r'$P(t^\\mathrm{wt})$') plt.show() <pre>Identified number of waiting times events: 144131\n</pre> <p>So we see, that we get a smooth interpolation of the waiting time distribution.</p> In\u00a0[7]: Copied! <pre>paths = mh.msm.estimate_paths(\n    trajs=traj_4state,\n    lagtime=lagtime,\n    start=start,\n    final=final,\n    steps=nsteps,\n)\n\npath_frequencies = sorted(\n    ((path, len(pathtimes)) for path, pathtimes in paths.items()),\n    key=lambda pathfreq: pathfreq[1],\n    reverse=True,\n)\nn_sampled_paths = np.sum([freq for _, freq in path_frequencies])\n\n# Let's format the output\nprint(f'Identified pathways with time of events given in [frames]:')\nfor path, freq in path_frequencies:\n    print(f'{path}:\\t{freq / n_sampled_paths:.1%}')\n</pre> paths = mh.msm.estimate_paths(     trajs=traj_4state,     lagtime=lagtime,     start=start,     final=final,     steps=nsteps, )  path_frequencies = sorted(     ((path, len(pathtimes)) for path, pathtimes in paths.items()),     key=lambda pathfreq: pathfreq[1],     reverse=True, ) n_sampled_paths = np.sum([freq for _, freq in path_frequencies])  # Let's format the output print(f'Identified pathways with time of events given in [frames]:') for path, freq in path_frequencies:     print(f'{path}:\\t{freq / n_sampled_paths:.1%}') <pre>Identified pathways with time of events given in [frames]:\n(1, 2, 4):\t38.5%\n(1, 3, 4):\t36.8%\n(1, 2, 3, 4):\t12.6%\n(1, 3, 2, 4):\t12.1%\n</pre> In\u00a0[8]: Copied! <pre>wtd = mh.msm.estimate_wtd(\n    trajs=traj_4state,\n    max_lagtime=10,\n    start=start,\n    final=final,\n    steps=nsteps,\n)\nfig, ax = plt.subplots()\nax = mh.plot.plot_wtd(wtd=wtd, ax=ax)\nplt.show()\n</pre> wtd = mh.msm.estimate_wtd(     trajs=traj_4state,     max_lagtime=10,     start=start,     final=final,     steps=nsteps, ) fig, ax = plt.subplots() ax = mh.plot.plot_wtd(wtd=wtd, ax=ax) plt.show() <p>An interesting observation we have made is that the waiting time $t$ shows a linear scaling relationship with the lag time $\\tau_\\text{lag}$. However, our analysis also revealed that when comparing the timescales to the reference simulation (referred to as \"MD\" in the figure), using a lag time of $\\tau_\\text{lag} \\ge 6$ leads to overestimation of the waiting timescale. This effect is due to selecting a lag time that is longer than the fastest intrinsic timescale of the process. It is worth noting that unlike the commonly used implied timescale, which typically converges towards the true value, waiting times do not exhibit such behavior, and therefore, caution must be exercised when comparing these intrinsically different time scales.</p>"},{"location":"tutorials/timescales/#waiting-times-and-pathways-of-markov-models","title":"Waiting Times and Pathways of Markov Models\u00b6","text":"<p>For a more detailed introduction to this topic, please refer to following article.</p> <p>MSMPathfinder: Identification of Pathways in Markov State Models Daniel Nagel, Anna Weber, and Gerhard Stock J. Chem. Theory Comput. 2020 16 (12), 7874-7882 doi: 10.1021/acs.jctc.0c00774</p>"},{"location":"tutorials/timescales/#introduction","title":"Introduction\u00b6","text":"<p>In the context of biochemical systems, understanding the kinetics of protein dynamics is critical for gaining insight into the underlying mechanisms of biological function. The Markov state model provides a powerful framework for characterizing the kinetics of a system. One can use it to estimate the waiting times $t^\\text{wt}$ between transitions, the transition path times $t^\\text{tt}$, and the pathways that the system takes between states.</p> <p>It is important to note that waiting times $t^\\text{wt}$, transition path times $t^\\text{tt}$, and means first passage times $t^\\text{mfpt}$ are related but distinct quantities. Waiting times are the times between individual transitions. Transition path times, on the other hand, are the times required for the system to traverse a particular path between two states. Finally, mean first passage times are the average times required for the system to reach a particular state for the first time. In general, it holds that $$ t^\\text{wt} \\ge t^\\text{mfpt} \\ge t^\\text{tt}\\;. $$ In general, we are interested in comparisons with experiments. For example, in biochemical experiments, one can measure the times required for a system (an ensemble) to transition from one state to another. Since this directly corresponds to the waiting time distribution, we mainly focus on it and try to relate it to the corresponding pathways.</p> <p>In this section, we will focus on the waiting times and transition path times and show how to estimate them using either the Markov state model or directly the state trajectory. We will also discuss how to visualize the pathways and interpret the results in the context of the toy system being studied.</p>"},{"location":"tutorials/timescales/#model-systems","title":"Model Systems\u00b6","text":"<p>In the following we will use two simple toy models introduced and discussed by Nagel et al. 20, namely, the following 4-state and 6-state models</p>"},{"location":"tutorials/timescales/#estimating-timescales-from-md","title":"Estimating Timescales from MD\u00b6","text":"<p>Before relying on Markov state models to analyse the expected times and pathways of a given process, we first want to show to analyse the raw data. In the following this is referred as MD due to the fact that it is the truly simulated dynamic of the MD simulation.</p> <p>Let us start by analysing the $1\\to4$ process of the 4 state model. Within this model, this is the most interesting one, due to the fact that these two states are not directly connected.</p>"},{"location":"tutorials/timescales/#estimating-paths-from-md","title":"Estimating Paths from MD\u00b6","text":"<p>So let us now take a look at the pathways.</p>"},{"location":"tutorials/timescales/#estimating-timescales-from-msm","title":"Estimating Timescales from MSM\u00b6","text":"<p>Now we want to compare how well the Markov model is able to recover the true waiting time distributions and path frequencies.</p>"},{"location":"tutorials/timescales/#estimating-paths-from-msm","title":"Estimating Paths from MSM\u00b6","text":"<p>Estimating pathways is straight forward and can be achieved by,</p>"},{"location":"tutorials/timescales/#comparing-waiting-times-of-md-vs-msm","title":"Comparing Waiting Times of MD vs MSM\u00b6","text":"<p>Finally, we want to directly compare the effect of alternating the lag time $\\tau$ on the waiting time distribution. Similar to the implied timescale plot, we can also compare the waiting time distribution for a given lag time to the resulting MD waiting time distribution. To circumvent the problem of poor statistics, we rely in this analysis only on statistical quantities instead of the probability distributions: Namely, the three quartiles $Q_{1,2,3}$, and the interquartile range $\\mathrm{IQR}=Q_3 - Q_1$.</p> <p>This can be easily achieved with the predefined functions:</p>"},{"location":"tutorials/timescales/#concluding-remarks","title":"Concluding Remarks\u00b6","text":"<p>In conclusion, we have learned how to estimate waiting times and transition pathways directly from the state trajectory and via Markov state modeling. By analyzing the timescales and pathways of a system, we can gain valuable insights into its dynamics and compare them with experimental observations. We hope that this tutorial has provided a useful introduction to the estimation of waiting times and pathways in protein dynamics and will inspire further investigations into the dynamics of complex biological systems. We will continue to see how the Hummer-Szabo projection can be used to improve the general MSM prediction of lumped microstate dynamics.</p>"}]}